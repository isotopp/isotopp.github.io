<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>unix on Die wunderbare Welt von Isotopp</title>
    <link>https://blog.koehntopp.info/tags/unix.html</link>
    <description>Recent content in unix on Die wunderbare Welt von Isotopp</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 12 Dec 2022 21:36:25 +0000</lastBuildDate><atom:link href="https://blog.koehntopp.info/tags/unix/feed.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Fertig gelesen: UNIX: A History and a Memoir</title>
      <link>https://blog.koehntopp.info/2021/09/05/fertig-gelesen-unix-a-history-and-a-memoir.html</link>
      <pubDate>Sun, 05 Sep 2021 15:47:06 +0000</pubDate>
      
      <guid>https://blog.koehntopp.info/2021/09/05/fertig-gelesen-unix-a-history-and-a-memoir.html</guid>
      <description>&lt;p&gt;The memoir of Brian Kernighan, and the story of how UNIX came to be and what working at Bell Labs was like at that time:
&lt;a href=&#34;https://www.amazon.de/UNIX-History-English-Brian-Kernighan-ebook/dp/B07ZQHX3R1&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;UNIX: A History and a Memoir&lt;/a&gt;

 is required reading for anyone who wants to know where Unix concepts came from and what ideas were behind its inception.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.amazon.de/UNIX-History-English-Brian-Kernighan-ebook/dp/B07ZQHX3R1&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/2021/09/unix.jpg&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;

&lt;/a&gt;

&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&amp;quot;&lt;a href=&#34;https://www.amazon.de/UNIX-History-English-Brian-Kernighan-ebook/dp/B07ZQHX3R1&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;UNIX: A History and a Memoir&lt;/a&gt;

&amp;quot;, Brian Kernighan&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Kernighan takes us through the history and the setting of Bell Labs, why it existed and what it did.
He explains the hardware of the time, in terms of size, power and capabilities, and why Bell did get involved into writing an Operating System, and the failure of Multics.
Unix inception and its co-evolution with the C language was a kind of response to the Multics project, at the same time pioneering novel ideas and taking tested salvageable concepts from Multics, making something new and much more useful.&lt;/p&gt;
&lt;p&gt;While he roughly follows the timeline of Unix releases, Kernighan takes short detours, including mini-biographies of his colleagues and the influence they had on the design of the system and the ideas embodied in it.
He finishes with the commercialization of Unix, Unix descendants - BSD, Minix, Linux and Plan 9, and with the closure of Bell Labs.&lt;/p&gt;
&lt;p&gt;If you work with Linux, the C language or any Unix tools, you should read this book to understand where these things came from and what formed this environment.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Why do Ops and Sec people wear black</title>
      <link>https://blog.koehntopp.info/2020/08/19/why-do-ops-and-sec-people-wear-black.html</link>
      <pubDate>Wed, 19 Aug 2020 17:05:47 +0000</pubDate>
      
      <guid>https://blog.koehntopp.info/2020/08/19/why-do-ops-and-sec-people-wear-black.html</guid>
      <description>&lt;p&gt;For &lt;a href=&#34;https://www.imdb.com/title/tt0108756&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;reasons that don&amp;rsquo;t need exploring at this juncture&lt;/a&gt;

 I &lt;a href=&#34;https://twitter.com/isotopp/status/1296073392655933444&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;tweeted&lt;/a&gt;

&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Once upon a time there were shared boxes, on which the local Unix easily had 200-300 users, Junior Developers at a University.&lt;/p&gt;
&lt;p&gt;A /tmp/ls found easily 3-4 people per day that had . (dot) in their path.&lt;/p&gt;
&lt;p&gt;No particular reason. Why?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;and followed up with&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Hope is not a strategy.&lt;/p&gt;
&lt;p&gt;Neither is &lt;code&gt;curl stackoverflow | sudo bash&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;tmpls&#34;&gt;
    &lt;a href=&#34;#tmpls&#34;&gt;
	/tmp/ls
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;I was asked to explain: &amp;ldquo;What is /tmp/ls?&amp;rdquo;.&lt;/p&gt;
&lt;p&gt;/tmp/ls is a shell script installed as executable in /tmp/ls. If you have . (dot, the current directory) early in your path, it shadows the command /bin/ls, which you use to list the current directory.&lt;/p&gt;
&lt;p&gt;So when you &lt;code&gt;cd /tmp&lt;/code&gt; and then &lt;code&gt;ls&lt;/code&gt; you are executing my script instead of the actual &lt;code&gt;/bin/ls&lt;/code&gt; command. You are now inadvertently running my code under your permissions. When I finish my script with &lt;code&gt;exec /bin/ls &amp;quot;$@&amp;quot;&lt;/code&gt; you won&amp;rsquo;t even notice, because it will run the normal &lt;code&gt;/bin/ls&lt;/code&gt; command at the end.&lt;/p&gt;
&lt;p&gt;The mistake is to have any directory in your path that can contain code controlled by another person besides you and root. That is, a world-writeable &lt;code&gt;/usr/local/bin&lt;/code&gt; in - say - an AIX install would amount to the same exposure (A lot of old Unices such as AIX, HP/UX and SGI would ship with world writeable directories of one kind or the other by default).&lt;/p&gt;
&lt;h2 id=&#34;the-777-root-cron&#34;&gt;
    &lt;a href=&#34;#the-777-root-cron&#34;&gt;
	The 777 root cron
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;The same scenario is a script globally installed on all Macs by JAMF, running through cron as root every minute. The same JAMF sets the enclosing directory to 777 (full access for everybody). Due to how permissions work in Unix, this allows anybody to remove, rename or replace the script itself, no matter what the script permissions are.&lt;/p&gt;
&lt;p&gt;It is instant root for anybody who cares: You replace the script with your own content, wait a minute for the cron to hit it, and put the original script back. Or not, depending on how you feel that day.&lt;/p&gt;
&lt;p&gt;The remarkable part of this particular incident is that none of the multitude of endpoint security products also installed by the same JAMF detected or quarantined this script. So much for that.&lt;/p&gt;
&lt;h2 id=&#34;the-world-writeable-fileshare&#34;&gt;
    &lt;a href=&#34;#the-world-writeable-fileshare&#34;&gt;
	The world writeable fileshare
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Other fun things that should not have happened: A university of applied science exported their AIX home directories by NFS, world-writeable, once. That is, for several years, their site was a well known Shell-o-matic.&lt;/p&gt;
&lt;p&gt;Why is this bad?&lt;/p&gt;
&lt;p&gt;Anybody who mounted this on their own machine could create a user account with a matching UID, go into the mounted user home and drop a .rlogin file of appropriate content (The .rlogin reference should tell you how old that is).&lt;/p&gt;
&lt;p&gt;The fun part is that the university in question eventually migrated to Solaris, and that included all the&amp;hellip; interesting configuration.&lt;/p&gt;
&lt;p&gt;Apparently SMB fileshares can serve the same purpose. Also, Windows always has . (dot) in the front of the path, implicitly.&lt;/p&gt;
&lt;h2 id=&#34;external-storage&#34;&gt;
    &lt;a href=&#34;#external-storage&#34;&gt;
	External storage
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;A lot of people have world-readable backup devices such as a 644 /dev/rmt. If the backup tape from last night is left in that drive it does not matter much what the permissions on the original files are.&lt;/p&gt;
&lt;p&gt;You can read the files from backup, and restore them with any permission you like.&lt;/p&gt;
&lt;h2 id=&#34;this-makes-me-sad&#34;&gt;
    &lt;a href=&#34;#this-makes-me-sad&#34;&gt;
	This makes me sad
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;For some reasons each of these things, all of which are from personal experience up to 25 years ago, still happen today.&lt;/p&gt;
&lt;p&gt;That is why ops people wear black. Now you know.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Everything was a file, but we got better</title>
      <link>https://blog.koehntopp.info/2019/11/14/everything-was-a-file-but-we-got-better.html</link>
      <pubDate>Thu, 14 Nov 2019 11:42:07 +0000</pubDate>
      
      <guid>https://blog.koehntopp.info/2019/11/14/everything-was-a-file-but-we-got-better.html</guid>
      <description>&lt;p&gt;I fell into the Twitters again. &lt;a href=&#34;https://twitter.com/carrickdb/status/1194842452361789441&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;@CarrickDB&lt;/a&gt;

 joked about Unix,
Files and Directories:&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://twitter.com/carrickdb/status/1194842452361789441&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/everything-is-a-file.png&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;

&lt;/a&gt;

&lt;/p&gt;
&lt;p&gt;And that is a case of &amp;ldquo;Haha, only serious&amp;rdquo;. Because directories
used to be files, and that was a bad time. Check out the V7 Unix
&lt;a href=&#34;https://github.com/v7unix/v7unix/blob/master/v7/usr/src/cmd/mkdir.c#L49&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;mkdir&lt;/a&gt;


command. At this point in history we do not have a &lt;code&gt;mkdir(2)&lt;/code&gt;
syscall, yet, so we need to construct the entire directory in
multiple steps.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/v7unix/v7unix/blob/master/v7/usr/src/cmd/mkdir.c#L49&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;mknod(2)&lt;/code&gt; an inode that has the &lt;code&gt;S_IFDIR&lt;/code&gt; flag set&lt;/a&gt;

,
even if that macro does not even exist yet.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/v7unix/v7unix/blob/master/v7/usr/src/cmd/mkdir.c#L57&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;manually link the entry for the current directory &lt;code&gt;.&lt;/code&gt; into that&lt;/a&gt;

&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/v7unix/v7unix/blob/master/v7/usr/src/cmd/mkdir.c#L64&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;manually link the entry for the parent directory &lt;code&gt;..&lt;/code&gt; into that&lt;/a&gt;

&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This fragile and broken: &lt;code&gt;mkdir&lt;/code&gt; could be interrupted while
doing that or another program could try to race &lt;code&gt;mkdir&lt;/code&gt; while it
is doing that. In both cases we get directories that are invalid
and dangerous to traverse, because they break crucial
assumptions users make about directories.&lt;/p&gt;
&lt;p&gt;This is also before &lt;code&gt;readdir(2)&lt;/code&gt; and friends, so programs like
&lt;code&gt;ls&lt;/code&gt; &lt;a href=&#34;https://github.com/v7unix/v7unix/blob/master/v7/usr/src/cmd/ls.c#L304&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;open directories like files&lt;/a&gt;


and then make assumptions about the format of dentries on disk.
Specifically, they assume a 16 bit inode number and then a
filename of 14 characters or less and a directory that is an array
of these entries. Unfortunately, time has not been kind to the
assumption of 65535 files or less per partition, and also we
require filenames that are longer than 14 bytes these days.&lt;/p&gt;
&lt;p&gt;Finally have a look at the hot mess that the
&lt;a href=&#34;https://github.com/v7unix/v7unix/blob/master/v7/usr/src/cmd/rmdir.c#L29&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;rmdir&lt;/a&gt;


command is. What could probably go wrong?&lt;/p&gt;
&lt;p&gt;Well, &lt;a href=&#34;https://twitter.com/opheleon/status/1194941703632932865&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Jan Kraetzschmar&lt;/a&gt;


reminds us that this kind of non-atomic rmdir can also produce
structures in the filesystem that are disconnected from the main
tree starting at &lt;code&gt;/&lt;/code&gt;. In that case you end up with orphaned, unreachable
inodes that still have a non-zero link count. &lt;code&gt;fsck&lt;/code&gt; should be
able to find them and free them, but of course that would be a
disruptive operation. Making &lt;code&gt;mkdir&lt;/code&gt; and &lt;code&gt;rmdir&lt;/code&gt; system call avoids
all of these problems.&lt;/p&gt;
&lt;p&gt;That&amp;rsquo;s why all of this was fixed in 1984 or so, when BSD
FFS came around and we got long filenames, wider inodes,
&lt;code&gt;mkdir&lt;/code&gt;, &lt;code&gt;rmdir&lt;/code&gt; and &lt;code&gt;readdir&lt;/code&gt; as syscalls and many other
improvements.&lt;/p&gt;
&lt;h2 id=&#34;what-if-really-everything-was-a-file&#34;&gt;
    &lt;a href=&#34;#what-if-really-everything-was-a-file&#34;&gt;
	What if really everything was a file?
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Another decade later, around 1995 or so, we got Plan 9, not from
outer space, but from Bell Labs.&lt;/p&gt;
&lt;p&gt;It not only brought us Unicode everywhere, but also an
exploration of &amp;lsquo;What if really everything was a file?&amp;rsquo;,
including other machines on the network and processes on our
machine. From that we get todays
&lt;a href=&#34;https://en.wikipedia.org/wiki/Plan_9_from_Bell_Labs#/proc&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;procfs&lt;/a&gt;


in Linux (and in many other modern Unices).&lt;/p&gt;
&lt;p&gt;Except that you can&amp;rsquo;t &lt;code&gt;rm -rf /proc/1&lt;/code&gt; to shut down the box.&lt;/p&gt;
&lt;h2 id=&#34;things-that-still-are-not-a-file-and-should-be-dead&#34;&gt;
    &lt;a href=&#34;#things-that-still-are-not-a-file-and-should-be-dead&#34;&gt;
	Things that still are not a file, and should be dead
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;I am not going to mention System V IPC here at all. Not shm, not
sem, and not msq. They are abominations that should never have
escaped the lab cages they have been conceived in.&lt;/p&gt;
&lt;p&gt;There is &lt;code&gt;mmap&lt;/code&gt;, and mmap is good. Or can be, as long as you do
not conflate in memory and on disk representations of data, and
understand the value of MVCC. But that is another story and
should be told another day.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Bashismen</title>
      <link>https://blog.koehntopp.info/2019/03/04/bashismen.html</link>
      <pubDate>Mon, 04 Mar 2019 11:36:29 +0000</pubDate>
      
      <guid>https://blog.koehntopp.info/2019/03/04/bashismen.html</guid>
      <description>&lt;p&gt;I &lt;a href=&#34;https://twitter.com/isotopp/status/1102527703033491456&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;trolled Twitter&lt;/a&gt;

 with some Ha-Ha-Only-Serious.&lt;/p&gt;
&lt;p&gt;Every now and then someone complains on Twitter about the use of Bashisms in Shellscripts or legacy systems that are not completely Linux-compatible.
I usually troll back with the claim that anything that is not Linux is broken, and that anything that is not Bash is broken.&lt;/p&gt;
&lt;p&gt;That is of course a troll, and I am of course at the same time totally serious.&lt;/p&gt;
&lt;p&gt;Yes, MacOS exists and does not have a Linux userland, and that is a problem (just try to use Docker, you get a VM that runs Linux that then starts Containers).
Yes, Debian ships systems with ash, and your Openwrt runs Busybox, and in both cases that is the first thing everybody changes.
At least if they are going to use these systems for real, and for good reasons, too.&lt;/p&gt;
&lt;p&gt;The thing is, time did not stop.
It&amp;rsquo;s 2019, and the by far dominant majority of all systems run Linux, bash and a few other things.
It is perfectly okay to demand that these things are present, because the world has moved on and is way beyond kernel, operating systems and shell questions.
In fact, the need to be able to run Docker images at scale is so huge that even Microsoft implemented a Linux kernel API on their operating system, which underneath is anything but close to what Linux requires.&lt;/p&gt;
&lt;p&gt;The other thing is, of course, if portability matters, you do not run Bash or any other kind of Shell.
Or if security matters.
Or extensibility.
Or anything at all.
Use Python.
Or, PHP or even Perl, if you are like from the last millennium.&lt;/p&gt;
&lt;p&gt;But never write Shell Scripts.
Ever.
Or if you do, do not expect them to run anywhere but on your box.
This in the history of mankind has never worked.&lt;/p&gt;
&lt;p&gt;So, get yourself a real computer.
And use a proper programming language.
Thank you.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>But is it atomic?</title>
      <link>https://blog.koehntopp.info/2018/11/29/but-is-it-atomic.html</link>
      <pubDate>Thu, 29 Nov 2018 15:38:05 +0000</pubDate>
      
      <guid>https://blog.koehntopp.info/2018/11/29/but-is-it-atomic.html</guid>
      <description>&lt;p&gt;From &lt;a href=&#34;https://pluspora.com/posts/310948&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Pluspora&lt;/a&gt;

&lt;/p&gt;
&lt;h2 id=&#34;but-is-it-atomic&#34;&gt;
    &lt;a href=&#34;#but-is-it-atomic&#34;&gt;
	But is it atomic?
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;So a few days ago, a colleague asked “Why do we love files on disk?” and in the course of that discussion, I made a comment that, among other things, used the assumption that somebody is updating some file on some Linux system atomically. I wrote:&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s assume we are using local files, and we do so in a managed, sane way:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;All these state files are always JSON,&lt;/li&gt;
&lt;li&gt;there is a JSON schema, so
&lt;ul&gt;
&lt;li&gt;it is clear which attributes can be there,&lt;/li&gt;
&lt;li&gt;must be there, and&lt;/li&gt;
&lt;li&gt;what they mean and&lt;/li&gt;
&lt;li&gt;what changes to data mean as well.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Files are updated atomically&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;And immediately the question came up: “I either misunderstand you or I have a gap in the knowledge. When writes to a file became atomic? They are not in general case.”&lt;/p&gt;
&lt;p&gt;There is &lt;a href=&#34;https://dilbert.com/strip/1995-06-24&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;a Dilbert for that&lt;/a&gt;

.&lt;/p&gt;
&lt;p&gt;So let’s go back in time, it’s &lt;a href=&#34;http://silvertonconsulting.com/gbos2/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Greybeards time&lt;/a&gt;

! We’re going to find out where the things you are working with are actually coming from. With sources and references.&lt;/p&gt;
&lt;h2 id=&#34;the-write2-system-call&#34;&gt;
    &lt;a href=&#34;#the-write2-system-call&#34;&gt;
	The write(2) system call
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;A write(2) system call is atomic. The size or amount of data written does not matter. How come?&lt;/p&gt;
&lt;p&gt;The system call will, before trying to write data to disk, lock the in-memory inode. That is, it will effectively lock the entire file. It then performs the file changes, and only then unlocks. That can take a long, long, long time, depending on the amount of data and the media the file is being stored on.&lt;/p&gt;
&lt;p&gt;It means that on a single physical file in Unix there can be only one write(2) or read(2) system call active at any point in time.&lt;/p&gt;
&lt;p&gt;One exception to this is XFS, but only when a file is opened with O_DIRECT. In this special case, XFS instead locks the byte range in a structure attached to the inode, performs the write and then unlocks. So, in XFS with O_DIRECT, any number of concurrent, non-overlapping write(2) system calls can be active.&lt;/p&gt;
&lt;p&gt;The Posix specification requires that write(2) is atomic, it does not require that only one write per file can happen.&lt;/p&gt;
&lt;h2 id=&#34;that-is-a-horrible-thing&#34;&gt;
    &lt;a href=&#34;#that-is-a-horrible-thing&#34;&gt;
	That is a horrible thing!
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;The locking behavior of write(2) (and read(2)) is a problem for databases that require many concurrent writes to happen.&lt;/p&gt;
&lt;p&gt;Ingres and some other early SQL databases used to solve that problem by avoiding filesystem entirely, they recommended that tablespaces use raw disks. No filesystem, no files, no locks.&lt;/p&gt;
&lt;p&gt;Oracle solved the problem by introducing the concept of tablespaces, which are data storage spaces made up by a fleet of files, e.g. one file for each GB of data storage. Tables are assigned tablespaces, not data files directly. Since there is one write lock per inode, concurrent writes to different files in the same tablespace can happen.&lt;/p&gt;
&lt;p&gt;Only in 1994, when SGI published XFS, the actual problem was tackled by splitting the lock at the kernel level for buffer cache less writes. XFS also contained many other improvements over the 1984 BSD Fast Filing System that made it superior for concurrent I/O, streaming I/O, very large file systems, and many other modern use-cases. BSD FFS was in turn an improvement over 1974’s original Unix Filesystem.&lt;/p&gt;
&lt;p&gt;In Linux terms, the 1974 Unix Filesystem is mirrored by the Minix File system, the 1984 BSD FFS is roughly equivalent to ext2, and XFS was donated and ported to Linux by SGI, bringing that up into the tech level of 1994.&lt;/p&gt;
&lt;p&gt;Sun ZFS and Linux Btrfs are from 2004, and are a complete deviation from earlier Unix ideas. They are a different, much longer writeup, which will actually end with the git and the Blockchain.&lt;/p&gt;
&lt;h2 id=&#34;source-dive-why-are-writes-atomic&#34;&gt;
    &lt;a href=&#34;#source-dive-why-are-writes-atomic&#34;&gt;
	Source Dive: Why are writes atomic?
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;“Posix requiring a file write to be atomic” comes from the behavior of the original Version 7 Unix and later systems. In there, we find the &lt;a href=&#34;https://github.com/dspinellis/unix-history-repo/blob/Research-V7-Snapshot-Development/usr/sys/sys/sys2.c#L20&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;write(2)&lt;/a&gt;

 system call, which just calls the &lt;a href=&#34;https://github.com/dspinellis/unix-history-repo/blob/Research-V7-Snapshot-Development/usr/sys/sys/sys2.c#L30&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;rdwr()&lt;/code&gt;&lt;/a&gt;

 function.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/*
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * write system call 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;write&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nf&#34;&gt;rdwr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;FWRITE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;You are looking very old K&amp;amp;R style C code here, which predates even ANSI-C and function prototypes, by the way.&lt;/p&gt;
&lt;p&gt;So &lt;code&gt;rdwr()&lt;/code&gt; a few lines down the function calls &lt;code&gt;plock()&lt;/code&gt;, for as long as we are not dealing with a device special file (Here is where the Ingres “use raw devices” idea comes into play), then does the I/O and finally calls prele().&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;((&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ip&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i_mode&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;IFCHR&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;IFBLK&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;			&lt;span class=&#34;nf&#34;&gt;plock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ip&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mode&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;FREAD&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;			&lt;span class=&#34;nf&#34;&gt;readi&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ip&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;k&#34;&gt;else&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;			&lt;span class=&#34;nf&#34;&gt;writei&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ip&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;((&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ip&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i_mode&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;IFCHR&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;IFBLK&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;			&lt;span class=&#34;nf&#34;&gt;prele&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ip&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;plock()&lt;/code&gt; is what locks the actual inode and the origin of the observed behavior. It is is a misnomer, it’s not a pipe lock, it’s an inode lock.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/*
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * Lock a pipe.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * If its already locked,
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * set the WANT bit and sleep.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;plock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ip&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;register&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;inode&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ip&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;while&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ip&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i_flag&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ILOCK&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;n&#34;&gt;ip&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i_flag&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;|=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;IWANT&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;nf&#34;&gt;sleep&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;((&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;caddr_t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ip&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;PINOD&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;n&#34;&gt;ip&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i_flag&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;|=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ILOCK&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;See the locking loop here: As as we do not have the lock, indicate desire to get the lock, then sleep on a lock release. When we exit the loop (because the inode is unlocked), lock the inode.&lt;/p&gt;
&lt;p&gt;These are simple C Code lines, not special magic macros that translate into special magic TAS machine instructions. That is because the code here is so old that it comes from a world where we have single-die, single-core, single-thread CPUs. If your code is actually running (and this is kernel code!), then you are alone in the entire system. There is nobody else touching these variables as long as you have the CPU.&lt;/p&gt;
&lt;p&gt;Under the lock, &lt;code&gt;rdwr()&lt;/code&gt; above calls &lt;code&gt;writei()&lt;/code&gt;. And &lt;code&gt;writei()&lt;/code&gt; has a do loop which uses variables from the u-Area.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;do&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;n&#34;&gt;bn&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;u_offset&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;BSHIFT&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;n&#34;&gt;on&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;u_offset&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;BMASK&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;min&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;((&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;BSIZE&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;on&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;u_count&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;IFBLK&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;IFMPB&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;			&lt;span class=&#34;n&#34;&gt;bn&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;bmap&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ip&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bn&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;B_WRITE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;			&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;((&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bn&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;				&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;			&lt;span class=&#34;n&#34;&gt;dev&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ip&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i_dev&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;BSIZE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;			&lt;span class=&#34;n&#34;&gt;bp&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;getblk&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;dev&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bn&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;k&#34;&gt;else&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;			&lt;span class=&#34;n&#34;&gt;bp&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;bread&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;dev&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bn&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;nf&#34;&gt;iomove&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bp&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;b_un&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;b_addr&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;on&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;B_WRITE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;u_error&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;			&lt;span class=&#34;nf&#34;&gt;brelse&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;k&#34;&gt;else&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;			&lt;span class=&#34;nf&#34;&gt;bdwrite&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;u_offset&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ip&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i_size&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		   &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;==&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;IFDIR&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;||&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;==&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;IFREG&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;			&lt;span class=&#34;n&#34;&gt;ip&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i_size&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;u_offset&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;n&#34;&gt;ip&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i_flag&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;|=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;IUPD&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ICHG&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;u_error&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;==&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;u_count&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The u-Area of a process at that time was a common data structure that the userland and the kernel used to communicate. Here it is being used to shift syscall parameters into the kernel. The write writes the data at &lt;code&gt;u.u_base&lt;/code&gt; in userland into the current inode, at &lt;code&gt;u.u_offset&lt;/code&gt; bytes in the file. There are &lt;code&gt;u.u_count&lt;/code&gt; many bytes to write.&lt;/p&gt;
&lt;p&gt;We convert the &lt;code&gt;u.u_offset&lt;/code&gt; into a logical block number (the n-th block of a file), and an offset &lt;code&gt;on&lt;/code&gt; within the block. We need to call &lt;code&gt;bmap()&lt;/code&gt;. This function turns an inode number and block number within the file into a physical block number on a device.&lt;/p&gt;
&lt;p&gt;We can then bring the relevant physical block into the buffer cache, using &lt;code&gt;bread()&lt;/code&gt;, and then use &lt;code&gt;iomove()&lt;/code&gt; to modify and dirty the block. As we &lt;code&gt;brelse()&lt;/code&gt; it, it will eventually be written back to disk later.&lt;/p&gt;
&lt;p&gt;There is an optimization here:&lt;/p&gt;
&lt;p&gt;When the write is a full block, we do not read the block from disk. We just allocate a buffer using &lt;code&gt;getblk()&lt;/code&gt;, and fill it. It will overwrite the data on disk completely, there is no old and new data to merge. Disk accesses are slow, in the 1970ies even more so than today, so not reading data that you are going to obliterate completely pays off substantially.&lt;/p&gt;
&lt;p&gt;The loop continues as long as there are no errors and still blocks to write.&lt;/p&gt;
&lt;p&gt;As we return from &lt;code&gt;writei()&lt;/code&gt;, &lt;code&gt;rdrw()&lt;/code&gt; resumes and will eventually &lt;code&gt;prele()&lt;/code&gt; the inode lock.&lt;/p&gt;
&lt;h2 id=&#34;how-old-is-this-stuff&#34;&gt;
    &lt;a href=&#34;#how-old-is-this-stuff&#34;&gt;
	How old is this stuff?
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;This is of course extremely old code, original V7 unix, almost as old as me: git blames places its age at 41 years. I was in the third class of a German basic school when this was written.&lt;/p&gt;
&lt;p&gt;I chose this implementation, because it is very simple, and because it is also what became immortalised in the performance destroying standard which we got to know as Posix File System Semantics.&lt;/p&gt;
&lt;h2 id=&#34;homework&#34;&gt;
    &lt;a href=&#34;#homework&#34;&gt;
	Homework
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;You can have fun to find the matching functionality in a &lt;a href=&#34;https://github.com/torvalds/linux&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;modern Linux kernel&lt;/a&gt;

, threads, multicore, capabilities, namespaces, cgroups and dynamic data structures and all.&lt;/p&gt;
&lt;p&gt;Compare code readability and complexity. Discuss. Is this progress? Why do you think so?&lt;/p&gt;
&lt;p&gt;You can try to get a &lt;a href=&#34;http://160592857366.free.fr/joe/ebooks/ShareData/Design%20of%20the%20Unix%20Operating%20System%20By%20Maurice%20Bach.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;copy&lt;/a&gt;

 of “&lt;a href=&#34;https://www.amazon.de/Design-UNIX-Operating-System-Prentice/dp/0132017997&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;The Design of the Unix Operating System&lt;/a&gt;

” by Maurice J. Bach. It will take you on a guided tour through the origins of our craft and the legacy we build on. The topics discussed in this note can be found on the pages 101ff, “WRITE” and “FILE AND RECORD LOCKING”.&lt;/p&gt;
&lt;p&gt;If you are into operating systems, continue reading after Bach: “&lt;a href=&#34;https://www.amazon.de/Design-Implementation-4-3Bsd-Operating-System/dp/0201061961&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;The Design and Implementation of the 4.3 BSD Operating System&lt;/a&gt;

” builds on Bach’s work and showcases the progress and inventions that Kirk McKusick, Sam Leffler et al made after that.&lt;/p&gt;
&lt;p&gt;If you are into comparative operating system design, read “&lt;a href=&#34;https://www.amazon.com/Inside-Windows-NT-Helen-Custer/dp/155615481X&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Inside Windows NT&lt;/a&gt;

” by Helen Custer after Bach and Leffler/McKusick, and try to understand the different ideas and world view behind that.&lt;/p&gt;
&lt;h2 id=&#34;but-we-dont-use-write2-for-atomic-file-updates&#34;&gt;
    &lt;a href=&#34;#but-we-dont-use-write2-for-atomic-file-updates&#34;&gt;
	But we don’t use write(2) for atomic file updates!
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Well, some of us do, but I agree that it is hard to get right: write(2) and writev(2) are very hard to handle properly in applications, as you need to write everything in a single call.&lt;/p&gt;
&lt;p&gt;Most programs use another atomic operation in Unix, the rename(2) system call. You write file.new at your leisure, printf(), chunked writes() and all. When completed, rename file.new to file. This automatically unlinks the old version of file as well.&lt;/p&gt;
&lt;p&gt;This is also the recommended approach to atomicity, because unlike write(2) it is stable in the face of the dreaded nightmare file system.&lt;/p&gt;
&lt;p&gt;rename(2) was introduced really early in BSD Unix because of specific race problems in the V7 Unix early BSD patched and improved.&lt;/p&gt;
&lt;p&gt;Before BSD, we only had link(2) and unlink(2). You can use a combination of these syscalls to implement a rename-like operation, but you need more than one syscall to do that.&lt;/p&gt;
&lt;p&gt;In Unix, at the end of a syscall, before return to userland, the scheduler runs (Bach, Chapter 8). That is, at the end of each syscall, a process can be forced to yield the CPU. This is the cause for potential race conditions when not having a rename(2) as a single syscall, and that is why BSD came up with a single syscall for renaming files in the first place.&lt;/p&gt;
&lt;p&gt;Renaming files for atomic updates can be taken to an art form: try looking into the Maildir/ implementations as invented by qmail, and implemented in Dovecot and Cyrus&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.qmail.org/man/man5/maildir.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Maildir Man Page&lt;/a&gt;

&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cr.yp.to/proto/maildir.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;On Maildir at DJBs site&lt;/a&gt;

&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://danluu.com/file-consistency/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Dan Luu on File Consistency&lt;/a&gt;

&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;And that concludes this issue of Our Systems Legacy.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Dennis Ritchie (Sep 1941-Okt 2011)</title>
      <link>https://blog.koehntopp.info/2011/10/13/dennis-ritchie-sep-1941-okt-2011.html</link>
      <pubDate>Thu, 13 Oct 2011 03:39:44 +0000</pubDate>
      
      <guid>https://blog.koehntopp.info/2011/10/13/dennis-ritchie-sep-1941-okt-2011.html</guid>
      <description>&lt;p&gt;Das da ist
&lt;a href=&#34;http://en.wikipedia.org/wiki/Dennis_Ritchie&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Dennis Ritchie&lt;/a&gt;

,
&lt;a href=&#34;http://cm.bell-labs.com/who/dmr/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;dmr&lt;/a&gt;

.&lt;/p&gt;
&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/dennis_ritchie.jpg&#34; alt=&#34;Dennis Ritchie&#34;  /&gt;
&lt;/p&gt;

&lt;/p&gt;
&lt;p&gt;Dennis Ritchie schrieb zusammen mit Ken Thompson und vielen anderen Menschen
in den späten 60er und den 70er Jahren die ersten Versionen des
Unix-Betriebssystems, von dem viele der Systeme, die wir heute einsetzen,
direkt abstammen oder substantiell beeinflußt wurden. Zusammen mit Brian
Kernighan entwarf er die Programmiersprache C. Ritchie schrieb auch die
Dokumentation zu diesen Systemen, und jeder Informatikstudent auf diesem
Planeten hat seine Bücher &amp;lsquo;The C Programming Language&amp;rsquo; und eine Version des
&amp;lsquo;Unix Programmers Manual&amp;rsquo; lesen müssen - sie sind noch heute im Druck.&lt;/p&gt;
&lt;p&gt;1983 bekam Ritchie für seine Arbeiten den
&lt;a href=&#34;http://awards.acm.org/images/awards/140/articles/2898606.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Turing-Award&lt;/a&gt;

,
quasi den Nobelpreis für Informatiker.&lt;/p&gt;
&lt;p&gt;Es ist absolut unmöglich, mit Computern zu arbeiten und mit den Arbeiten und
den Ideen von Dennis Ritchie nicht an jedem einzelnen Tag in direkten
Kontakt zu kommen.&lt;/p&gt;
&lt;p&gt;Dennis Ritchie starb am 12. Oktober 2011. Seine Arbeit ist unsterblich.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Acht Jahre SCO-Prozeß</title>
      <link>https://blog.koehntopp.info/2011/08/31/acht-jahre-sco-proze.html</link>
      <pubDate>Wed, 31 Aug 2011 18:46:23 +0000</pubDate>
      
      <guid>https://blog.koehntopp.info/2011/08/31/acht-jahre-sco-proze.html</guid>
      <description>&lt;p&gt;Im März 2003 begann die Firma, die mal Caldera hieß und sich in SCO Group
umbenannte, IBM auf eine Fantasiesumme von Schadenersatz zu verklagen, weil
Ex-Caldera sich im Besitz des Unix-Copyrights wähnte und der Auffassung war,
daß IBM im Rahmen seiner Linux-Initiative Ex-Caldera geraubmordkopiert
hätte. Sich mit den Anwälten von IBM anzulegen ist eine unglaublich gute
Idee, die der Idee, einen Feldzug in Rußland im Winter zu führen, in nichts
nachsteht. So bekam Ex-Caldera dann auch bald bescheinigt: Linux enthält
keinen original Unix-Quellcode, SCO-Caldera hatte ihr IP unter der GPL
freigegeben und hat so keinen Grund zu klagen &lt;em&gt;und&lt;/em&gt; das Copyright am
Original-Unix System V liegt übrigens nicht bei Euch, liebes Ex-Caldera,
sondern bei Novell.&lt;/p&gt;
&lt;p&gt;Heute, &lt;a href=&#34;http://www.heise.de/open/meldung/SCO-vs-Linux-Es-ist-vorbei-1333811.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;8 Jahre später&lt;/a&gt;

,
geht die Akte endgültig zu. Endlich ist dieser Zombie tot.&lt;/p&gt;
&lt;p&gt;Bester Seiteneffekt der ganzen Aktion: &lt;a href=&#34;http://groklaw.net/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Groklaw&lt;/a&gt;

 -
Tausende von Geeks lernen (amerikanisches) Recht, und Armeen von verteilten
Beweisfindern dokumentieren diesen Prozeß im Detail, suchen Dokumente in
alten Papierstapeln, und finden Fehler und Schwachstellen in den
Argumentationen von Ex-Caldera. Die Firma muß feststellen, daß IBMs Anwälte,
bei aller Drohkraft, nicht der eigentliche Endgegner sind: Es ist das Netz
selber, die Masse der Geeks, die sich da mobilisiert und gegenhält.&lt;/p&gt;
&lt;p&gt;Nach dem Ende des SCO-Prozesses definiert sich Groklaw mit neuer Belegschaft
um: Themen sind nun Oracle vs. Google, Patenttrolle wie Lodsys und ähnliche
Themen. An Prozessen herrscht ja seit zehn Jahren im IT-Umfeld kein Mangel.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Unix-&#34;Standards&#34;</title>
      <link>https://blog.koehntopp.info/2009/07/26/unix-standards.html</link>
      <pubDate>Sun, 26 Jul 2009 17:14:50 +0000</pubDate>
      
      <guid>https://blog.koehntopp.info/2009/07/26/unix-standards.html</guid>
      <description>&lt;p&gt;Die Geschichte von Unix ist eine Geschichte der gescheiterten oder unbrauchbaren Standards - ihre Zahl ist Legion.&lt;/p&gt;
&lt;p&gt;Egal in welche Richtung man schaut: Sun zum Beispiel hatte einmal einen auf Postscript basierenden Desktop - &lt;a href=&#34;http://en.wikipedia.org/wiki/NeWS&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;NeWS&lt;/a&gt;

, der in gewissser Weise X11 um Jahrzehnte voraus war, sich aber nie hat durchsetzen können, unter anderem deswegen, weil das Ding von Sun als Waffe gegen andere Unix-Anbieter verwendet worden war und quasi tot-lizensiert wurde, gefolgt von&lt;a href=&#34;http://en.wikipedia.org/wiki/OPEN_LOOK&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Open Look&lt;/a&gt;

 und dann dem Motif-basierenden &lt;a href=&#34;http://en.wikipedia.org/wiki/Common_Desktop_Environment&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CDE&lt;/a&gt;

. Speziell letzteres war endlich ein herstellerübergreifendes Projekt, das von allen kommerziellen Unix-Anbietern unterstützt wurde (siehe auch &lt;a href=&#34;http://en.wikipedia.org/wiki/Solaris_%28operating_system%29#Desktop_environments&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;den Solaris-Artikel&lt;/a&gt;

). Da Motif als Toolkit aber bis zur Obsoleszens keine freie Software war und CDE auch keine nennenswerte Weiterentwicklung erfuhr, wurde es inzwischen großflächig durch KDE oder Gnome ersetzt - beides nativ freie Software.&lt;/p&gt;
&lt;p&gt;Auch auf Ebenen weiter unten war Standardisierung schwierig und ist vielfach gescheitert - so hat &lt;a href=&#34;http://en.wikipedia.org/wiki/POSIX&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;POSIX&lt;/a&gt;

 bis heute keine Norm für Access Control Lists von Dateisystemen und entsprechend ist etwa die Kommandozeilensyntax (und Ausdrucksstärke) von Access Control Lists auf einem Mac, einem Linux und einem Solaris unterschiedlich. Schaut man sich die Datumsangaben in dem verlinkten Wikipedia-Artikel an, kann man erkennen, daß Posix ein klassischer Nachfolgestandard ist - also kein Standard, der irgendetwas definiert oder voran bringt, sondern einer, der nur eine bereits vollzogene Entwicklung dokumentiert und festschreibt. Auch hier sind Herstellerkriege um Definitionsmacht die Ursache dafür.&lt;/p&gt;
&lt;p&gt;Auf der anderen Seite findet man eine Reihe von Innovationen in Unix, die sich universell durchgesetzt haben, aber erst nachdem ein Hersteller sie in klarer Verletzung aller formellen und informellen Standards eingeführt hat. Um bei Sun zu bleiben: Die heutige Architektur von Shared Libraries (.so&amp;rsquo;s) wie wir sie kennen ist einem Alleingang von Sun geschuldet, der so erfolgreich war, daß wir ihn heute in allen Unices finden, die überlebt haben. Genau so ist das heutige Layout von Dateisystemen, also die Einführung von /var, /home, /opt und die Aufgabe der Trennung von / und /usr ein Alleingang von Sun, der so erfolgreich war, daß er über den Umweg von SVR4 in alle nennenswerten modernen Unices Einzug gehalten hat.&lt;/p&gt;
&lt;p&gt;Sun hat das damals machen können, weil sie Workstations in großer Zahl abgesetzen konnten und so die entsprechende Definitionsmacht hatten. Außerdem sind die oben genannten Innovationen Beispiele für Innovationen, die nicht totlizensiert waren und so ohne Risiko experimentell von anderen Herstellern übernommen werden konnten.&lt;/p&gt;
&lt;p&gt;Die Rolle von Sun im heutigen Unix-Markt ist eine viel kleinere - Sun hat nicht nur nach Stückzahlen, sondern vor allen Dingen nach Developer- Mindshare eine sehr viel kleinere Rolle. Sun hat immer noch Ideen, einige von denen sind sogar kopierenswert. In die nach Stückzahlen und vor allen Dingen nach Developer-Mindshare sehr viel größere Linux-Welt werden sie jedoch nicht.&lt;/p&gt;
&lt;p&gt;Die Gründe sind immer noch dieselben wie oben:&lt;/p&gt;
&lt;p&gt;ZFS und Dtrace sind zwei Ideen, die sehr kopierenswert sind, die aber aus der Sicht der Linux-Welt totlizensiert sind. Sie sind totlizensiert in dem Sinne, daß die Lizenz dieser Stücke Software frei im Sinne von DFSG sein mag, aber die Lizenz ist mit der GPL inkompatibel. Das mag Absicht oder ein unglücklicher Zufall sein, Fakt ist, daß diese Ideen so nicht direkt als Code in Linux übernommen werden können. Also entwickeln sich in Linux alternative Projekte und es ist absehbar, daß diese in den nächsten 5 Jahren die entsprechenden Sun-Konzepte verdrängen werden - falls Oracle den Kram (&lt;strong&gt;Update wegen &lt;a href=&#34;http://blog.vodkamelone.de/archives/157-BTRFS-und-die-Lizenz....html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ixs Artikel&lt;/a&gt;

:&lt;/strong&gt; gemeint ist ZFS, das ja nun wie ganz Sun auch Oracle gehört) nicht Linux-kompatibel relizensiert. Letzteres wäre immerhin denkbar, denn die BTRFS-Entwicklung wurde zu einem guten Teil von Oracle finanziert und BTRFS ist das Linux-Gegenstück zu ZFS.&lt;/p&gt;
&lt;p&gt;Ein anderes Beispiel für eine Sun-Idee, die kopierbar wäre, aber nicht kopiert wird, ist SMF - hier ist die Sun-Lösung zu häßlich oder verkopft und es gibt zu viele konkurrierende Ideen, um &lt;a href=&#34;http://en.wikipedia.org/wiki/Init#Other_styles&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;init&lt;/a&gt;

 zu ersetzen. Wahrscheinlicher ist es, daß sich Konzepte wie &lt;a href=&#34;http://en.wikipedia.org/wiki/Upstart&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Upstart&lt;/a&gt;

 auf breiter Front durchsetzen.&lt;/p&gt;
&lt;p&gt;Unter dem Strich bleiben einige Erkenntnisse:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Standards sind öfter als nicht Festschreibungen bereits erfolgter Standardisierungsprozesse. Sie sind meist mehr Dokumentation als Innovation.&lt;/li&gt;
&lt;li&gt;Innovation wird im Unix-Bereich oft als Abweichung von einem vermeintlich oder tatsächlich bestehenden Standard wahrgenommen und daher oft schon aus Prinzip und ungeachtet ihres Nutzens mit Kritik überzogen.&lt;/li&gt;
&lt;li&gt;In 2009 haben die verschiedenen Linux-Distributionen endlich eine solche Marktmacht, daß sie de-facto Standards setzen können, die mit großer Wahrscheinlichkeit bald in Standarddokumenten dokumentiert werden. Die Tatsache, daß Sun
die GNU Tools im Pfad vor den eigenen Tools positioniert ist Testament dieser Entwicklung.&lt;/li&gt;
&lt;li&gt;Die Tatsache, daß es einen Unterschied macht ob man Sun Tools oder GNU Tools vorne im Pfad hat (oder BSD- statt SysV-Tools vorne im Pfad plaziert), ist Dokumentation der Tatsache, daß die existierenden Standardisierungen im Unix-Bereich noch lange nicht weit genug gehen, um eine Plattform zu erzeugen, die für die Anwendungsentwicklung groß genug wäre. Kommandozeilenwerkzeuge sind aber nur ein Aspekt der Sache - das Spiel setzt sich in rpm, deb, pkg und anderen Paketformaten, tar-Versionen, Desktop-Umgebungen und so weiter fort.&lt;/li&gt;
&lt;li&gt;Andererseits dokumentiert der bisherige Erfolg von Linux, daß das gar nicht so schlimm ist - von allen Unix-Versionen außer Linux sind überhaupt nur noch Solaris und AIX übrig geblieben und beide werden immer Linux-ähnlicher. Das ist eine gute Sache, und wenn man das erst einmal akzeptiert hat, kann man sich an den Tisch setzen und konstruktiv dokumentatorische Standards verabschieden.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(geschrieben nach der Lektüre von
&lt;a href=&#34;http://www.c0t0d0s0.org/archives/5785-Thoughts-of-an-admin-starting-to-get-old-....html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Jörgs Rant&lt;/a&gt;

)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Historische Kernelsourcen</title>
      <link>https://blog.koehntopp.info/2008/05/27/historische-kernelsourcen.html</link>
      <pubDate>Tue, 27 May 2008 08:08:46 +0000</pubDate>
      
      <guid>https://blog.koehntopp.info/2008/05/27/historische-kernelsourcen.html</guid>
      <description>&lt;p&gt;In anderen Artikeln habe ich ja schon an Hand von &lt;a href=&#34;http://lxr.linux.no/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://lxr.linux.no/&lt;/a&gt;

 Strukturen im Linux-Kernel referenziert und in Erklärungen verwendet.&lt;/p&gt;
&lt;p&gt;Auf &lt;a href=&#34;http://www.tamacom.com/tour.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Tamacom&lt;/a&gt;

 gibt es zum Vergleich die Quellen von Linux 2.6, FreeBSD 7, NetBSD 4.x, OpenBSD 4.x, GNU Hurd 0.3 und OpenSolaris zum verlinken. Auch liegen dort ein UNIX V7 Kernel und ein 4.3BSD rum.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://minnie.tuhs.org/UnixTree/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Minnie&lt;/a&gt;

 hat eine schöne Sequenz wirklich alter Unix-Trees, der die Entwicklung der 70er Jahre und einige BSD-Trees miteinander vergleicht. Das älteste nützliche Zeugs von dort ist &lt;a href=&#34;http://minnie.tuhs.org/UnixTree/Nsys/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;von 1973&lt;/a&gt;

.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The nsys files are timestamped August 31, 1973. This is consistent with other known dates. The files use structs, but in December 1972 the C compiler didn&amp;rsquo;t support structs. In September 1973, the C version of the kernel finally supplanted the assembly version, and the kernel here certainly works fine.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Mit anderen Worten, wir schauen hier der gleichzeitigen Entstehung der Sprache C und des Unix-Kernels zu. So kennt der V3 Kernel &lt;a href=&#34;http://minnie.tuhs.org/UnixTree/V3/usr/man/man2/stat.2.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;noch keine GID&lt;/a&gt;

 im stat(2) Systemaufruf, und der Compiler kann noch keine &amp;ldquo;struct&amp;rdquo; - im nsys-Kernel 6 Monate später existieren beide - und andere wichtige Erfindungen werden gemacht.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://minnie.tuhs.org/UnixTree/Nsys/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Goldenes Zitat&lt;/a&gt;

:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The number of UNIX installations is now above 20&amp;hellip;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>fork und exec vs. CreateProcess</title>
      <link>https://blog.koehntopp.info/2007/01/07/fork-und-exec-vs-createprocess.html</link>
      <pubDate>Sun, 07 Jan 2007 09:06:13 +0000</pubDate>
      
      <guid>https://blog.koehntopp.info/2007/01/07/fork-und-exec-vs-createprocess.html</guid>
      <description>&lt;p&gt;&lt;strong&gt;Disclaimer:&lt;/strong&gt; Meine Windows-Kenntnisse sind beschränkt, veraltet und ausschließlich theoretischer Natur. Im Zweifel erzählt dieser Artikel Unsinn nach Hörensagen.&lt;/p&gt;
&lt;p&gt;Nach dem Artikel &lt;a href=&#34;https://blog.koehntopp.info/2007/01/07/fork-exec-wait-und-exit.html&#34;&gt;form, exec, wait und exit&lt;/a&gt;

 habe ich mir aber einmal meine Kopie von Jeffrey Richters &lt;a href=&#34;http://www.amazon.de/Microsoft-Windows-Programmierung-fuer-Experten/dp/3860633899/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Windows - Programmierung für Experten (Advanced Windows)&lt;/a&gt;

 (1997) gegriffen und dort nachgeschlagen, wie man sich das mit den Prozessen und Programmen unter Windows vorstellt (oder jedenfalls vor 10 Jahren vorgestellt hat).&lt;/p&gt;
&lt;p&gt;Windows hat zu diesem Zweck die Systemfunktion &lt;a href=&#34;http://msdn.microsoft.com/library/default.asp?url=https://blog.koehntopp.info/library/en-us/dllproc/base/createprocess.asp&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CreateProcess&lt;/a&gt;

(10 Parameters). Die liest sich so:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;BOOL WINAPI CreateProcess(  LPCTSTR lpApplicationName,  LPTSTR lpCommandLine,  LPSECURITY_ATTRIBUTES lpProcessAttributes,  LPSECURITY_ATTRIBUTES lpThreadAttributes,  BOOL bInheritHandles,  DWORD dwCreationFlags,  LPVOID lpEnvironment,  LPCTSTR lpCurrentDirectory,  LPSTARTUPINFO lpStartupInfo,  LPPROCESS_INFORMATION lpProcessInformation);&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Die Funktion erzeugt einen neuen Prozeß und lädt in diesen ein neues Programm. Dieses wird dann gestartet. lpApplicationName ist der Pfadname des auszuführenden Programmes.&lt;/p&gt;
&lt;p&gt;lpCommandLine ist die Kommandozeile (der argv) des neuen Programmes. Sie wird als String und nicht als Vektor von Strings übergeben. Das Parsen der Kommandozeile in Wort wird also durch das Betriebssystem übernommen und kann nicht durch den Aufrufer kontrolliert werden. In Unix muß man bei execve() einen Vektor von Strings übergeben, das Zerlegen der Kommandozeile in Worte muß also durch den Aufrufer, z.B. die Shell übernommen werden. Die anderen Funktionen der exec-Familie sind Bibliotheksfunktionen, die einem hier einen Teil der Arbeit abnehmen.&lt;/p&gt;
&lt;p&gt;lpApplicationName und lpCommandLine interagieren: lpApplicationName darf NULL sein, dann wird das erste Wort von lpCommandLine nach der Zerlegung in Worte als lpApplicationName interpretiert. lpApplicationName darf ohne Endung angegeben werden, dann rät Windows die Extension bzw. probiert eine Liste von ausführbaren System-Extensions aus.&lt;/p&gt;
&lt;p&gt;lpApplicationName darf auch ein unqualifizierter Pfadname sein. In diesem Fall wird das Absuchen eines System-Suchpfades wird durch diese Funktion von Windows übernommen. In Unix führt execve() genau das Binary aus, dessen Pfadnamen man angegeben hat. Will man einen Suchpfad absuchen, muß man execve() in einer Schleife so lange ausführen, bis es nicht mehr zurück kommt.&lt;/p&gt;
&lt;p&gt;lpProcessAttributes ist kein einzelner Parameter, sondern ein Zeiger auf eine &lt;a href=&#34;http://msdn2.microsoft.com/en-us/library/aa379560.aspx&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SECURITY_ATTRIBUTES&lt;/a&gt;

-Struktur, die man ausfüllen kann und die viele Parameter enthalten kann. Die Struktur enthält eine ACL für die Discretionary Access Control, bestimmt also im wesentlichen, wer diesen Prozeß anfassen und was mit ihm machen darf. In Unix gibt es kein vergleichbares Konzept für Prozesse: Ein Prozeß hat entweder die entsprechende Capability (etwa CAP_KILL oder CAP_SYS_PTRACE) oder nicht.&lt;/p&gt;
&lt;p&gt;lpThreadAttributes erzeugt ist der passende Parameter für den in dem Prozeß zwingend enthaltenen Thread. bInheritHandles definiert, ob vererbbare Handles auf Objekte von dem neu erzeugten Prozeß geerbt werden.&lt;/p&gt;
&lt;p&gt;dwCreationFlags legt die Priorität des Prozesses und &lt;a href=&#34;http://msdn2.microsoft.com/en-us/library/ms684863.aspx&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;weitere Flags&lt;/a&gt;

 für den neuen Prozeß fest. In Unix würde man all dies zwischen dem fork() und dem exec() mit einzelnen Calls machen, etwa mit Calls aus der setpriority()-Familie oder mit Aufrufen nach setpgrp().&lt;/p&gt;
&lt;p&gt;lpEnvironment entspricht konzeptuell, aber nicht im Format dem envp von execve.&lt;/p&gt;
&lt;p&gt;lpCurrentDirectory ist das aktuelle Verzeichnis des neuen Prozesses. In Unix würde man den identischen Effekt erreichen, indem man zwischen dem fork() und dem exec()-Systemaufruf ein chdir() (oder chroot()) aufruft.&lt;/p&gt;
&lt;p&gt;lpStartupInfo ist ein Zeiger auf eine eine Struktur &lt;a href=&#34;http://msdn2.microsoft.com/en-us/library/ms686331.aspx&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;STARTUPINFO&lt;/a&gt;

, die keine Entsprechung in Unix hat, weil hier Dinge angegeben werden, die mit den Fenstern einer Anwendung zu tun haben. Unix handhabt diese Dinge komplett vom Betriebssystemkern getrennt und daher finden wir in den Betriebssystem-Primitiven zu Prozessen keine Fensterinformationen. Genaugenommen ist lpStartupInfo entweder ein Zeiger auf eine STARTUPINFO oder STARTUPINFOEX-Struktur. Was es genau ist wird mit einem Flag in dwCreationFlags angegeben. Das ist nicht typsicher, und das ist bemerkenswert, weil Windows an anderer Stelle sehr viel Wert auf solche Dinge legt.&lt;/p&gt;
&lt;p&gt;Der letzte Parameter von CreateProcess, lpProcessInformation, ist ein Referenzparameter auf eine &lt;a href=&#34;http://msdn2.microsoft.com/en-us/library/ms684873.aspx&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;PROCESS_INFORMATION&lt;/a&gt;

-Struktur, die von Windows überschrieben und ausgefüllt wird. Wir finden dort die Handles zu unserem Prozeß und dem darin enthaltenen Thread sowie eine ProcessId und eine ThreadId.&lt;/p&gt;
&lt;p&gt;Will man das Äquivalent zu einem setuid()-Eignerwechsel in Unix in Windows durchführen, kommt dieses Konzept an seine Grenzen - so etwas ist trotz der Vielzahl der Parameter von CreateProcess() in Windows nicht vorgesehen. Man braucht eine neue Funktion, &lt;a href=&#34;http://msdn2.microsoft.com/en-us/library/ms682429.aspx&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CreateProcessAsUser&lt;/a&gt;

(11 Parameter).&lt;/p&gt;
&lt;h2 id=&#34;analyse&#34;&gt;
    &lt;a href=&#34;#analyse&#34;&gt;
	Analyse
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Hier wird der grundlegende Unterschied zwischen den Konzepten von Windows und Unix deutlich: Die Unix-API stammt von Mitte der 70er Jahre und hat sich in den vergangenen mehr als 30 Jahren nicht wesentlich verändert.&lt;/p&gt;
&lt;p&gt;Sie genügt heutigen Ansprüchen, weil sie alle Ansprüche nicht erfüllt - sie liefert stattdessen relativ atomare primitive Funktionen und trennt sogar auf den ersten, flüchtigen Blick zusammengehörende Dinge wie Erzeugen von Prozessen und Laden von Programmen. Dadurch muß ein Programmierer einer Anwendung entweder eine Bibliotheksfunktion verwenden, die fork() und exec() in etwas bequemeres einpackt (etwa system() oder popen()) oder all die Dinge selber machen, die Windows im Kernel für den Programmierer erledigt. fork() hat keine Parameter und execve() hat deren drei.&lt;/p&gt;
&lt;p&gt;Will man mehr, hat man die Gelegenheit, das Environment des neuen Prozesses nach dem fork() vor dem Start des neuen Programmes mit execve() von innen zu verändern.&lt;/p&gt;
&lt;p&gt;Windows dagegen erzeugt eine alles-in-einem Funktion, die für den häufigen Anwendungsfall und alle denkbaren Varianten Extraparameter hat. Windows hat dabei die Sicht von außen auf den Kindprozeß. Dies führt zu nützlichen Dingen wie einer Thread- und Prozeß DACL, ist aber konzeptuell nicht gut erweiterbar. Dinge wie ein setuid()-Aufruf zwischen fork() und exec() sind mit CreateProcess() nicht abbildbar und machen weitere Funktionen erforderlich, die noch mehr Parameter haben.&lt;/p&gt;
&lt;p&gt;Das Konzept von Unix ist auf den ersten Blick umständlich und wenig intuitiv. Es genügt von der Aufteilung her jedoch den Ansprüchen, die man als Datenbanker an eine Normalform hätte und ist daher flexibel und ohne Änderungen am Kern erweiterbar - unabhängige Konzepte sind als unabhängige Funktionen implementiert und Erweiterung erfolgt durch Einschieben weiterer Aufrufe zwischen fork() und exec(). Neben dem Vorteil der Erweiterbarkeit hat dies den Nachteil, daß mehr Systemaufrufe notwendig sind als bei Windows (Unix-Systemaufrufe müssen schnell sein, damit dieses Konzept aufgeht) und daß man unter Umständen ein Problem mit der Atomizität bekommen kann.&lt;/p&gt;
&lt;p&gt;Beispiel ist hier die Aufgabe: &amp;ldquo;Starte aus einem Debugger einen Programm in einem Kindprozeß und zwar so, daß der Kindprozeß ohne Racecondition auf der ersten Anweisung des Kindes stoppt und debugbar ist.&amp;rdquo;. Das Problem war lange Zeit nicht lösbar, und wurde von Linux durch das PTRACE_TRACEME-Flag zu ptrace() gelöst, das neben einigen anderen Dingen bewirkt, daß ein Kindprozeß nach einem execve() erst mal mit einem SIGTRAP stehen, bleibt bevor er irgendwas selber macht. Bemerkenswert ist, daß die Erweiterung möglich war, ohne das bestehende 30 Jahre alte Konzept von fork, exec und wait verändern zu müssen.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Filesysteme für theclaw (30 Jahre Unix Source)</title>
      <link>https://blog.koehntopp.info/2006/12/26/filesysteme-fuer-theclaw-30-jahre-unix-source.html</link>
      <pubDate>Tue, 26 Dec 2006 19:09:59 +0000</pubDate>
      
      <guid>https://blog.koehntopp.info/2006/12/26/filesysteme-fuer-theclaw-30-jahre-unix-source.html</guid>
      <description>&lt;p&gt;&amp;mdash; Log opened Di Dez 26 15:52:09 2006&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Hey :] &lt;a href=&#34;https://blog.koehntopp.info/2006/05/08/fragmentierung-fuer-jannik.html&#34;&gt;Spitze erklaerung zu ext2.&lt;/a&gt;

&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Danke&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Bist du Kerneldeveloper?&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Nein. Mysql Consultant.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Hmm. Hab da was nicht verstanden bei der Erklärung. Und zwar: Was sind Datenblockzeiger?&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Die Blockadressen von Datenblöcken einer Datei.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Ich paste mal was&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;(0-11):9711-9722, (IND):9723, (12-267):9724-9979, (DIND):9980, (IND):9981, (268-523):9982-10237, (IND):10238, (524-779):10239-10494, (IND):10495, (780-1035):10496-10751, (IND):10752, (1036-1291):10753-11008, (IND):11009, (1292-1547):11010-11265, (IND):11266, (1548-1795):11267-11514
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Isotopp&amp;gt; Habs im
&lt;a href=&#34;%28https://blog.koehntopp.info/2006/05/08/fragmentierung-fuer-jannik.html%29&#34;&gt;Originalartikel&lt;/a&gt;

.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; &lt;code&gt;__le32 i_block[EXT2_N_BLOCKS];&lt;/code&gt; Das ist das, was unter BLOCKS bei debugfs steht?&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt;
&lt;a href=&#34;http://lxr.linux.no/source/include/linux/ext2_fs.h#L211&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://lxr.linux.no/source/include/linux/ext2_fs.h#L211&lt;/a&gt;

: Das ist was auf der Platte steht.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Okay mal durchdenken.&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Die Definition steht in
&lt;a href=&#34;http://lxr.linux.no/source/include/linux/ext2_fs.h#L165&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://lxr.linux.no/source/include/linux/ext2_fs.h#L165&lt;/a&gt;

. Es kommen also &lt;code&gt;EXT2_NDIR_BLOCKS&lt;/code&gt; direkt, also in der Inode selbst. Das sind (0-11):9711-9722.&lt;/p&gt;
&lt;p&gt;Dann kommt ein &lt;code&gt;EXT2_IND_BLOCK&lt;/code&gt;, (IND):9723. Der steht auch in der Inode, aber der zeigt nicht auf Daten, sondern auf einen Indirect Block. Der enthält die Blocknummern der Datenblöcke, (12-267):9724-9979.&lt;/p&gt;
&lt;p&gt;Dann kommt &lt;code&gt;EXT2_DIND_BLOCK&lt;/code&gt;. Der wiederum enthält keine Blocknummern von Datenblöcken, sondern die Blocknummern von Indirect Blocks, die wiederum Blocknummern von Datenblöcken enthalten. Daher
&lt;a href=&#34;http://kris.koehntopp.de/artikel/dateisysteme/filestructure.gif&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://kris.koehntopp.de/artikel/dateisysteme/filestructure.gif&lt;/a&gt;

.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; &lt;em&gt;anseh&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; In der inode steht nur (DIND):9980. In DIND steht dann (IND):9981 und (IND):10238 und so weiter. Und in (IND):9981 stehen dann 9982-10237, in (IND):10238 dann 10239-10494.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; DIR steht für &amp;ldquo;direct&amp;rdquo;?&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; ja&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Muss das jetzt mal kurz mit debugfs ausprobieren.&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Sieh mal
&lt;a href=&#34;http://lxr.linux.no/source/fs/ext2/inode.c#L665&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://lxr.linux.no/source/fs/ext2/inode.c#L665&lt;/a&gt;

. Das &lt;code&gt;ext2_bmap&lt;/code&gt; geht über &lt;code&gt;generic_block_bmap&lt;/code&gt; nach
&lt;a href=&#34;http://lxr.linux.no/source/fs/ext2/inode.c#L547&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://lxr.linux.no/source/fs/ext2/inode.c#L547&lt;/a&gt;

. Und das wiederum benutzt
&lt;a href=&#34;http://lxr.linux.no/source/fs/ext2/inode.c#L196&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://lxr.linux.no/source/fs/ext2/inode.c#L196&lt;/a&gt;

. Und da siehst du den lookup.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; okay langsam kommts&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Wenn &lt;code&gt;i_block&lt;/code&gt;&amp;lt;0 -&amp;gt; error. Wenn &lt;code&gt;i_block&lt;/code&gt;&amp;lt;&lt;code&gt;direct_blocks&lt;/code&gt;, dann direkt. Sonst IND, sonst DIND, sonst TIND. Sonst bumm.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Wart mal, nicht so schnell. Ich kann das nicht alles gleichzeitig aufnehmen. Also, die ersten zwölf Blöcke sind -direkt- in der Inode?&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Ja. Blocknummern. Nicht Blöcke.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; &lt;code&gt;i_block&lt;/code&gt; ist schon ein element aus &lt;code&gt;i_block[]&lt;/code&gt; oder? ;)&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Wo bist du gerade? Also in welcher zeile?&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; &lt;code&gt;static int ext2_block_to_path&lt;/code&gt;. Bei der Definition da.&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Kannst du eine lxr url geben bitte? Sonst wird das schwer hier. Ah, hier:
&lt;a href=&#34;http://lxr.linux.no/source/fs/ext2/inode.c#L196&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://lxr.linux.no/source/fs/ext2/inode.c#L196&lt;/a&gt;

.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; ja&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; &lt;code&gt;i_block&lt;/code&gt; ist der 2. Parameter der Funktion, der Aufruf steht in
&lt;a href=&#34;http://lxr.linux.no/source/fs/ext2/inode.c#L547&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://lxr.linux.no/source/fs/ext2/inode.c#L547&lt;/a&gt;

. Da ist es &lt;code&gt;iblock&lt;/code&gt;,
das wird durchgereicht vom 2. Parameter von &lt;code&gt;ext2_get_block&lt;/code&gt; &lt;code&gt;iblock&lt;/code&gt;. Das wiederum ist
&lt;a href=&#34;http://lxr.linux.no/source/fs/ext2/inode.c#L665&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://lxr.linux.no/source/fs/ext2/inode.c#L665&lt;/a&gt;

, der das über den Umweg von
&lt;a href=&#34;http://lxr.linux.no/source/fs/buffer.c#L2759&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://lxr.linux.no/source/fs/buffer.c#L2759&lt;/a&gt;

 aufruft.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Nicht gerade trivial.&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Für den Kernel schon. Das geht da überall so, inzwischen. Man gewöhnt sich dran, das Lesen zu können. Die
Alternative ist Code Duplication, und das nervt noch mehr. Anyway, &lt;code&gt;sector_t&lt;/code&gt; ist ein unsigned 64 bit
(long long, 8 byte) in i386. Eine Blocknummer.&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; In
&lt;a href=&#34;http://lxr.linux.no/source/fs/ext2/inode.c#L556&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://lxr.linux.no/source/fs/ext2/inode.c#L556&lt;/a&gt;

, das ist die wichtige Stelle, hast du die &lt;code&gt;inode&lt;/code&gt; und den &lt;code&gt;iblock&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Die &lt;code&gt;inode&lt;/code&gt; hat das 12-Elemente direct block array usw im Speicher und &lt;code&gt;iblock&lt;/code&gt; ist der Offset. Die Frage,
die in
&lt;a href=&#34;http://lxr.linux.no/source/fs/ext2/inode.c#L556&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://lxr.linux.no/source/fs/ext2/inode.c#L556&lt;/a&gt;

 geklärt werden muss
ist: wie tief müssen wir runter steigen - für die Blöcke 0-11 gar nicht, für die Blöcke 12- einen Level und so weiter.
Das klärt &lt;code&gt;ext2_block_to_path&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Den Abstieg sehen wir dann in
&lt;a href=&#34;http://lxr.linux.no/source/fs/ext2/inode.c#L562&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://lxr.linux.no/source/fs/ext2/inode.c#L562&lt;/a&gt;

.
Und der Abstieg klappt entweder, weil das File schon einen Block hat an der Stelle &lt;code&gt;iblock&lt;/code&gt;
(&lt;a href=&#34;http://lxr.linux.no/source/fs/ext2/inode.c#L564&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://lxr.linux.no/source/fs/ext2/inode.c#L564&lt;/a&gt;

),
oder es klappt nicht und wir müssen Blöcke beschaffen
(nach &lt;a href=&#34;http://lxr.linux.no/source/fs/ext2/inode.c#L575&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://lxr.linux.no/source/fs/ext2/inode.c#L575&lt;/a&gt;

).&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Sekunde. Bin kein Kernelmensch ;)&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Aber das ist doch nur gewöhnliches C.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Na ja, trotzdem komplex (für mich). Erstmal eine Frage. Man hat ein FS, und will die Inode nummer 23, wie wird die gefunden?&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Über die Verzeichnisse. Wir wissen, / hat die inode 2. Das ist definiert in
&lt;a href=&#34;http://lxr.linux.no/source/include/linux/ext2_fs.h#L60&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://lxr.linux.no/source/include/linux/ext2_fs.h#L60&lt;/a&gt;

,
also lesen wir das File mit der inode 2 durch, und parsen es als
&lt;a href=&#34;http://lxr.linux.no/source/include/linux/ext2_fs.h#L510&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://lxr.linux.no/source/include/linux/ext2_fs.h#L510&lt;/a&gt;

 Strukturen.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Sind die indodes nicht nacheinander abgepeichert in den BGs?
Also die erste BG enthält die ersten X Inodes, die zweite BG die zweiten X usw&amp;hellip;&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Aeh, ah. Ich verstehe. Userland kann nichts mit Inodes machen, nur mit Filenamen. Es gibt kein &lt;code&gt;openi()&lt;/code&gt;.
Also müssen alle Funktionen im Userland immer Namen angeben, und du kommst dann vom Namen zur Inode über das kernel-interne &lt;code&gt;namei()&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Ja, klar. Aber der Kernel will ja Inode X irgendwie kriegen können.&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Ja, intern. Das weiß er, weil im Superblock ja steht, wie viele Inodes pro bg vorhanden sind, und er dann aus
der Inodenummer / inodes_per_bg sofort die bg nummer ausrechnen kann, und dann sofort weiß, wo die inode
stehen muss auf der Platte. Eine Inodenummer ist also implizit auch die Blockadresse der Inode auf der Platte.&lt;/p&gt;
&lt;p&gt;Hier ist der Superblock:
&lt;a href=&#34;http://lxr.linux.no/source/include/linux/ext2_fs.h#L341&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://lxr.linux.no/source/include/linux/ext2_fs.h#L341&lt;/a&gt;

,
und &lt;a href=&#34;http://lxr.linux.no/source/include/linux/ext2_fs.h#L352&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://lxr.linux.no/source/include/linux/ext2_fs.h#L352&lt;/a&gt;

 ist
die &lt;code&gt;s_inodes_per_group&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Und die Inode wird dann in
&lt;a href=&#34;http://lxr.linux.no/source/fs/ext2/inode.c#L998&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://lxr.linux.no/source/fs/ext2/inode.c#L998&lt;/a&gt;

 gelesen.&lt;/p&gt;
&lt;p&gt;Meine Rechnung von eben ist hier
&lt;a href=&#34;http://lxr.linux.no/source/fs/ext2/inode.c#L1012&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://lxr.linux.no/source/fs/ext2/inode.c#L1012&lt;/a&gt;

.  &lt;code&gt;(ino - 1) / EXT2_INODES_PER_GROUP(sb);&lt;/code&gt;
und &lt;code&gt;((ino - 1) % EXT2_INODES_PER_GROUP(sb)) * EXT2_INODE_SIZE(sb);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Nix für ungut aber für mich ist der Code grad ned so hilfreich.&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Was ist das Problem?&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Bin grad bisschen überfordert.&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Du hast eine Inode Nr 23. Du weisst, pro bg hast Du sagen wir 8192 Inodes. Und (23-1) / ext2_indes_per_group(sb) = 0.
Also ist inode 23 in bg 0.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; &lt;em&gt;wartmal&lt;/em&gt; 8192?!&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; 8192 bei 1 kb blockgroesse, 32768 bei 4kb&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Wie gross ist eine Inode nochmal?&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; 128 bytes.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;linux/ext2_fs.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ext2_inode&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nf&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;%d&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;sizeof&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;und&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;kris@linux:~&amp;gt; make probe
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;make: &amp;#34;probe&amp;#34; ist bereits aktualisiert.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;kris@linux:~&amp;gt; ./probe
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;128
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;theclaw&amp;gt; Also pro BG ist allein 1 MB bzw 4 MB an Inodes reserviert?&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Ja. Eine bg ist 8 MB oder 128 MB gross. Schau, hast du ein ext2 da?&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; ja&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Dann mach mal ein &lt;code&gt;debugfs /dev/...&lt;/code&gt; da drauf. Ist read only, macht also nix kaputt. Dann mach mal &lt;code&gt;show_super_stats&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;Inodes per group:         2008
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;Inode count:              26104
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;für ein &lt;code&gt;/dev/sda5     ext2     99M  6.7M   87M   8% /boot&lt;/code&gt;
und &lt;code&gt;26104*128/1024 = 3263&lt;/code&gt;, also 3263 KB oder 3.2M für alle Inodes.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Aber meine Frage ist eine Andere.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; 21:40 Isotopp&amp;gt; und das wichtigste in &lt;code&gt;struct: __le32 i_block[EXT2_N_BLOCKS];&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; &lt;code&gt;i_block[12]&lt;/code&gt; ist ein indirekter Block? &lt;em&gt;aaargh&lt;/em&gt; Die Adresse eines indirekten Blockes?&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Ja.
&lt;a href=&#34;http://lxr.linux.no/source/include/linux/ext2_fs.h#L165&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://lxr.linux.no/source/include/linux/ext2_fs.h#L165&lt;/a&gt;

. Dort ist
&lt;code&gt;#define EXT2_IND_BLOCK EXT2_NDIR_BLOCKS&lt;/code&gt; und weiter ist
&lt;code&gt;#define EXT2_NDIR_BLOCKS 12&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Also 15 &lt;code&gt;EXT2_N_BLOCKS&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Also ist &lt;code&gt;i_block[0]&lt;/code&gt; bis &lt;code&gt;i_block[11]&lt;/code&gt; direct, &lt;code&gt;i_block[12]&lt;/code&gt; indirect, und &lt;code&gt;i_block[13]&lt;/code&gt; DIND und &lt;code&gt;i_block[14]&lt;/code&gt; TIND. Alles in allem also 15.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Sind das die Faktoren die die max. Dateigröße in ext2 bestimmen?&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Das sind die Faktoren, die die maximale Blocknummer bestimmen. Dateigröße ist Blockgröße mal maximale Blocknummer.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Also ja ;) Indirekt halt.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; 9711-9722: Sind das die &amp;ldquo;Adressen&amp;rdquo;?&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Blocknummern, ja, Adressen auf der Platte. In
&lt;a href=&#34;http://lxr.linux.no/source/include/linux/ext2_fs.h#L234&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://lxr.linux.no/source/include/linux/ext2_fs.h#L234&lt;/a&gt;

 siehst du als Typ uebrigens &lt;code&gt;__le32&lt;/code&gt;. Das ist definiert in
&lt;a href=&#34;http://lxr.linux.no/source/include/linux/types.h#L172&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://lxr.linux.no/source/include/linux/types.h#L172&lt;/a&gt;

 und endet als &lt;code&gt;__u32&lt;/code&gt;, also unsigned 32 bit. Also 2^32 Blöcke. Bei 4 KB Blöcken sind das 17592186044416 Bytes, oder 16 TB, bei 1 KB Blöcken nur 4 TB.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Diese Blöcke haben aber nix mit den Blöcken bei ext2 zu tun? Oder doch?&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; &lt;code&gt;show_super_stats&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; &lt;code&gt;Block size:               1024&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; In meinem Fall also auch maximale Dateigröße 4 TB. 4 Gigablocks.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Okay, dann noch eine Frage:&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; TOTAL: 1804 und Blockcount: 3608, huh? Warum *2?&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Hmm, da rechnet jemand mit 512 Byte Hardwaresektoren, warum auch immer.&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;linux:~ # ls -lsi /boot/vmlinuz-2.6.13-15-default
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt; 28 1513 -rw-r--r--  1 root root 1541719 Sep 13  2005 /boot/vmlinuz-2.6.13-15-default
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Isotopp&amp;gt; Inode 28, 1513 Blöcke auf der Platte, Dateilaenge 15411719 Bytes. Rechnerisch ist  &lt;code&gt;1541719/1024 = 1505.5849&lt;/code&gt;. 7 Blöcke Verwaltungsoverhead. Und zwar&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;(0-11):11515-11526, 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;(IND):11527, (12-267):11528-11783, 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;(DIND):11784, (IND):11785, (268-523):11786-12041, 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;              (IND):12042, (524-779):12043-12298, 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;              (IND):12299, (780-1035):12300-12555, 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;              (IND):12556, (1036-1291):12557-12812, 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;              (IND):12813, (1292-1505):12814-13027
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;TOTAL: 1513
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Isotopp&amp;gt; (IND):11527, (DIND):11784, (IND):11785, (IND):12299, (IND):12556, (IND):12813 &amp;lt;- das sind 6.&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; 1541719/1024 = 1505.5849 sind 1506. Plus 6 sind 1512.&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Er meint total sei 1513. Wieso?&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Ich versteh das sowieso nicht, warum da 1513 angezeigt wird. 1292-1505 ist das letzte und dann total 1513. Evtl noch die Metainfos dazu?&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Nein, aber die DIND und IND Blocks. Für die Blöcke 12-267 wird ja ein IND gebraucht, für die Blöcke 268-1505 wird ein DIND und vier IND gebraucht. 6 blocks Extra. Siehe noch einmal
&lt;a href=&#34;http://kris.koehntopp.de/artikel/dateisysteme/filestructure.gif&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://kris.koehntopp.de/artikel/dateisysteme/filestructure.gif&lt;/a&gt;

. Das rechts sind die Daten. In der Inode stehen die ersten paar Datenblocknummern direkt, in der zeichnung 10, in ext2 sind es 12. Dann steht in der Inode die Nummer vom IND, und im IND die Blocknummern der Datenblöcke, hier 12-267. Das ist also 1 block overhead, wenn das file mehr als 12 blocks lang wird. Dann ein DIND, wenn der 268&amp;rsquo;te block gebraucht wird und für jeweils 256 Blocks ein IND dazu.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Du erklaerst so schnell.&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;linux:/boot # dd if=/dev/zero of=kris bs=1k count=12
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;linux:/boot # ls -ls kris
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;12 -rw-r--r--  1 root root 12288 Dec 26 16:58 kris
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;12 Blöcke, 12288 Bytes Länge. Und nun:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;linux:/boot # dd if=/dev/zero of=kris bs=1k count=13
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;linux:/boot # ls -ls kris
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;14 -rw-r--r--  1 root root 13312 Dec 26 16:58 kris
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Ein 1k länger, 14 Blocks statt 12.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Wie findet man die Größen der BGs eines dateisystems heraus?&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Lies &lt;code&gt;show_super_stats&lt;/code&gt; von &lt;code&gt;debugfs&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;linux:/boot # export DEBUGFS_PAGER=cat
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;linux:/boot # debugfs /dev/sda5
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;debugfs 1.38 (30-Jun-2005)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;debugfs:  show_super_stats
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;Inode count:              26104
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;Block count:              104388
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;Block size:               1024
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;Blocks per group:         8192
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;Inodes per group:         2008
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;Inode blocks per group:   251
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Isotopp&amp;gt; Wird einiges klarer?&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Ein bisschen. Also wenn ich z.B. block nummer X habe, dann ist (nummer X)/(blocks per group) die BG nummer gell?&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Ja, aber das interessiert nicht. Du redest ja von Blöcken.&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Der n-te Block der Datei x kann irgendwo liegen. Wo, das sagt dir die Inode.  Normal hast du ja ein File, und eine Position in einem File.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Ich kann doch einfach von der Adresse auf der Platte X * bytes_per_block lesen?&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Na ja, als root schon. Sonst nicht. debugfs macht das ja, die Disk als raw device auf und dann direkt auf die Blöcke klettern. Niemand sonst tut so etwas ausser debugfs und fsck. Alle anderen machen FILES auf und lesen dann am OFFSET in dem File. Punkt ist, dass du normal mit Files arbeitest und nicht mit Blöcken. Der Kernel arbeitet mit Blöcken. Und er muss irgendwie vom File + Offset auf den Block kommen.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Ja Klar&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Unser ext2 hier hat 1 KB Blocksize. Wir lesen das File &lt;code&gt;/boot/vmlinuz-2.6.13-15-default&lt;/code&gt; (inode 36). Und zwar am Offset 1000000 (1 mio). Der wievielte Block im File ist das?&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; &lt;em&gt;denk&lt;/em&gt;. Erstmal hat man ja nur den Dateinamen.&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Ja, das kümmert uns gerade noch nicht. Offset 1 mio &amp;ndash; welcher block? 1000000/1024 = 976.5625. Also Bytes 0-1023 sind Block 0, Bytes 1024-2047 sind Block 1 und so weiter.  In unserem fall also block 976. 976*1024=999424, 1000000-999424=576. Byte 1 000 000 steht also in Block 976, an Position 576 in diesem Block.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Okay. Stop mal. Hab da gleich ne Frage dazu:&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; 21:40 Isotopp&amp;gt; und das Wichtigste in &lt;code&gt;struct: __le32 i_block[EXT2_N_BLOCKS];&lt;/code&gt;
theclaw&amp;gt; dieser kontext: &lt;code&gt;i_block[976]&lt;/code&gt; brauchen wir da also. Ack? Und dazu noch das offset dazu?&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Ja, aber den kriegen wir nicht so.
&lt;a href=&#34;http://kris.koehntopp.de/artikel/dateisysteme/filestructure.gif&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://kris.koehntopp.de/artikel/dateisysteme/filestructure.gif&lt;/a&gt;

.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Ja, das wollte ich grad sagen. :-P Blocks 0-11 kriegen wir so. Muss man sich halt den Weg durchhangeln.&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; blocks 12-267 kriegen wir über den IND (single indirect block). Und blocks 268- kriegen wir über den DIND und den passenden IND.&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; 976-12=964, 964-256=708. 708/256=2.7656. Also müssen wir über den 2. IND des DIND gehen.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Ich weiss nicht ganz was du da rechnest.&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Naja, 1 KB blockgroesse, 4 byte pro blocknummer, also 256 blockadressen pro Block. 976ter Block ist gefragt.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; ay&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; 12 direct blocks, also 964 blocks dahinter.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Also mit einem &amp;ldquo;indirekten block&amp;rdquo; kann man 256 andere Blöcke adressieren, wie pointer in C&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Ich hab noch ganz grundlegende Fragen. Was wir wirklich wollen, ist doch das mapping logische Ext2block-Adresse der Datei → physische Blockadresse. Richtig?&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; In diesem speziellen Fall: ja. Die allgemeine Formulierung lautet so: Wir haben ein Quadrupel (major number, minor number, inode number, offset in bytes), das ist ein Device, eine Partition (maj, min), und in dem Device ein File (inode), und in dem File eine Byteposition. Und wir wollen ein Tripel (maj, min, blockno), also in der partition (maj, min) den zu dieser Datei gehörenden physikalischen Block.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; jo&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Weil (maj, min) bei dieser Abbildung konstant sind (wir arbeiten immer innerhalb derselben partition), vergessen wir maj und min und reden von einer Funktion die (ino, offset) auf (phy block) abbildet. Das nennt man ein Mapping. Und zwar ein Mapping für Datenblöcke. Daher heisst die funktion &lt;code&gt;bmap&lt;/code&gt;. Jedes Dateisystem hat so eine Funktion, daher reden wir hier über die bmap funktion von ext2, die heisst also sinnigerweise &lt;code&gt;ext2_bmap&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Schonmal sauhilfreich. ext2_bmap: Jetzt kann ich mir was darunter vorstellen. Danke. &lt;em&gt;codesuch&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Es ist eine diskrete Funktion.&lt;/p&gt;
&lt;p&gt;y = mx+k. Das sind kontinuierliche Funktionen von R-&amp;gt;R.&lt;/p&gt;
&lt;p&gt;Wir arbeiten hier mit diskreten, endlichen Funktionen. Die werden in der Regel als Lookuptable realisiert.&lt;/p&gt;
&lt;p&gt;Es gibt also eine Wertetabelle, die jedem (ino, offset) ein (phy block) zuordnet.&lt;/p&gt;
&lt;p&gt;Die Wertetabelle &lt;em&gt;ist&lt;/em&gt; die Inode. Eine Inode ist also ein Array von Blocknummern.&lt;/p&gt;
&lt;p&gt;Wenn es ein naives Array waere, dann waere die Inode variabel groß und für große Dateien sehr, sehr gross. Das ist wenig effizient.&lt;/p&gt;
&lt;p&gt;Daher hat man die Inode komprimiert, für kleine dateien (bis 12 blocks) speichert man die Wertetabelle tatsächlich &lt;em&gt;in&lt;/em&gt; der Inode (i_blocks[0-11]),
aber stell Dir dieses Verfahren mal für 1000 Blocks vor. Das wäre doof.&lt;/p&gt;
&lt;p&gt;Also speichert man die Wertetabelle für die Blöcke 12-267 nicht in der Inode, sondern in einem für diesen Zweck bestellten block, indem indirect block und in der Inode nur den einen Eintrag für diesen Block.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Ich habs soweit gecheckt.&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Das kann man beweisen.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;linux:/boot # dd if=/dev/zero of=kris bs=1k count=12
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;12 blocks a 1 KB (ich hab ja ein ext2 mit 1 KB blocks).&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;linux:/boot # ls -ls kris
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;12** -rw-r--r--  1 root root 12288 Dec 26 17:30 kris
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;12288 bytes lang 12 blocks belegt. Nun mal 13 KB.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;linux:/boot # dd if=/dev/zero of=kris bs=1k count=13
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;linux:/boot # ls -ls kris
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;14 -rw-r--r--  1 root root 13312 Dec 26 17:30 kris
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;13312 bytes, aber 14 blocks! Da ist er, der IND.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; &lt;em&gt;selbstausprobier&lt;/em&gt; Ist das die Anzahl der Blöcke für das Inode inklusive den Daten?&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Das ist die Anzahl der Blöcke OHNE die inode selber (Die belegt 128 byte in der Inodetable), also Daten + IND + DIND + TIND. Kann man auch beweisen.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;linux:/boot # dd if=/dev/zero of=kris bs=1k count=0
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;linux:/boot # ls -ls kris
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;0 -rw-r--r--  1 root root 0 Dec 26 17:33 kris
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Isotopp&amp;gt; File mit 0 Byte belegt 0 Blocks, Inode wird also nicht gezählt.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; okay. Das war hilfreich die Erklaerung, danke.&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Also wir haben in der Inode das Lookup Array für eine diskrete Funktion, eine Wertetabelle,
und die Speicherung des Array ist ulkig. Und wir haben deswegen overhead, weil wir die
mit 1, 2 und 3 markierten Blöcke in
&lt;a href=&#34;http://kris.koehntopp.de/artikel/dateisysteme/filestructure.gif&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://kris.koehntopp.de/artikel/dateisysteme/filestructure.gif&lt;/a&gt;


irgendwann belegen müssen. Und deswegen siehst du die Sprünge - kein File hat jemals 13 Blocks.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Moment, aber das ist ja sau umständlich eine ganze Datei zu lesen dann? :)&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Ah! Jetzt dämmert es langsam. Ist ja nicht so, dass ext2 GUT wäre.&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; So, jetzt gehen wir noch mal in den Code&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Das ist
&lt;a href=&#34;http://lxr.linux.no/source/fs/ext2/inode.c#L665&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ext2_bmap&lt;/a&gt;

, sehr kurz. Du erinnerst dich: JEDES Dateisystem hat ein bmap.
Darum ist &lt;code&gt;ext2_bmap&lt;/code&gt; sehr kurz, es ruft &lt;code&gt;generic_block_bmap&lt;/code&gt; auf. Das wiederum ruft dann allerdings
&lt;code&gt;ext2_get_block&lt;/code&gt; auf, das die Arbeit für &lt;code&gt;generic_block_bmap&lt;/code&gt; macht. &lt;code&gt;generic_block_bmap&lt;/code&gt; kriegt also
einen Callback nach &lt;code&gt;ext2_get_block&lt;/code&gt; mitgegeben. Wir landen also in
&lt;a href=&#34;http://lxr.linux.no/source/fs/ext2/inode.c#L547&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ext2_get_block&lt;/a&gt;

. So weit so klar?&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Ja warte. Ich schau mir den Code gerade an.&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Tut nicht not. Noch nicht. Erst mal ist nur wichtig, wie wir zu &lt;code&gt;ext2_get_block&lt;/code&gt;
kommen und wieso da ein Umweg über das &lt;code&gt;generic_block_bmap&lt;/code&gt; gemacht wird.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Nicht klar. Warte. Wo bei &lt;code&gt;ext2_get_block()&lt;/code&gt; ist das Offset?&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; in &lt;code&gt;iblock&lt;/code&gt; (2. parameter), ist schon umgerechnet in eine blocknummer.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Ah klar, der n. block eines inodes.&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Wir sind also in
&lt;a href=&#34;http://lxr.linux.no/source/fs/ext2/inode.c#L547&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://lxr.linux.no/source/fs/ext2/inode.c#L547&lt;/a&gt;

 und sollen &lt;code&gt;iblock&lt;/code&gt;
aus &lt;code&gt;inode&lt;/code&gt; (1. parameter) fischen. Also block 976 aus file 36. Wir müssen ja nun je nach
Blockoffset unterschiedlich kompliziert die Lookuptable runterklettern. Bei blocks 0-11 wäre
alles ganz einfach, bei 12-267 kommt der IND dazu und bei den folgenden Blöcken der DIND.
Soweit das Verfahren grundsätzlich klar?&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Ich schau mir das .gif nochmal an.&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Es wird leichter, wenn du
&lt;a href=&#34;http://lxr.linux.no/source/fs/ext2/inode.c#L196&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://lxr.linux.no/source/fs/ext2/inode.c#L196&lt;/a&gt;

 liest.
&lt;code&gt;i_block&lt;/code&gt; ist also 976. Dann schau mal in die Zeile 196. Zeile 201: &lt;code&gt;direct_blocks&lt;/code&gt; ist 12. &lt;code&gt;indirect_blocks&lt;/code&gt; ist ptrs, also 256.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; &lt;code&gt;ext2_block_to_path&lt;/code&gt;. Das &lt;code&gt;path&lt;/code&gt; hat nix mit dem Dateisystempfad zu tun, sondern mit dem Pfad, wie man zum Block kommt. Ahh.&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Es geht um den Path in
&lt;a href=&#34;http://kris.koehntopp.de/artikel/dateisysteme/filestructure.gif&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://kris.koehntopp.de/artikel/dateisysteme/filestructure.gif&lt;/a&gt;

, ja.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Warte, ich hab eine Frage zu dem GIF. Da z.b. &amp;ldquo;1&amp;rdquo;, also der erste indirekte Block. Der koennte auf 256 weitere zeigen?&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Ja. In unserem Beispiel ist das so, 4 byte pro blocknummer und 1 kb pro block. Bei anderen
Größen (8 byte pro blocknr, und 4 kb pro block) ist das anders. 4096/8 = 512 pro IND z.B.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; hm. Sorry, ich dachte ne Blocknummer ist 32bit?&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Ja, in unserem Beispiel ist das so. Aber es waere ja möglich, das alles mit anderen Sizes zu compilen.
Und dann soll es auch noch funktionieren. Also coden wir das alles nicht hart rein, sondern speichern die
Rahmendaten im Superblock des Filesystems und schreiben den Code ordentlich. Soweit so klar?&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; jo&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Drum auch der Code in
&lt;a href=&#34;http://lxr.linux.no/source/fs/ext2/inode.c#L196&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://lxr.linux.no/source/fs/ext2/inode.c#L196&lt;/a&gt;

, Zeilen 199 bis 203.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Den ich mir grad anschaue. ;)&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Der fragt den Superblock sb nach den Anzahl der Adressen pro Block, und bestimmt dann die &lt;code&gt;direct_blocks&lt;/code&gt;,
die Anzahl der Blockadressen pro indirect Block in &lt;code&gt;indirect_block&lt;/code&gt; und die Anzahl der Blockadressen pro Double Indirect Block.&lt;/p&gt;
&lt;p&gt;Der macht das ein wenig komisch. Erst mal &lt;code&gt;direct_blocks&lt;/code&gt;. Das ist leicht, da nimmt er nur den #define.
&lt;code&gt;indirect_blocks&lt;/code&gt; ist auch leicht, das ist ptrs, also &lt;code&gt;EXT2_ADDR_PER_BLOCK(...sb)&lt;/code&gt;, also mal im Superblock nachschlagen.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;[#define EXT2_ADDR_PER_BLOCK(s)          (EXT2_BLOCK_SIZE(s) / sizeof (__u32))](http://lxr.linux.no/source/include/linux/ext2_fs.h#L100)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Block size bei uns 1024 und &lt;code&gt;sizeof __u32&lt;/code&gt; ist immer 4. Also ist mein beispiel mit 8 derzeit hypothetisch.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; ;)&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Ein double block kann ebenfalls ptrs viele Blockadressen enthalten, also 256 Stück. Jede von denen ist ein indirect block, der 256 Datenblöcke enthält.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; also 256^2 und ein TIND für 256^3.&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Nun will er das aus irgendeinem Grund nicht so rechnen, sondern mit bit shifts, also macht er 1 &amp;laquo; (ptrs_bits * 2).&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Also warte, kann man 256+256^2+256^3 Blöcke adressieren, d.h. kann ne Datei so groß sein?&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Ja, das ist auch noch ein Limit. Aber da wir nur 2^32 viele Blocknummern haben, ist bei 4 Gigablocks Schluss, also bei 4 TB (1 kb Blöcke) oder 16 TB (4 kb Blöcke).&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Okay, irgendwie so ;)&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Du müßtest schon die Blocknummern länger machen als ein &lt;code&gt;__u32&lt;/code&gt;, damit mehr geht, dann passen aber weniger direct_blocks in eine Inode, oder die Inode wird größer.&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Aber wir wollen mal weiter im Code. Schau in zeile 207. Was machen die da?&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; &lt;code&gt; if (i_block &amp;lt; 0) {&lt;/code&gt;
Isotopp&amp;gt; geht das überhaupt?&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Warte&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Nah, nur durch nen Programmierfehler evtl.&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Welchen typ hat &lt;code&gt;i_block&lt;/code&gt;?&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; unsigned? :) Ja, okay. Das geht überhaupt nicht.&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Steht oben in der Funktion - da ist es ein LONG!&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; ah, doch ein signed :)&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Aber eine Blocknummer, das haben wir vorher gesehen, ist ein &lt;code&gt;__u32&lt;/code&gt;!&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Macht das sinn?&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Nein, das ist FAHALSCH!&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Sag das doch!&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Du hast gerade deinen ersten Kernelfehler gefunden.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Geil! ;)&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Der Fehler sieht Blocknummern als signed, daher ist also nun schon bei 2 Gigablocks zu, also 2 TB und 8 TB Filesize (für 1 und 4 kb Blocksize). Aber weiter im Text, Zeile 209.&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Weiter zu 212. &lt;code&gt;((i_block -= direct_blocks) &amp;lt; indirect_blocks)&lt;/code&gt; ist dir auch klar? Wir zermatschen &lt;code&gt;i_blocks&lt;/code&gt; hier als Seiteneffekt.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; ja bin ein C-ler. Daran scheitert die Erklaerung nicht ;)&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Also sind wir in 216. Nun ist &lt;code&gt;i_block&lt;/code&gt; also 964 und wir ziehen 256 (&lt;code&gt;indirect_blocks&lt;/code&gt;) ab. Das sind 708. Und &lt;code&gt;double_blocks&lt;/code&gt; ist 256^2. Also true. Also speichern wir in 217: lese &lt;code&gt;EXT2_DIND_BLOCK&lt;/code&gt;, dann in 218: lese &lt;code&gt;i_block/256&lt;/code&gt; (&lt;code&gt;i_block &amp;gt;&amp;gt; ptrs_bits&lt;/code&gt;), und in 219: lese &lt;code&gt;i_block % 256&lt;/code&gt; (&lt;code&gt;i_block &amp;amp; ( ptrs - 1)&lt;/code&gt;). Dann sind wir fertig.&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Wir sind wieder in &lt;a href=&#34;http://lxr.linux.no/source/fs/ext2/inode.c#L547&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://lxr.linux.no/source/fs/ext2/inode.c#L547&lt;/a&gt;

, line 557 nun, soweit klar?&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Kleinen Moment, das Bitshifting finde ich verwirrend.&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; ja&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; ich weiss jetzt, was &lt;code&gt;ext2_block_to_path&lt;/code&gt; macht.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Also warte mal. Lass mich mal zusammenfassen.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Naja, nicht mal so einfach zu beschreiben.&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Doch schon. Dir fehlen nur die Worte.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; :] jo&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Wir haben nun offset[0], offset[1] und offset[2]. In offset[0] steht welches Feld aus der Inode wir nehmen (das DIND feld),  Wir haben dann einen Block mit 256 Feldern, und nehmen das Feld offset[1] da draus, lesen den Block und nehmen das Feld offset[2] da draus.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Naja, das sind ja Details. Mich interessiert aber eher das Design als die Implementation ;), Das geht mir schon zu sehr in die Tiefe ehrlich gesagt.&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Allgemeiner: wir haben ein Array, das nicht linear ist, sondern quadratisch steigend durch Indirektion komprimiert wird, und bei unseren Randparametern ist die schrittweite 8 bit (256 entries) pro Block, also 256, 256^2, 256^3, &amp;hellip; und das ist genau die Zeichnung
&lt;a href=&#34;http://kris.koehntopp.de/artikel/dateisysteme/filestructure.gif&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://kris.koehntopp.de/artikel/dateisysteme/filestructure.gif&lt;/a&gt;

.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Okay. Jetzt sind meine Fragen geklärt oder? Dieses ganze Detailwissen erschlägt mich ;)&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Der Rest sind tatsaechlich Kerneldetails. Das hier war die Logik. Der Punkt ist, dass du in &lt;code&gt;block_to_path&lt;/code&gt; durch die Faltlogik geklettert bist. Also die, die das mit DIR, IND, DIND und TIND analysiert und entscheidet.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Naja, Faltlogik?&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Ja, erst 12 direkt, dann 256 einmal gefaltet, dann 256*256 zweimal gefaltet, dann 256*256*256 dreimal gefaltet statt eines einzigen linearen Arrays das zum groessten Teil leer waere.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Hm, ich versteh zwar das System, aber nicht was das mit Falten zu tun hat ;)&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Naja, statt eines Array mit 2 Gigaentries (Kernelbug!) hast du ein Array mit 15 Eintraegen, bei dem die ersten 12 Eintraege für sich selber stehen, der Eintrag 13 für 256 Eintraege, der Eintrag 14 für 256 Eintraege, die für 256 Eintraege stehen, steht, und der Eintrag 15 für 256 Eintraege die für 256 Eintraege, die für 256 Eintraege stehen steht. Also einmal falten, zweimal falten, dreimal falten.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Aber &amp;ldquo;falten&amp;rdquo;?&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; So in etwa:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;   ___
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;___\ /___
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;theclaw&amp;gt; Was stellt das dar?&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Ein Eintrag, der für viele steht. Ein Blatt Papier mit zwei Knicks, ein Eintrag (der zwischen \ /) steht für Drei (___)&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Und zum Schluß
&lt;a href=&#34;http://www.tamacom.com/tour.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://www.tamacom.com/tour.html&lt;/a&gt;

,
&lt;a href=&#34;http://www.tamacom.com/tour/kernel/unix/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://www.tamacom.com/tour/kernel/unix/&lt;/a&gt;

,
&lt;a href=&#34;http://www.tamacom.com/tour/kernel/unix/S/97.html#L18&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://www.tamacom.com/tour/kernel/unix/S/97.html#L18&lt;/a&gt;

.&lt;/p&gt;
&lt;p&gt;Das, mein Freund, ist der Urvater aller bmaps, bmap in V7 Unix.&lt;/p&gt;
&lt;p&gt;Rein gehen eine &lt;code&gt;struct inode&lt;/code&gt;, die inode,  eine &lt;code&gt;daddr_t bn&lt;/code&gt;, eine blocknummer und ein &lt;code&gt;rwflag&lt;/code&gt;, das ist aber Wurst. Raus geht eine &lt;code&gt;daddr_t&lt;/code&gt; blocknummer.&lt;/p&gt;
&lt;p&gt;Also (ino, block_in_file) -&amp;gt; (phys blocknr). NADDR ist die Anzahl der Eintraege in der Inode. Also sind 0-&amp;gt; NADDR-4 die direct blocks, NADDR-3 der IND,  NADDR-2 der DIND  und NADDR-1 der TIND.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Aber den Code will ich mir jetzt nicht genauer ansehen, sorry ;)&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Das ist derselbe Code, nur noch verquaster. Der ist ja auch 30 Jahre alt.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Den Link bookmarke ich mal, das könnte noch interessant werden.&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Und weil es so schön ist, sind da auch die FreeBSD, NetBSD, OpenBSD und Hurd Versionen von demselben Zeug. Und da kannst du dann sehen wie fundamental das ist, was Du da gerade anfasst. Und wie sich C-Style im Kernel in den letzten 30 Jahren so entwickelt hat. Weil das V7 Zeugs da sind etwa 30 Jahre von hier, das 4.3BSD sind ca. 20 Jahre von hier und das Linux-Zeugs ist von jetzt.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Wenn ich das so seh fällt mir grad auf wie sinnvoll man seine Zeit nützen könnte ;)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>User und Gruppen, Prozesse und Dateien</title>
      <link>https://blog.koehntopp.info/2005/11/01/user-und-gruppen-prozesse-und-dateien.html</link>
      <pubDate>Tue, 01 Nov 2005 18:41:28 +0000</pubDate>
      
      <guid>https://blog.koehntopp.info/2005/11/01/user-und-gruppen-prozesse-und-dateien.html</guid>
      <description>&lt;p&gt;Heute im Irc stellte eine Teilnehmerin den folgenden Fragenschwall:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Wie finde ich eigentlich heraus, was für Gruppen es auf einem
Linuxsystem gibt? Wie füge ich da jemanden hinzu? Lege ich den
zuerst als User an, ganz normal? Und: Wenn ich einen Ordner
anlege, der nur für eine bestimmte Gruppe zugänglich sein
soll, mache ich das doch über File Permissions, oder habe ich
falsch gedacht?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Die offensichtliche Antwort, das Nachsehen in &lt;code&gt;/etc/group&lt;/code&gt;,
funktioniert bei modernen Unixen nicht mehr zwingend, denn
Gruppendefinitionen können nicht nur in lokalen Dateien stehen,
sondern auch aus dem NIS, dem NIS+, einem LDAP oder einem Active
Directory kommen.&lt;/p&gt;
&lt;p&gt;Die folgenden Dinge wurden mit Suse Linux 10.0 getestet, sollten
so aber auch auf Solaris funktionieren.&lt;/p&gt;
&lt;h2 id=&#34;name-service-switch&#34;&gt;
    &lt;a href=&#34;#name-service-switch&#34;&gt;
	Name Service Switch
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Genauer gesagt haben moderne Unixe ein Subsystem namens Name
Service Switch. Der Name Service Switch erlaubt es dem System,
für Benutzer, Gruppen, Hostnamen, Protokolle, Service und noch
ein paar Dinge beliebige Datenquellen zu verwenden, für die
vorgefertige Module existieren.&lt;/p&gt;
&lt;p&gt;Der Name Service Switch wird durch die Datei
&lt;code&gt;/etc/nsswitch.conf&lt;/code&gt; gesteuert. Dort findet man für jede
Datenbasis (passwd, group, hosts, &amp;hellip;) einen einzeiligen
Eintrag. Nach dem Namen der Datenbasis werden durch Leerzeichen
getrennt die Namen der Datenquellen aufgelistet, und zwar in der
Reihenfolge, in der sie durchsucht werden sollen.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;passwd: files nis
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;shadow: files nis
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;group: files nis
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;hosts: files dns
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Diese Beispielkonfiguration holt ihre Benutzerdaten für Passwd-
und Shadow-Datei sowie die Gruppen aus den lokalen Dateien und
danach aus dem NIS, und sie ermittelt Hostnamen aus der lokalen
&lt;code&gt;/etc/hosts&lt;/code&gt; und danach aus dem DNS.&lt;/p&gt;
&lt;p&gt;Die Syntax für die &lt;code&gt;/etc/nsswitch.conf&lt;/code&gt; ist noch ein wenig
komplizierter. Zwischen den Einträgen für Datenquellen können in
eckigen Klammern nämlich noch Anweisungen für das Verhalten in
Fehlerfällen stehen. Auf diese Weise sind Setups möglich, die
ihre Daten normalerweise NUR aus dem NIS ziehen, aber aus den
lokalen Dateien, falls das NIS einmal nicht erreichbar sein
sollte.&lt;/p&gt;
&lt;p&gt;Die Datenbasen des Name Service Switch lassen sich mit dem
Kommando &lt;code&gt;getent&lt;/code&gt; testen. &lt;code&gt;getent group&lt;/code&gt; listet zum Beispiel die
gesamte &lt;code&gt;group&lt;/code&gt;-Datenbasis auf, &lt;code&gt;getent group disk&lt;/code&gt; listet nur
den Eintrag für die Gruppe &lt;code&gt;disk&lt;/code&gt; auf.&lt;/p&gt;
&lt;p&gt;Wir merken uns:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In einem modernen Unix mit Name Service Switch ist es also
falsch, eine Liste der Gruppen des Systems durch Auslesen von
&lt;code&gt;/etc/group&lt;/code&gt; zu erzeugen. Stattdessen muß die Liste mit
&lt;code&gt;getent group&lt;/code&gt; erzeugt werden.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Das Interface des Name Service Switch ist read-only. Es erlaubt
nicht die virtualisierte Erzeugung von Gruppen. Schreibzugriffe
müssen also weiterhin manuell in die richtige Datenbank geroutet
werden, also in eine lokale Datei oder in ein LDAP geschrieben
werden.&lt;/p&gt;
&lt;h2 id=&#34;prozesse-und-dateien&#34;&gt;
    &lt;a href=&#34;#prozesse-und-dateien&#34;&gt;
	Prozesse und Dateien
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;User und Gruppen sind nur dann von Bedeutung, wenn sie auch vom
Systemteilen verwendet werden. Systemteile sind Subjekte, also
Prozesse, und Objekte, also Dateien.&lt;/p&gt;
&lt;p&gt;Ein Prozeß in Unix hat eine effektive User-ID und eine effektive
primäre Gruppen-ID. Er kann außerdem eine Reihe von weiteren
sekundären Gruppen-IDs enthalten.&lt;/p&gt;
&lt;p&gt;Das Kommando &amp;ldquo;id&amp;rdquo; listet die User- und Gruppen-IDs eines Benutzers:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;kris@dhcp-179:~&amp;gt; id -a
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;uid=1000(kris) gid=100(users) Gruppen=16(dialout),33(video),100(users)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Der Benutzer kris hat also die User-ID 1000 und die primäre
Gruppen-ID 100. Er gehört außerdem den Gruppen 16 (dialout) und
33 (video) an.&lt;/p&gt;
&lt;p&gt;Wenn dieser Prozeß eine Datei erzeugt, dann gehört diese Datei
ebenfalls dem Benutzer 1000 (kris) und sie wird standardmäßig
(&amp;ldquo;System V Semantik&amp;rdquo;) der Gruppe 100 (users) angehören, denn
dies sind die primäre User- und Gruppen-ID dieses Prozesses.&lt;/p&gt;
&lt;p&gt;Es gibt eine andere Betriebsart für Dateisysteme (&amp;ldquo;BSD Semantik&amp;rdquo;), bei der neu angelegte Dateien nicht die primäre Gruppe des anlegenden Prozesses erben, sondern die Gruppe des unmittelbar übergeordneten Verzeichnisses. Man kann das ext2-Dateisystem komplett auf BSD-Semantik umstellen, indem man es mit der Option &amp;ldquo;grpid&amp;rdquo; (alternativ &amp;ldquo;bsdgroups&amp;rdquo;) mounted - der Default ist &amp;ldquo;nogrpid&amp;rdquo; (alternativ &amp;ldquo;sysvgroups&amp;rdquo;). In der Betriebsart &amp;ldquo;nogrpid&amp;rdquo; kann man für ein einzelnes Verzeichnis BSD Semantik wählen, indem man das SGID-Bit an dem Verzeichnis setzt. Hier ein Beispiel:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;dhcp-179:~ # lvcreate -l 10 -n test system
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;Logical volume &amp;#34;test&amp;#34; created
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;dhcp-179:~ # mke2fs -q /dev/system/test
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;dhcp-179:~ # mount -o nogrpid /dev/mapper/system-test /export/test
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;dhcp-179:~ # mkdir /export/test/bla /export/test/fasel
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;dhcp-179:~ # chown kris:video /export/test/bla /export/test/fasel
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;dhcp-179:~ # chmod g+s /export/test/fasel
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;dhcp-179:~ # su - kris
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;kris@dhcp-179:~&amp;gt; cd /export/test
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;kris@dhcp-179:/export/test&amp;gt; touch bla/eins fasel/zwei
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;kris@dhcp-179:/export/test&amp;gt; ls -l bla/eins fasel/zwei
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;-rw-r--r-- 1 kris users 0 2005-11-01 18:59 bla/eins
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;-rw-r--r-- 1 kris video 0 2005-11-01 18:59 fasel/zwei
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;kris@dhcp-179:/export/test&amp;gt; ls -ld bla fasel
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;drwxr-xr-x 2 kris video 1024 2005-11-01 18:59 bla
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;drwxr-sr-x 2 kris video 1024 2005-11-01 18:59 fasel
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;In diesem Beispiel wird das logical Volume &lt;code&gt;test&lt;/code&gt; in der Volume
Group &lt;code&gt;system&lt;/code&gt; angelegt und mit dem ext2-Dateisystem formatiert.
Das Dateisystem wird mit der Option &lt;code&gt;nogrpid&lt;/code&gt; als /export/test
gemountet, was der Default für ext2 ist (und bei reiserfs
unveränderlich immer der Fall ist).&lt;/p&gt;
&lt;p&gt;In &lt;code&gt;/export/test&lt;/code&gt; werden die Verzeichnisse &lt;code&gt;bla&lt;/code&gt; und &lt;code&gt;fasel&lt;/code&gt; anlegt
und beide auf &lt;code&gt;kris:video&lt;/code&gt; gesetzt. An &lt;code&gt;fasel&lt;/code&gt; wird zusätzlich noch
das SGID-Bit gesetzt.&lt;/p&gt;
&lt;p&gt;Legt der User &lt;code&gt;kris:users&lt;/code&gt; nun in &lt;code&gt;bla&lt;/code&gt; und &lt;code&gt;fasel&lt;/code&gt; jeweils eine Datei
an, wird die Datei in &lt;code&gt;bla&lt;/code&gt; (System V Semantik, bzw. nogrpid) der
Gruppe users angehören. Die Datei in &lt;code&gt;fasel&lt;/code&gt; (BSD Semantik, durch
+s umgeschaltet) erbt ihre Gruppenzugehörigkeit jedoch vom
übergeordneten Verzeichnis, gehört also &lt;code&gt;kris:video&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Dasselbe Beispiel wie oben für ein Dateisystem, das mit &lt;code&gt;grpid&lt;/code&gt;
gemountet wurde, ergibt dann das folgende Bild:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;kris@dhcp-179:/export/test&amp;gt; touch bla/eins fasel/zwei
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;kris@dhcp-179:/export/test&amp;gt; ls -ld bla fasel
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;drwxr-xr-x 2 kris video 1024 2005-11-01 19:04 bla
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;drwxr-sr-x 2 kris video 1024 2005-11-01 19:04 fasel
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;kris@dhcp-179:/export/test&amp;gt; ls -l bla/eins fasel/zwei
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;-rw-r--r-- 1 kris video 0 2005-11-01 19:04 bla/eins
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;-rw-r--r-- 1 kris video 0 2005-11-01 19:04 fasel/zwei
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Das SGID-Bit am Verzeichnis hat dann also keine Wirkung mehr,
weil das Dateisystem an sich hier schon BSD-Semantik hat.&lt;/p&gt;
&lt;p&gt;Reiserfs kennt die Optionen &lt;code&gt;grpid&lt;/code&gt; und &lt;code&gt;nogrpid&lt;/code&gt; nicht und
verhält sich immer wie ein ext2-Dateissystem mit &lt;code&gt;nogrpid&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Wie kann man nun ein Verzeichnis einer Gruppe schenken? Nun, das
geht einfach mit chgrp:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;kris@dhcp-179:~&amp;gt; mkdir keks
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;kris@dhcp-179:~&amp;gt; chgrp video keks
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;kris@dhcp-179:~&amp;gt; chgrp disk keks
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;chgrp: Ändern der Gruppe für „keks“: Die Operation ist nicht erlaubt
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;kris@dhcp-179:~&amp;gt; chgrp users keks
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Offenbar kann man ein Verzeichnis nur Gruppen schenken, denen
man selbst angehört. Das ist deswegen so, weil Unix die
Zuordnung von Quotas zu Benutzern und zu Gruppen erlaubt. Indem
man eine Datei einer Gruppe schenkt, belastet die Datei die
Quota der Gruppe und natürlich darf man nur die Quota einer
Gruppe belasten, der man auch angehört.&lt;/p&gt;
&lt;p&gt;Wenn man eine Datei in einem Verzeichnis mit BSD-Semantik
anlegt, dann erbt diese Datei jedoch immer die Gruppe des
Verzeichnisses, selbst dann, wenn der Benutzer, der die Datei
anlegt, nicht dieser Gruppe angehört - hier kann dann ein
fremder Benutzer die Quota einer Gruppe belasten, der er nicht
angehört. Es ist also Aufgabe einer Gruppe, die Zugriffsrechte
an ihren Verzeichnissen so zu setzen, daß dort nicht fremde
Leute Daten ablegen können und so die Quota der Gruppe belasten.&lt;/p&gt;
&lt;p&gt;Es ist außerdem möglich (wenn auch unwahrscheinlich), daß ein
Benutzer so eine Datei anlegen kann, die er später nicht mehr
lesen darf.&lt;/p&gt;
&lt;p&gt;Das Szenario ist konstruiert, aber technisch möglich:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;gp&#34;&gt;#&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;# Kris legt ein Verzeichnis an&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;kris@dhcp-179:~&amp;gt; mkdir keks
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;kris@dhcp-179:~&amp;gt; chmod a+rwx,g+s keks
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;kris@dhcp-179:~&amp;gt; chgrp video keks
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;kris@dhcp-179:~&amp;gt; ls -ld keks
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;drwxrwsrwx 2 kris video 48 2005-11-01 19:17 keks
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;gp&#34;&gt;#&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;# kdebuild legt dort eine Datei an&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;kdebuild@dhcp-179:/home/kris/keks&amp;gt; umask 0727
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;kdebuild@dhcp-179:/home/kris/keks&amp;gt; touch bla
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;kdebuild@dhcp-179:/home/kris/keks&amp;gt; ls -l bla
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;----r----- 1 kdebuild video 0 2005-11-01 19:18 bla
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;kdebuild@dhcp-179:/home/kris/keks&amp;gt; cat bla
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;cat: bla: Keine Berechtigung
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Das ist für ein Rechtesystem eine unschöne Situation. Fällt
jemandem ein sinnvoller Anwendungszweck für diese Eigenschaft
des Unix-Rechtesystems ein?&lt;/p&gt;
&lt;p&gt;Wir merken uns:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Um ein Verzeichnis zu erzeugen, auf das nur eine bestimmte
Gruppe Zugriff hat, legen wir das Verzeichnis an und schenken
es der Gruppe mit &lt;code&gt;chgrp&lt;/code&gt;, dann setzen wir die Zugriffsrechte
auf &lt;code&gt;rwxrwx---&lt;/code&gt; oder ähnlich.&lt;/p&gt;
&lt;p&gt;Wenn wir außerdem das SGID-Bit am Verzeichnis mit &lt;code&gt;chmod g+s …&lt;/code&gt; setzen, werden auch alle Dateien im Verzeichnis der
Gruppe gehören. Um ein Verzeichnis einer Gruppe schenken zu
können, muß man selbst Mitglied der Gruppe sein.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;zugriffsrechte-an-dateien&#34;&gt;
    &lt;a href=&#34;#zugriffsrechte-an-dateien&#34;&gt;
	Zugriffsrechte an Dateien
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;In den letzten 30 Jahren war es in Unix immer so, daß eine Datei
einen Eigentümer und eine Eigentümer-Gruppe hatte. Rechte wurden
für den Eigentümer und die Eigentümer-Gruppe vergeben. Prozesse
hatten ebenfalls einen Eigentümer und eine Gruppe, und Unix hat
stur den folgenden simplen Test durchgeführt, um zu bestimmen,
welche Rechte für eine Datei gelten:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Stimmen der Datei-Eigentümer und der Prozeß-Eigentümer
überein? Wenn ja, dann gelten die User-Rechte, also das erste
rwx-Tripel. Das ist selbst dann der Fall, wenn in einem anderen
Tripel bessere Rechte definiert sind.&lt;/li&gt;
&lt;li&gt;Stimmen die Datei-Eigentümergruppe und eine der primären oder
sekundären Gruppen eines Prozesses überein? Wenn ja, dann gelten
die Gruppen-Rechte, also das zweite rwx-Tripel. Das ist selbst
dann der Fall, wenn im 3. Tripel bessere Rechte definiert
sind.&lt;/li&gt;
&lt;li&gt;In allen anderen Fällen gelten die Rechte aus dem 3. Tripel.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;access-control-lists-acls&#34;&gt;
    &lt;a href=&#34;#access-control-lists-acls&#34;&gt;
	Access Control Lists (ACLs)
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Mit modernen Unixen ist es jedoch alles viel komplizierter
geworden, denn nun können im Prinzip an einer Datei selber auch
viele Benutzer- und Gruppenrechte kleben.&lt;/p&gt;
&lt;p&gt;Zum Glück nicht per Default.&lt;/p&gt;
&lt;p&gt;Damit die Lage kompliziert wird, muß man das betreffende
Dateisystem mit der Option &lt;code&gt;acl&lt;/code&gt; mounten. Im Beispiel erzeugen
wir zur Abwechslung mal ein reiserfs und mounten dies mit der
passenden Option. Mit den Kommandos &lt;code&gt;getfacl&lt;/code&gt; und &lt;code&gt;setfacl&lt;/code&gt; (&amp;ldquo;get
and set a file access control list&amp;rdquo;) können wir dann lustig
individuelle Zugriffsrechte vergeben.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;dhcp-179:~ # lvcreate -l 10 -n test system
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;Logical volume &amp;#34;test&amp;#34; created
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;dhcp-179:~ # mkreiserfs -q /dev/system/test
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;mkreiserfs 3.6.18 (2003 www.namesys.com)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;dhcp-179:~ # mount -o acl /dev/mapper/system-test /export/test
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;dhcp-179:~ # cd /export/test
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;dhcp-179:/export/test # touch keks
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;dhcp-179:/export/test # chmod 000 keks
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;dhcp-179:/export/test # setfacl -m u:kris:rwx,mask::rwx,g:video:rwx,u:kdebuild:rx keks
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;dhcp-179:/export/test # ls -l keks
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;----rwx---+ 1 root root 0 Nov 1 19:26 keks
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;dhcp-179:/export/test # getfacl keks
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;&lt;/span&gt;&lt;span class=&#34;gp&#34;&gt;#&lt;/span&gt; file: keks
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;gp&#34;&gt;#&lt;/span&gt; owner: root
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;gp&#34;&gt;#&lt;/span&gt; group: root
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;user::---
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;user:kris:rwx
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;user:kdebuild:r-x
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;group::---
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;group:video:rwx
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;mask::rwx
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;other::---
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Eine Datei mit einer ACL wird von ls mit einem &amp;ldquo;+&amp;quot;-Zeichen
markiert. Statt den Rechten der Gruppe werden dann im  zweiten
Tripel die Rechte der Mask angezeigt.&lt;/p&gt;
&lt;p&gt;Die Mask limitiert alle anderen Zugriffsrechte an der Datei
ausgenommen den Eigentümer und Others. Sie legt also quasi die
maximalen Rechte fest, die irgendjemand außer dem Eigentümer an
der Datei haben kann, wenn er nicht die Defaultrechte bekommt.&lt;/p&gt;
&lt;p&gt;Dies ist ein Kompatibilitätsmechanismus, der meistens das
korrekte Verhalten von Programmen bewirken soll, die nichts von
Zugriffsrechten wissen - sie bekommen durch Auslesen des zweiten
Rechtetripels einen etwas optimistischen View auf die Rechte,
die sie wahrscheinlich haben werden. :)&lt;/p&gt;
&lt;p&gt;Das Kommando &lt;code&gt;setfacl&lt;/code&gt; kann jetzt die Rechte an einer Datei
modifizieren. Die Option &lt;code&gt;-m&lt;/code&gt; (modify) bewirkt das.&lt;/p&gt;
&lt;p&gt;Im Beispiel werden Rechte für Benutzer (&amp;ldquo;u:&amp;rdquo;) und Gruppen (&amp;ldquo;g:&amp;rdquo;)
sowie eine Mask (&amp;ldquo;m:&amp;rdquo;) definiert.&lt;/p&gt;
&lt;p&gt;Liest man die ACL mit getfacl aus, wird recht schnell deutlich,
was hier geschieht:&lt;/p&gt;
&lt;p&gt;Der Eigentümer der Datei hat an ihr keine Rechte, der User kris
hat die Rechte rwx, der User kdebuild hat die Rechte rx, die
Defaultgruppe hat keine Rechte, die Gruppe video hat die Rechte
rwx, und die Maske schränkt die Rechte von kris, kdebuild, video
und der Defaultgruppe nicht ein.&lt;/p&gt;
&lt;p&gt;Der Rest der Welt hat keine Rechte an dieser Datei.&lt;/p&gt;
&lt;p&gt;Wir merken uns:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Dateisysteme, die mit der Option &amp;ldquo;acl&amp;rdquo; gemounted wurden,
können beliebig komplizierte Rechteregeln pro Datei haben. Es
ist mit einem &amp;ldquo;+&amp;rdquo; an der Datei zu erkennen, ob dies der Fall
ist. Diese ACLs können mit setfacl editiert und mit getfacl
gelesen werden.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;acls-an-verzeichnissen&#34;&gt;
    &lt;a href=&#34;#acls-an-verzeichnissen&#34;&gt;
	ACLs an Verzeichnissen
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Um die Sache noch komplizierter zu machen, haben Verzeichnisse
&lt;em&gt;zwei&lt;/em&gt; ACLs:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Eine normale wie wir sie schon kennen, die für das Verzeichnis
selber gilt,&lt;/li&gt;
&lt;li&gt;eine &lt;em&gt;default&lt;/em&gt; ACL, die für alle Verzeichnisse
und Dateien gilt, die in dem Verzeichnis erzeugt werden.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Werte für die Default-ACL werden festgelegt, indem man sie beim
&amp;ldquo;setfacl&amp;rdquo; mit &amp;ldquo;d:&amp;rdquo; prefixed, also &amp;ldquo;d:u:kris:rwx&amp;rdquo;,
&amp;ldquo;d:g:video:rwx&amp;rdquo; und &amp;ldquo;dⓜ️:rwx&amp;rdquo;.&lt;/p&gt;
&lt;h2 id=&#34;tldr&#34;&gt;
    &lt;a href=&#34;#tldr&#34;&gt;
	TL;DR
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Wir merken uns:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In den allermeisten Fällen tut das Unix-Rechtesystem mit den
drei Tripeln &amp;ldquo;ugo&amp;rdquo; und den drei Rechten &amp;ldquo;rwx&amp;rdquo; genau das, was
man von ihm will.&lt;/p&gt;
&lt;p&gt;Sehr selten braucht man was komplizierteres, und dann steht es
zur Verfügung.&lt;/p&gt;
&lt;p&gt;Selbst dann ist das Rechtesystem von Unix noch einfacher und
übersichtlicher zu warten als das von Windows, getreu dem
Motto &amp;ldquo;Simple things should be simple, and complex things
should be possible.&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>#!/bin/bash -- Brace Expansion</title>
      <link>https://blog.koehntopp.info/2005/10/08/bin-bash-brace-expansion.html</link>
      <pubDate>Sat, 08 Oct 2005 08:43:57 +0000</pubDate>
      
      <guid>https://blog.koehntopp.info/2005/10/08/bin-bash-brace-expansion.html</guid>
      <description>&lt;p&gt;Eine Unix-Kommandoshell nimmt die Benutzereingabe und unterteilt sie in Worte.
Das erste Wort einer Zeile ist ein Kommando, der Rest sind die Parameter des Kommandos.
So weit so langweilig.&lt;/p&gt;
&lt;p&gt;Interessant wird die Sache, weil eine Unix Shell gut mit Worten umgehen kann.
So kann sie Worte ersetzen und dabei auch neue Worte generieren.
Dies nennt man Expansion, und die Bash hat sehr viele Expansion-Mechanismen:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;brace expansion,&lt;/li&gt;
&lt;li&gt;tilde expansion,&lt;/li&gt;
&lt;li&gt;parameter expansion,&lt;/li&gt;
&lt;li&gt;variable expansion,&lt;/li&gt;
&lt;li&gt;arithmetic expansion,&lt;/li&gt;
&lt;li&gt;command substitution,&lt;/li&gt;
&lt;li&gt;word splitting und&lt;/li&gt;
&lt;li&gt;pathname expansion, sowie&lt;/li&gt;
&lt;li&gt;process substitution&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;werden in dieser Reihenfolge auf den Worten einer Zeile durchgeführt.
Nicht alle diese Mechanismen sind in einer klassischen &lt;code&gt;#!/bin/sh&lt;/code&gt; enthalten.&lt;/p&gt;
&lt;p&gt;Wenn man schnell mal ein paar Pfadnamen braucht, ist
&lt;a href=&#34;http://ebergen.net/wordpress/?p=80&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Bash Brace Expansion&lt;/a&gt;


echt nützlich.
Die Grundidee ist diese:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;kris@valiant:~&amp;gt; echo a{b,c,d}e
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;abe ace ade
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Das kann man benutzen, um ähnliche Dinge aufzuzählen, ohne mehr schreiben zu müssen:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;kris@valiant:~/Source/tidy/src&amp;gt;ls parser.{c,h,o,lo}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;parser.c  parser.h  parser.lo  parser.o
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Dabei ist es durchaus erlaubt, einen Teilausdruck leer zu lassen:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;kris@h3118:/etc/httpd&amp;gt; ls -1 httpd.conf{,.old}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;httpd.conf
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;httpd.conf.old
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Aber Brace Expansion kann noch mehr: Bestandteil des Konzeptes sind auch Ranges.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;kris@valiant:~&amp;gt; mkdir x; for i in {0..10}; do mkdir x/$i; done; ls x
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;0  1  10  2  3  4  5  6  7  8  9
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;kris@valiant:~&amp;gt; mkdir y; for i in {a..z}; do mkdir y/$i; done; ls y
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Da die Erweiterung reihenfolgetreu ist, ist es sehr leicht, zum Beispiel alte Logfiles zu rotieren. Das geht dann so:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;kris@valiant:~/x&amp;gt; touch a.log
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;kris@valiant:~/x&amp;gt; for i in {9..0}; do olog=a.log.$i; nlog=a.log.$(( $i+1 )); [ -f $olog ] &amp;amp;&amp;amp; mv $olog $nlog; done; mv a.log a.log.0; touch a.log; ls
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;a.log  a.log.0
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;kris@valiant:~/x&amp;gt; for i in {9..0}; do olog=a.log.$i; nlog=a.log.$(( $i+1 )); [ -f $olog ] &amp;amp;&amp;amp; mv $olog $nlog; done; mv a.log a.log.0; touch a.log; ls
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;a.log  a.log.0  a.log.1
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Das letzte Beispiel verwendet eine weitere Bash-Expansion, Arithmethic Expansion.
Hier wird ein Ausdruck, der in &lt;code&gt;$(( ... ))&lt;/code&gt; steht, ausgerechnet und durch das Rechenergebnis ersetzt.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Wieviel Load darf es denn sein?</title>
      <link>https://blog.koehntopp.info/2005/06/24/wieviel-load-darf-es-denn-sein.html</link>
      <pubDate>Fri, 24 Jun 2005 08:47:16 +0000</pubDate>
      
      <guid>https://blog.koehntopp.info/2005/06/24/wieviel-load-darf-es-denn-sein.html</guid>
      <description>&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/load-beispiel.png&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;

&lt;/p&gt;
&lt;p&gt;In
&lt;a href=&#34;http://webhostingtech.de/2106/677.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Wann ist die Serverload zu hoch?&lt;/a&gt;


fragt Reimer:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Die Frage, ob ein Serverload von n zu hoch sei, höre ich häufig.
Die Antworten sind jedoch ebenso unterschiedlich.
So wird häufig die Zahl 1,00 als normaler Wert gehandelt, aber genau so fallen Zahlen wie 5,00 und 8,00 etc.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;In Linux und Unix gibt es einige Zahlen, mit denen man die CPU-Auslastung des Systems ausdrücken kann.
Da ist erst einmal die momentane CPU-Auslastung in Prozent, wie sie von &lt;code&gt;top&lt;/code&gt; und anderen Tools angezeigt wird:&lt;/p&gt;
&lt;p&gt;Diese Zahl gibt detailliert Auskunft darüber, wie die CPU &lt;em&gt;in diesem Moment&lt;/em&gt; ihre Zeit verbringt:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;top - 10:49:36 up 11:53,  4 users,  load average: 2.71, 2.33, 2.20
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;Tasks: 109 total,   3 running, 106 sleeping,   0 stopped,   0 zombie
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;Cpu(s): 31.4% us,  8.9% sy,  0.0% ni, 47.5% id,  0.0% wa, 10.2% hi,  2.0% si
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Die Zahl &lt;code&gt;id&lt;/code&gt; ist die Idle-Zeit, die ungenutzte Zeit der CPU.
Die anderen Zahlen sagen detailliert, wie die CPU ihre Zeit verbringt: &lt;code&gt;us&lt;/code&gt; (User-Time) ist Zeit, die im Programm verbracht wird, und &lt;code&gt;sy&lt;/code&gt; (System-Time) die Zeit, die vom Kernel im Auftrag dieses Programmes verbraucht wird.
&lt;code&gt;ni&lt;/code&gt; (Nice-Time) ist Zeit, die von herunter priorisierten Prozessen sinnvoll verbraucht wird.
Alle drei Zeiten zusammen sind sinnvoll genutzte Arbeitszeit.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;wa&lt;/code&gt; (Wait-Time) ist I/O-Wait, also Zeit, die der Rechner auf das Eintreffen von Daten von der Platte oder dem Netzwerk wartet.
&lt;code&gt;hi&lt;/code&gt; und &lt;code&gt;si&lt;/code&gt; (Hard- und Soft Interrupt) sind Zeiten, die das System mit der Bearbeitung von Interrupts zubringt, also in Gerätetreibern und Timer-Routinen.&lt;/p&gt;
&lt;p&gt;Die Loadzahlen geben die mittlere Länge der Run-Queue über eine Minute (erste Zahl), fünf Minuten (zweite Zahl) und 15 Minuten (dritte Zahl) an.
Die Zahl sagt, wie viele Prozessoren das System im Schnitt auslasten könnte.
Wenn also die Load 1 ist, ist ein Einprozessorsystem so in etwa ausgelastet, eine Enterprise 10000 mit 64 CPUs in einer Domain ist bei einer Load von 64 gut ausgelastet.&lt;/p&gt;
&lt;p&gt;Die Load auf meinem System ist derzeit so:&lt;/p&gt;
&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/load-beispiel.png&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;

&lt;/p&gt;
&lt;p&gt;Für Auslastungsabschätzungen ist die blaue Fläche aussagekräftig, denn sie stellt die 15 Minuten-Load dar.
Diese Zahl ist relativ unempfindlich gegen lokale Lastspitzen und daher ein besseres Maß für die Auslastung (im Gegensatz zur Elastizität) des Systems.
Meine Maschine läuft derzeit tagsüber mit einer Load von ca. 0.8, ist also mit einem Prozessor zu etwa 80 % voll.
Zu einzelnen Zeitpunkten (nachts um 4:15 Uhr, wenn das News-Expire läuft), wird die Ideal-Last von 1 deutlich überschritten.
Das ist zu diesem Zeitpunkt aber nicht schlimm.&lt;/p&gt;
&lt;p&gt;Die Spitzenlasten (rote Kurve: 1 Minuten-Load, und davon das Maximum) halten sich außer um 4:15 Uhr im Rahmen, die Maschine kommt nicht nennenswert über Load 2 hinaus.
Die Kiste hat also nicht mehr allzu viel Reserven, ist aber auch noch nicht überlastet.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Neu auf einem fremden System</title>
      <link>https://blog.koehntopp.info/2000/04/14/neu-auf-einem-fremden-system.html</link>
      <pubDate>Fri, 14 Apr 2000 09:00:00 +0000</pubDate>
      
      <guid>https://blog.koehntopp.info/2000/04/14/neu-auf-einem-fremden-system.html</guid>
      <description>&lt;p&gt;Dies ist eine aktualisierte Version der Schulung „Unix Systemsicherheit“, die ich vor einiger Zeit schon einmal gehalten habe.
Der Schwerpunkt dieser Schulung hat sich etwas zu den Grundlagen hin verschoben:
Es geht diesmal weniger um Unix Systemsicherheit als um die typische Situation der Consultants und Bereitschaften:&lt;/p&gt;
&lt;p&gt;Man kommt an eine neue Maschine und muss sich erst einmal zurechtfinden.&lt;/p&gt;
&lt;h1 id=&#34;neu-auf-einem-fremden-system&#34;&gt;
    &lt;a href=&#34;#neu-auf-einem-fremden-system&#34;&gt;
	Neu auf einem fremden System
    &lt;/a&gt;
&lt;/h1&gt;
&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/2000/04/neu-system-001.jpg&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;

&lt;/p&gt;
&lt;p&gt;Orientierung:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Typ und Ausstattung der Maschine
&lt;ul&gt;
&lt;li&gt;Prozessor, Festplatten, andere Hardware&lt;/li&gt;
&lt;li&gt;Speichersituation, historische und aktuelle Lastdaten&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Netzwerk und Netzwerkumfeld der Maschine&lt;/li&gt;
&lt;li&gt;IP-Adressen, Routing
&lt;ul&gt;
&lt;li&gt;Welche Name-Services in welcher Reihenfolge, welche Server werden verwendet?&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Was läuft, was soll laufen?
&lt;ul&gt;
&lt;li&gt;Was ist installiert?&lt;/li&gt;
&lt;li&gt;tatsächlich laufende Subsysteme vs. konfigurierte Subsysteme&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Wir sind neu auf einem fremden System und loggen uns zum ersten Mal ein.
Wie können wir uns zurechtfinden? Was wollen wir überhaupt wissen?&lt;/p&gt;
&lt;p&gt;Die Maschine selbst ist nach Hardware, Speicher, Platten und Netzwerk zu beurteilen.
Die Netzwerkumgebung der Maschine ist einzuschätzen.
Die auf der Maschine installierten Systemdienste sind einzuschätzen und zu beurteilen.
Es muss ein Soll/Ist-Abgleich stattfinden.&lt;/p&gt;
&lt;p&gt;Ausgehend von diesen Daten kann die Arbeit auf der Maschine beginnen:&lt;/p&gt;
&lt;p&gt;Die Maschine kann für ihre Aufgabe angepasst werden (Hardware- oder Softwareinstallation durch Consulting), bzw. die Fehlersuche kann beginnen (Alarmruf für die Bereitschaft).&lt;/p&gt;
&lt;h1 id=&#34;typ-und-ausstattung-der-maschine&#34;&gt;
    &lt;a href=&#34;#typ-und-ausstattung-der-maschine&#34;&gt;
	Typ und Ausstattung der Maschine
    &lt;/a&gt;
&lt;/h1&gt;
&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/2000/04/neu-system-002.jpg&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;

&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Was für Hardware ist das hier?&lt;/li&gt;
&lt;li&gt;Was ist in der Maschine eingebaut?&lt;/li&gt;
&lt;li&gt;Wie lange ist die Hardware schon &amp;ldquo;up&amp;rdquo;?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Erster Handgriff: &lt;code&gt;uname -a&lt;/code&gt;.
Weitere Aktionen systemspezfisch.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Linux: &lt;code&gt;lscpu&lt;/code&gt;, &lt;code&gt;free&lt;/code&gt;, &lt;code&gt;df -Th&lt;/code&gt;, &lt;code&gt;lspci&lt;/code&gt;, &lt;code&gt;lsusb&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Solaris: &lt;code&gt;prtconf -v&lt;/code&gt;, &lt;code&gt;psrinfo -v&lt;/code&gt;, &lt;code&gt;/usr/platform/$(uname -m)/sbin/prtdiag&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Uptime und Load: &lt;code&gt;w&lt;/code&gt;, &lt;code&gt;uptime -w&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Für uns meist: Sparc/Solaris oder Intel/Linux.
Bei einigen Kunden auch PPC/AIX oder Intel/SCO.
Äußerst wenige Kunden mit HP oder Digital Hardware.&lt;/p&gt;
&lt;p&gt;Peilung des Maschinentyps (mit &lt;code&gt;uname -a&lt;/code&gt;) und der eingebauten Hardware.
In Solaris mit den drei Kommandos &lt;code&gt;prtconf&lt;/code&gt;, &lt;code&gt;psrinfo&lt;/code&gt; und &lt;code&gt;prtdiag&lt;/code&gt;.
In Linux mit &lt;code&gt;lscpu&lt;/code&gt;, &lt;code&gt;lspci&lt;/code&gt; oder indem man manuell durch &lt;code&gt;/proc&lt;/code&gt; turnt.&lt;/p&gt;
&lt;p&gt;Peilung der Systemauslastung und der anwesenden Benutzer:
Neben &lt;code&gt;w&lt;/code&gt; und &lt;code&gt;uptime&lt;/code&gt; einmal die Prozeßliste ansehen (&lt;code&gt;ps -ef&lt;/code&gt;, &lt;code&gt;ps axuwww&lt;/code&gt;) und die Systemlast checken (&lt;code&gt;iostat&lt;/code&gt;, &lt;code&gt;vmstat&lt;/code&gt;).&lt;/p&gt;
&lt;h1 id=&#34;speicher-und-last&#34;&gt;
    &lt;a href=&#34;#speicher-und-last&#34;&gt;
	Speicher und Last
    &lt;/a&gt;
&lt;/h1&gt;
&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/2000/04/neu-system-003.jpg&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;

&lt;/p&gt;
&lt;p&gt;Virtueller Speicher und seine Auslastung:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Linux: &lt;code&gt;free&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Solaris: &lt;code&gt;swap -l&lt;/code&gt;, &lt;code&gt;swap -s&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Wenn Accounting &amp;ldquo;up&amp;rdquo; ist (Solaris): &lt;code&gt;sar&lt;/code&gt;, &lt;code&gt;sar -r&lt;/code&gt; (freeswap), &lt;code&gt;sar -w&lt;/code&gt; (paging).&lt;/li&gt;
&lt;li&gt;In Linux (Suse 6.4): &lt;code&gt;sa&lt;/code&gt; aus dem Paket &lt;code&gt;ap1/acct.rpm&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Der weitaus größte Teil aller Lastprobleme sind Speicherprobleme (zuwenig RAM, zu kleiner Swap).
Zweithäufigstes Problem ist fehlende I/O-Kapazität.
Fehlende CPU-Kapazität ist fast niemals das Problem.&lt;/p&gt;
&lt;p&gt;Erst messen, dann nachdenken, dann handeln (OODA loop &amp;ndash; Observe, Orient, Decide, Act).
Optimierungen ohne genaue Messungen und Kenntnis des tatsächlichen Problems sind Verschwendung der durch den Kunden bezahlten Arbeitszeit.
Punktmessungen können hilfreich sein, aber ein Wochenlastprofil ist sehr viel wertvoller (hier &lt;code&gt;sar&lt;/code&gt;-Beispiele von &lt;code&gt;boss&lt;/code&gt; und &lt;code&gt;prime&lt;/code&gt; bringen).&lt;/p&gt;
&lt;h1 id=&#34;platten&#34;&gt;
    &lt;a href=&#34;#platten&#34;&gt;
	Platten
    &lt;/a&gt;
&lt;/h1&gt;
&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/2000/04/neu-system-004.jpg&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;

&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Logical Volume Management?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Welches System?&lt;/li&gt;
&lt;li&gt;Welche Zuordnung?&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Quota?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;/etc/vfstab&lt;/code&gt;, &lt;code&gt;/etc/fstab&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Solaris (SDS):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Gerätenamen&lt;/li&gt;
&lt;li&gt;metastat&lt;/li&gt;
&lt;li&gt;format&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Linux:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Gerätenamen&lt;/li&gt;
&lt;li&gt;fdisk&lt;/li&gt;
&lt;li&gt;&lt;code&gt;raidtool.rpm&lt;/code&gt; als Nachfolger von &lt;code&gt;md-tools&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/etc/raidtab&lt;/code&gt;, &lt;code&gt;raid.conf&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;df&lt;/code&gt;, &lt;code&gt;du&lt;/code&gt;, &lt;code&gt;mount&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Quota-Tools&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Vergleiche die sichtbaren Partitionen mit der durch das Hardware-Inventory angezeigten vorhandenen Hardware.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Sind alle Platten partitioniert und eingebunden?&lt;/li&gt;
&lt;li&gt;Ist die gezeigte Aufteilung sinnvoll gewählt für die Aufgabe der Maschine?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Prüfe auch:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Verteilung der Partitionen nach Auslastung auf Spindeln&lt;/li&gt;
&lt;li&gt;Verteilung der Partitionen über Platten und Controller nach Ausfallgesichtspunkten?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Welche RAID-Level für welche Aufgabe&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Wir verwenden fast überall RAID 0+1 (Solaris SDS).&lt;/li&gt;
&lt;li&gt;Linux-RAID (a la Suse) derzeit nur eingeschränkt nützlich.
&lt;ul&gt;
&lt;li&gt;Lange Startzeit.&lt;/li&gt;
&lt;li&gt;Rootplatte, Swap-Partition.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Prüfe auch:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Platzproblem oder Quota-Problem?&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;netzwerk-und-netzwerknachbarschaft&#34;&gt;
    &lt;a href=&#34;#netzwerk-und-netzwerknachbarschaft&#34;&gt;
	Netzwerk und Netzwerknachbarschaft
    &lt;/a&gt;
&lt;/h1&gt;
&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/2000/04/neu-system-005.jpg&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;

&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Übersicht über Interfaces und Routen&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-n&lt;/code&gt; Option verwenden&lt;/li&gt;
&lt;li&gt;Woher kommen die Routen?&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Weitere Analysetools:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ping&lt;/li&gt;
&lt;li&gt;tcpdump&lt;/li&gt;
&lt;li&gt;snoop&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Netzwerkinterfaces: &lt;code&gt;ifconfig -a&lt;/code&gt;, &lt;code&gt;netstat -i&lt;/code&gt;, &lt;code&gt;netstat -s&lt;/code&gt;, &lt;code&gt;netstat -m&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Routen: &lt;code&gt;netstat -rn&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Schicht 2-3 Bindungen: &lt;code&gt;arp -a&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Welche Interfaces und welche Routen werden tatsächlich wie oft verwendet?
Woher kommen die Routen?&lt;/p&gt;
&lt;p&gt;Viele Kunden haben ein kaputtes Netzwerkonzept (d.h. keines) und setzen Routen eventuell manuell. Probleme sind vorprogrammiert.&lt;/p&gt;
&lt;p&gt;Andere Kunden haben nur Default-Routen und bekommen differenzierte Routen nur über ICMP Redirect. Ebenfalls problematisch (Effizenz, Security).&lt;/p&gt;
&lt;h1 id=&#34;name-resolution&#34;&gt;
    &lt;a href=&#34;#name-resolution&#34;&gt;
	Name Resolution
    &lt;/a&gt;
&lt;/h1&gt;
&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/2000/04/neu-system-006.jpg&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;

&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Welche Namensdienste werden verwendet?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Welche Server werden verwendet?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Wie ist das Verhalten im Fehlerfall?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Ausfall&lt;/li&gt;
&lt;li&gt;Angriff&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;/etc/nsswitch.conf&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Files, DNS/Bind, NIS/NIS+, LDAP, Exoten&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Falls DNS: &lt;code&gt;/etc/resolv.conf&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Falls NIS: &lt;code&gt;ypwhich&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Woher kommen die Namen, welcher Dienst wird verwendet?&lt;/p&gt;
&lt;p&gt;Oft lokale Hostdateien -&amp;gt; Probleme! Im besten Fall DNS. Dann dort die Zone ansehen und Netzstruktur und Zonengröße abschätzen.&lt;/p&gt;
&lt;p&gt;Welche Abhängigkeiten existieren zwischen den Servern?&lt;/p&gt;
&lt;p&gt;Ausfall- und Bootszenarien: Was ist, wenn der DNS-, der Time- oder der NIS-Server nicht da sind? Gibt es NFS-Platten, auf die die lokale Maschine angewiesen ist?&lt;/p&gt;
&lt;p&gt;Security: Wer macht was in wessen Auftrag? Wer kontrolliert? Wird die Konfiguration manuell gepflegt oder existieren Frontends? Welche Dokumentationsprozeduren existieren?&lt;/p&gt;
&lt;h1 id=&#34;netzwerkdienste&#34;&gt;
    &lt;a href=&#34;#netzwerkdienste&#34;&gt;
	Netzwerkdienste
    &lt;/a&gt;
&lt;/h1&gt;
&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/2000/04/neu-system-007.jpg&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;

&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Welche Netzwerkdienste werden erbracht?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Prüfe neben &lt;code&gt;inetd&lt;/code&gt; auch persistenten Server.&lt;/li&gt;
&lt;li&gt;Prüfe auf Vorhandensein von Sicherheitsmechanismen&lt;/li&gt;
&lt;li&gt;Prüfe Verhalten im Falle von Ausfällen, etwa Firewall-Versagen&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Wie begründen sich diese Dienste?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Welche Sicherheit bieten diese Dienste?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;/etc/inetd.conf&lt;/code&gt;, &lt;code&gt;/etc/hosts.allow&lt;/code&gt;, &lt;code&gt;/etc/hosts.deny&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Sonderfälle für das jeweilige System&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Todesfallen bei AIX: Import/Exporttools für &lt;code&gt;inetd.conf&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Todesfallen bei HP/UX: &lt;code&gt;/etc/inetd.sec&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;rpcinfo -p&lt;/code&gt;, &lt;code&gt;showmount -e&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;nmap&lt;/code&gt;!&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Vergleiche &lt;code&gt;inetd.conf&lt;/code&gt; und Startscripte mit &lt;code&gt;netstat -an&lt;/code&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Consulting: Viele verstorbene Pflegefälle wegen manuell gestarteter Dienste, die in keiner Konfigurationsdatei auftauchen.&lt;/li&gt;
&lt;li&gt;Bereitschaft: Umgekehrtes Szenario. Alarm wurde wegen verschwundenem Server ausgelöst.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Sicherheitsanalyse wieder:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Wieder technische und organisatorische Prozesse synchronisieren und abgleichen:
&lt;ul&gt;
&lt;li&gt;Was tun die Maschinen?&lt;/li&gt;
&lt;li&gt;Wer entscheidet das? Wie begründen sich die Dienste?&lt;/li&gt;
&lt;li&gt;Wer dokumentiert und prüft das?&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Vergleiche Prozeduren bei uns im Haus:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ISP-Betrieb plant und deployed.&lt;/li&gt;
&lt;li&gt;Operating betreibt nach Doku vom ISP-Betrieb, Operating überwacht und alarmiert die Bereitschaft. Auch diese operiert mit dieser Doku.&lt;/li&gt;
&lt;li&gt;Konfigurationsgenerierung meist automatisch durch die Backends der KundenDB -&amp;gt; automatische Dokumentation und Abrechnung.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;welche-verzeichnisse-werden-exportiert&#34;&gt;
    &lt;a href=&#34;#welche-verzeichnisse-werden-exportiert&#34;&gt;
	Welche Verzeichnisse werden exportiert?
    &lt;/a&gt;
&lt;/h1&gt;
&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/2000/04/neu-system-008.jpg&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;

&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Häufige Panne:
&lt;ul&gt;
&lt;li&gt;Verzeichnisse werden ungewollt exportiert&lt;/li&gt;
&lt;li&gt;Rechner importiert Verzeichnisse und hängt wegen Abhängigkeit vom Server&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Automounter?
&lt;ul&gt;
&lt;li&gt;Mit NIS/NIS+?&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Samba?
&lt;ul&gt;
&lt;li&gt;Klartextpaßworte?&lt;/li&gt;
&lt;li&gt;Public Shares?&lt;/li&gt;
&lt;li&gt;Logfiles?&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;gp&#34;&gt;$&lt;/span&gt; showmount -e
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;gp&#34;&gt;$&lt;/span&gt; kshowmount -e
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;gp&#34;&gt;$&lt;/span&gt; share
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;gp&#34;&gt;$&lt;/span&gt; vi /etc/exports&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; vi  /etc/dfs/dfstab
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;gp&#34;&gt;$&lt;/span&gt; vi /etc/auto.master&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; vi /etc/auto.homel vi /etc/auto.misc
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;gp&#34;&gt;$&lt;/span&gt; vi smb.conf&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; smbclient
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Einschlägige Beispielserver draußen zeigen.&lt;/p&gt;
&lt;p&gt;Wir wollen nicht so enden wie die! Mehrfach gestaffelte Sicherheit durch&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;automatisch generierte Konfigurationen mit Sicherheitssperren&lt;/li&gt;
&lt;li&gt;Dienstsperrungen für Außen durch &lt;code&gt;tcpwrapper&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Portsperrung und Alamierung über die Firewall und das Operating&lt;/li&gt;
&lt;li&gt;Logauswertung (Usagelog, Wrapper-Protokoll, Firewall-Protokoll) durch
&lt;ul&gt;
&lt;li&gt;Abrechnung (KundenDB), Alarm bei Diensten mit fehlendem technischem Objekt in der KundenDB&lt;/li&gt;
&lt;li&gt;Operating (Wrapper, Firewall), Alarm bei Attack Patterns&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Einschlägige Selbstmordkonfigurationen zeigen.&lt;/p&gt;
&lt;h1 id=&#34;was-ist-installiert&#34;&gt;
    &lt;a href=&#34;#was-ist-installiert&#34;&gt;
	Was ist installiert?
    &lt;/a&gt;
&lt;/h1&gt;
&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/2000/04/neu-system-009.jpg&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;

&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Welche Pakete und Programme sind installiert?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;In welcher Version?&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Installation validieren?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&amp;ldquo;set permissions&amp;rdquo; und &amp;ldquo;check optionen&amp;rdquo;&lt;/li&gt;
&lt;li&gt;tripwire?&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Solaris: &lt;code&gt;pkginfo&lt;/code&gt;, &lt;code&gt;/var/sadm/install/contents&lt;/code&gt; (Reihenfolge!)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Linux: &lt;code&gt;rpm -qa&lt;/code&gt;, &lt;code&gt;rpm -qi &amp;lt;paket&amp;gt;&lt;/code&gt;, &lt;code&gt;rpm -ql &amp;lt;paket&amp;gt;&lt;/code&gt;, &lt;code&gt;rpm -qlc &amp;lt;paket&amp;gt;&lt;/code&gt;, &lt;code&gt;rpm -qld &amp;lt;paket&amp;gt;&lt;/code&gt;, &lt;code&gt;rpm -qf &amp;lt;datei&amp;gt;&lt;/code&gt;, &lt;code&gt;rpm -qp &amp;lt;datei.rpm&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Solaris Paketarchiv („NetUSE Distribution“) zeigen&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Consulting-CDROM, wird auch an Kunden verkauft&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Keine Installation ohne Paket&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Verweis auf Paketschulung&lt;/li&gt;
&lt;li&gt;Kein Paket -&amp;gt; automatische Konfigurationsgenerierung aus Installserver oder KundenDB macht die Verzeichnisse möglicherweise platt.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Kommandoäquivalenzen Linux/Solaris&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Verweis auf Rootkits&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Rootkits ersetzen wichtige Systemprogramme,&lt;/li&gt;
&lt;li&gt;in Folge belügt die Maschine den Operator&lt;/li&gt;
&lt;li&gt;tripwire-Check nach sauberem Reboot zeigen&lt;/li&gt;
&lt;li&gt;lrk3 demonstrieren (ohne sauberen Reboot bekommt man keine verlässlichen Informationen mehr und kompromittiert sein Netz nur noch weiter)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;was-soll-laufen&#34;&gt;
    &lt;a href=&#34;#was-soll-laufen&#34;&gt;
	Was soll laufen?
    &lt;/a&gt;
&lt;/h1&gt;
&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/2000/04/neu-system-010.jpg&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;

&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Welche Dienste sollen von der Maschine erbracht werden?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Konfiguration beim Systemstart für persistente Server&lt;/li&gt;
&lt;li&gt;Konfiguration von transienten Servern&lt;/li&gt;
&lt;li&gt;Konfiguration von zeitgesteuerten Services
&lt;ul&gt;
&lt;li&gt;Suche nach Zeitbomben?&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Wenn es hängt?&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Start/Stopscripte&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Linux: &lt;code&gt;/sbin/init.d/...&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Solaris: &lt;code&gt;/etc/init.d/...&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Crondateien: &lt;code&gt;/var/spool/cron/crontabs&lt;/code&gt;, &lt;code&gt;/var/cron/tabs&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;strace&lt;/code&gt;, &lt;code&gt;truss&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ltrace&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Bootsequenz durchgehen, Single User Mode, Wie bekomme ich meine Platten wieder?, Wie überlebe ich ohne Editor und Terminalemulation?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Defekte Programme tracen: &lt;code&gt;ldd&lt;/code&gt;, Solaris &lt;code&gt;proctools&lt;/code&gt;, Linux: &lt;code&gt;/proc/&amp;lt;nummer&amp;gt;/...&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;strace&lt;/code&gt;/&lt;code&gt;truss&lt;/code&gt; Output lesen, &lt;code&gt;ltrace&lt;/code&gt;/&lt;code&gt;sotruss&lt;/code&gt; Output lesen&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;was-läuft&#34;&gt;
    &lt;a href=&#34;#was-l%c3%a4uft&#34;&gt;
	Was Läuft?
    &lt;/a&gt;
&lt;/h1&gt;
&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/2000/04/neu-system-011.jpg&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;

&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Welche Dienste sind auf der Maschine aktiv?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Welche waren aktiv?&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Welche Ressourcen belegen diese Dienste?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ps -ef&lt;/code&gt;, &lt;code&gt;ps auxwww&lt;/code&gt;, &lt;code&gt;top&lt;/code&gt;, &lt;code&gt;lsof&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Linux: &lt;code&gt;ptree&lt;/code&gt;, &lt;code&gt;sa&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Solaris: &lt;code&gt;/usr/proc/bin/*&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Beispiele mit den Proctools&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Speicherverbrauch abschätzen für Server&lt;/li&gt;
&lt;li&gt;Programmaktivität laufender Prozesse feststellen&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;welche-user-können-rein&#34;&gt;
    &lt;a href=&#34;#welche-user-k%c3%b6nnen-rein&#34;&gt;
	Welche User können rein?
    &lt;/a&gt;
&lt;/h1&gt;
&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/2000/04/neu-system-012.jpg&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;

&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Quellen von Userlisten&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;lokal, aus dem Netz&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Erlaubte und nicht erlaubte Shells&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Gehackte Authentisierung&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Modifizierte wu-ftpd, imapd&lt;/li&gt;
&lt;li&gt;LDAP-Module&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;/etc/nsswitch.conf&lt;/code&gt;, &lt;code&gt;/etc/shells&lt;/code&gt;, &lt;code&gt;/etc/ftpusers&lt;/code&gt;, &lt;code&gt;/etc/ftpaccess&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Zugangsmechanismen&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Regeln für den Zugang, etwa über PAM: &lt;code&gt;/etc/pam.d&lt;/code&gt;, &lt;code&gt;/etc/pam.conf&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Verweis auf Folgeschulungen:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;NSS/PAM/GSS nutzen.&lt;/li&gt;
&lt;li&gt;NSS/PAM/GSS-Module erstellen.&lt;/li&gt;
&lt;li&gt;Überblick über die von NetUSE für den ISP-Betrieb modifizierte Software.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;welche-user-waren-drin&#34;&gt;
    &lt;a href=&#34;#welche-user-waren-drin&#34;&gt;
	Welche User waren drin?
    &lt;/a&gt;
&lt;/h1&gt;
&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/2000/04/neu-system-013.jpg&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;

&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Auswertung des Logbuches&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Querabgleiche mit anderen Logs&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Auditing-Subsysteme&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;/etc/utmp&lt;/code&gt;, &lt;code&gt;/etc/wtmp&lt;/code&gt;, syslog, Auth-Events, Radius-Logs und andere&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Exoten:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Logbücher der Sysadmin-Tools (AIX)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Auditing-Subsysteme&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Linux: fehlendes Auditing, bescheidenes Accounting (falls installiert).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Solaris: Demo des Auditing&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Beide: Welche Logs liegen wo und wie finde ich die gewünschte Info?&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;zugriffsrechte-und-privilegien-in-unix&#34;&gt;
    &lt;a href=&#34;#zugriffsrechte-und-privilegien-in-unix&#34;&gt;
	Zugriffsrechte und Privilegien in UNIX
    &lt;/a&gt;
&lt;/h1&gt;
&lt;p&gt;Bonusfolien aus der alten Schulung&lt;/p&gt;
&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/2000/04/neu-system-014.jpg&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;

&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Erkläre, wer unter welchen Bedingungen in UNIX auf eine Datei zugreifen darf!&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;rwx? sst?&lt;/li&gt;
&lt;li&gt;Verzeichnisrechte vs. Dateirechte&lt;/li&gt;
&lt;li&gt;Dateiattribute? Dateisystemattribute?&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Welche Spuren hinterläßt so ein Zugriff?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.koehntopp.info/1996/03/01/rwx-sonst-nix.html&#34;&gt;RWX - sonst nix?&lt;/a&gt;

&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Wer bin ich?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Zu welchen Gruppen gehöre ich?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Wie kann ich meine Identität ändern?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Welche Rechte (alle!) brauche ich, um auf eine Datei zuzugreifen? Sind es immer dieselben?&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;kurzer-sicherheitscheck-für-zwischendurch&#34;&gt;
    &lt;a href=&#34;#kurzer-sicherheitscheck-f%c3%bcr-zwischendurch&#34;&gt;
	Kurzer Sicherheitscheck für Zwischendurch
    &lt;/a&gt;
&lt;/h1&gt;
&lt;p&gt;Bonusfolien aus der alten Schulung&lt;/p&gt;
&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/2000/04/neu-system-015.jpg&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;

&lt;/p&gt;
&lt;p&gt;Die meisten Fehler entstehen nicht durch falsche Software, sondern dumme User.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;find / -fstype ... ! -type l -perm ... -ls&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;-perm -2 (find world writeable files)&lt;/li&gt;
&lt;li&gt;-perm -4000 (find SUID)&lt;/li&gt;
&lt;li&gt;-perm -2000 (find SGID)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Finde Dateien, die world writeable, suid oder sgid sind.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;/tmp&lt;/code&gt;, &lt;code&gt;/var/tmp&lt;/code&gt; (1777 ?)&lt;/li&gt;
&lt;li&gt;Verzeichnisse im Pfad, Binaries, Konfigurationsdateien?&lt;/li&gt;
&lt;li&gt;Dateien mit vorhersagbaren Dateinamen?&lt;/li&gt;
&lt;li&gt;Geräte? Backup?&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;rechte-an-geräten&#34;&gt;
    &lt;a href=&#34;#rechte-an-ger%c3%a4ten&#34;&gt;
	Rechte an Geräten
    &lt;/a&gt;
&lt;/h1&gt;
&lt;p&gt;Bonusfolien aus der alten Schulung&lt;/p&gt;
&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/2000/04/neu-system-016.jpg&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;

&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Auf vielen älteren kommerziellen Unices sind Gerätedateien unzureichend geschützt.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Beschreibbare Plattendevices, Banddevices&lt;/li&gt;
&lt;li&gt;777-Verzeichnisse &lt;code&gt;/dev/md/*&lt;/code&gt;, Löschen von LVM-Pseudogerätedateien&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ioctl()&lt;/code&gt;-Aufrufe nicht ausreichend privilegiert.&lt;/li&gt;
&lt;li&gt;Medien mit sensitivem Inhalt in lesbaren Geräten.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Beispiele:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ioctl()-Aufrufe in AIX teilweise nicht dokumentiert und nicht privilegiert.&lt;/li&gt;
&lt;li&gt;/dev-Unterverzeichnisse 777 in HP/UX.&lt;/li&gt;
&lt;li&gt;/bin-Verzeichnisse 777 in HP/UX und AIX nach Installation von Software.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>rwx - sonst nix?</title>
      <link>https://blog.koehntopp.info/1996/03/01/rwx-sonst-nix.html</link>
      <pubDate>Fri, 01 Mar 1996 09:00:00 +0000</pubDate>
      
      <guid>https://blog.koehntopp.info/1996/03/01/rwx-sonst-nix.html</guid>
      <description>&lt;p&gt;&lt;strong&gt;aus &amp;ldquo;Linux Magazin&amp;rdquo;, Ausgabe 3/96.&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&#34;rwx---sonst-nix&#34;&gt;
    &lt;a href=&#34;#rwx---sonst-nix&#34;&gt;
	rwx - sonst nix?
    &lt;/a&gt;
&lt;/h1&gt;
&lt;p&gt;In jedem Buch über UNIX wird das UNIX-Rechtesystem ungefähr in Kapitel 2 vollständig erläutert und es bleiben keine Frage mehr offen.
Wieso also ein Artikel über Zugriffsrechte?
Nun, dieser Artikel erklärt Zugriffsrechte für Leute, die es ganz genau wissen wollen:
Welche Rechte werden für den Zugriff auf eine Datei benötigt?
Wer prüft die Rechte und wie passiert das?&lt;/p&gt;
&lt;p&gt;Wie oft hört man Redewendungen wie &amp;ldquo;Ich öffne jetzt einmal diese Datei&amp;hellip;&amp;rdquo; oder &amp;ldquo;Ich habe keine Zugriffsrechte, um auf dieses Verzeichnis zuzugreifen.&amp;rdquo;
Solche Formulierungen sind zwar üblich und auch jedermann verständlich, weil sie so schön bildhaft sind.
Aber wenn man über Zugriffsrechte reden möchte, sind sie eher schädlich als hilfreich.&lt;/p&gt;
&lt;p&gt;Natürlich öffnet ein User niemals eine Datei oder greift auf ein Verzeichnis zu.
Prozesse tätigen Systemaufrufe und der Kernel öffnet Dateien oder liest Verzeichnisse im Auftrag und mit den Rechten dieses Prozesses.
Solche Unterscheidungen sind auf den ersten Blick Haarspaltereien.
Aber wenn man sich den Spaß macht und die Sache einmal zu Ende verfolgt, wird man feststellen, daß sich auf diese Weise einige Dinge besser verstehen und leichter erklären lassen.
Der Autor will sich also in  diesem Artikel einer besonders genauen Sprache befleißigen.&lt;/p&gt;
&lt;h2 id=&#34;woher-kommen-zugriffsrechte&#34;&gt;
    &lt;a href=&#34;#woher-kommen-zugriffsrechte&#34;&gt;
	Woher kommen Zugriffsrechte?
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Zugriffsrechte und Eigentümer sind etwas, das einem zunächst an Dateien ins Auge fällt.
Eine Datei besteht in Linux aus einem Haufen Blöcken auf der Festplatte und einer Verwaltungsstruktur, der I-Node.
Während die Blöcke die eigentliche Information in der Datei speichern, findet man in der I-Node fast alle Information &lt;em&gt;über&lt;/em&gt; die Datei - also Metainformation.
Was die Rechte betrifft, findet man in der I-Node eine User-ID (UID), eine Group-ID (GID) und zwölf Rechtebits:
Drei Bits mit den Bezeichnungen &lt;code&gt;sst&lt;/code&gt; und dann jeweils drei Dreiergruppen &lt;code&gt;rwx&lt;/code&gt;.
&lt;code&gt;sst&lt;/code&gt; sind gewissermaßen Allzweckbits, die je nach Typ der Datei und Systemaufruf unterschiedliche Bedeutung haben können.
Die Auswertung der übrigen neun Bits erfolgt dagegen relativ zentral in einer Funktion &lt;code&gt;permission()&lt;/code&gt;, auf die wir weiter unten eingehen werden.&lt;/p&gt;
&lt;p&gt;Was dem UNIX-Neuling noch auffallen wird, ist die Tatsache, daß sich in der I-Node der Datei nicht der Username und der Gruppenname findet, sondern nur jeweils eine ID.
Diese ID-Nummern werden vom ls-Kommando in Namen umgewandelt, falls man es ihm nicht verbietet.
Man kann das ls-Kommando zwingen, die Angaben numerisch zu machen, indem man die Option &lt;code&gt;-n&lt;/code&gt; verwendet oder indem man dem Benutzer, der ls aufruft, den Lesezugriff auf /etc/passwd und /etc/group verweigert (&lt;a href=&#34;#experiment-1&#34;&gt;Experiment 1&lt;/a&gt;

).&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;experiment-1&#34;&gt;
    &lt;a href=&#34;#experiment-1&#34;&gt;
	Experiment 1
    &lt;/a&gt;
&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;root@white:~# ls -l /etc/passwd /etc/group
-rw-r--r--   1 root     root          281 Jul 15 14:39 /etc/group
-rw-r--r--   1 root     root         1163 Nov 28 15:30 /etc/passwd
root@white:~# chmod 000 /etc/passwd /etc/group
root@white:~# su - kris
kris@white:~$ ls -l /tmp
-rw-r--r--   1 0        0               5 Nov 23 13:36 lall
-rw-rw-rw-   1 60000    20             11 Nov 28 21:32 lpq.00002b98
drwxr-xr-x   2 0        0            1024 Nov 17 07:31 root
kris@white:~$ exit
root@white:~# chmod 644 /etc/passwd /etc/group
root@white:~# ls -l /tmp
-rw-r--r--   1 root     root            5 Nov 23 13:36 lall
-rw-rw-rw-   1 smbguest users          11 Nov 28 21:32 lpq.00002b98
drwxr-xr-x   2 root     root         1024 Nov 17 07:31 root
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Indem man kris die Leserechte auf die Dateien &lt;code&gt;/etc/passwd&lt;/code&gt; und &lt;code&gt;/etc/group&lt;/code&gt; entzieht, kann man demonstrieren, daß in einer I-Node nur numerische Information über Eigentümer und Gruppe einer Datei gespeichert wird.
ls kann diese Zahlen durch Zugriff auf die Paßwortdatenbank in Namen übersetzen.
Dazu existiert eine Familie von Bibliotheksfunktionen, die in &lt;code&gt;getpwent(3)&lt;/code&gt;, &lt;code&gt;getpwuid(3)&lt;/code&gt;, &lt;code&gt;getgrent(3)&lt;/code&gt; und &lt;code&gt;getgrgid(3)&lt;/code&gt; dokumentiert ist.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Zugriffe auf Dateien erfolgen durch den Kernel im Auftrag eines Prozesses.
Der Kernel entscheidet anhand der Rechtebits in der Inode der Datei einer Datei, ob er den Zugriff auf die Datei ausführen wird oder nicht.
Entscheidend für die Interpretation dieser Rechtebits ist noch, mit welcher UID und GID der Prozeß abläuft, der auf die Datei zugreifen möchte.
Wie man in &lt;code&gt;/usr/include/linux/sched.h&lt;/code&gt; nachlesen kann, hat ein &lt;code&gt;struct task_struct&lt;/code&gt; in Linux die Felder&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;	#define NGROUPS 32

	unsigned short uid,euid,suid,fsuid;
	unsigned short gid,egid,sgid,fsgid;
	int     groups[NGROUPS];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Linux unterscheidet sich hier von einem normalen UNIX:
Für Zugriffe auf Dateien sind die Felder &lt;code&gt;fsuid&lt;/code&gt;, &lt;code&gt;fsgid&lt;/code&gt; und &lt;code&gt;groups[]&lt;/code&gt; relevant, während ein normales UNIX &lt;code&gt;euid&lt;/code&gt; und &lt;code&gt;egid&lt;/code&gt; verwendet.
Natürlich unterscheidet sich Linux nicht so sehr von einem normalen UNIX, daß es inkompatibel wäre:
Normalerweise ist die &lt;code&gt;fsuid/fsgid&lt;/code&gt; mit der &lt;code&gt;euid/egid&lt;/code&gt; des Prozesses identisch.
Die Zugriffe auf Dateien erfolgen also mit der sogenannten effektiven User-ID und Group-ID eines Prozesses.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;#experiment-2&#34;&gt;Kasten 2&lt;/a&gt;

 zeigt, wie man feststellen kann, unter welchen IDs Zugriffe erfolgen.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;experiment-2&#34;&gt;
    &lt;a href=&#34;#experiment-2&#34;&gt;
	Experiment 2
    &lt;/a&gt;
&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;kris@white:~$ id
uid=100(kris) gid=20(users) groups=20(users),11(floppy)
kris@white:~$ su -
Password:
root@white:~# id
uid=0(root) gid=0(root) groups=0(root),1(bin),2(daemon),3(sys),4(adm),6(disk),10(wheel),11(floppy)
root@white:~# exit
kris@white:~$ id marit
uid=101(marit) gid=20(users) groups=11(floppy)
kris@white:~$ ls -l /tmp/bash
-rwsr-xr-x   1 root     root       295940 Nov 29 12:07 /tmp/bash
kris@white:~$ /tmp/bash
kris@white:~# id
uid=100(kris) gid=20(users) euid=0(root) groups=20(users),11(floppy)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Jemand, der als &lt;code&gt;kris&lt;/code&gt; eingeloggt ist, greift normalerweise mit der UID 100, der GID 20 und den Einträgen 20 und 11 im Feld &lt;code&gt;groups[]&lt;/code&gt; auf Dateien zu.
Ein Systemverwalter dagegen hat die UID und die GID 0 und noch weitere Einträge im Feld &lt;code&gt;groups[]&lt;/code&gt;.
Mit einem Usernamen als Parameter kann man auch die IDs anderer Benutzer abfragen.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Effektive&lt;/em&gt; und &lt;em&gt;reale&lt;/em&gt; UID und GID müssen nicht immer übereinstimmen:
Werden Programme mit gesetztem &lt;em&gt;Set User ID&lt;/em&gt;-Bit ausgeführt, kann sich die effektive UID eines Prozesses ändern - was &lt;em&gt;set user id&lt;/em&gt; genau ist und was das Bit bewirkt, werden wir später noch klären.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Wir halten fest:
Dateien haben genau einen Eigentümer und gehören zu genau einer Gruppe, während ein Prozeß einen Eigentümer hat, aber zu bis zu 32 Gruppen gehören kann.
Zugriffsrechte werden an Dateien in 12 Bit vermerkt.
Die Interpretation dieser 12 Bit hängt ab vom Typ der Datei und von der Identität des zugreifenden Prozesses.&lt;/p&gt;
&lt;h2 id=&#34;wo-werden-die-rechte-geprüft&#34;&gt;
    &lt;a href=&#34;#wo-werden-die-rechte-gepr%c3%bcft&#34;&gt;
	Wo werden die Rechte geprüft?
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Linux prüft Zugriffsrechte mit Hilfe der Funktion &lt;code&gt;permission()&lt;/code&gt;.
Sie ist in &lt;code&gt;/usr/src/linux/fs/namei.c&lt;/code&gt; in den Zeilen 91 bis 114 definiert.
Ein Parameter von &lt;code&gt;permission()&lt;/code&gt; ist ein Zeiger auf die I-Node der Datei, auf die zugegriffen wird.
Außerdem muß der Funktion noch gesagt werden, welche Art von Zugriff auf die Datei gewünscht wird.
&lt;code&gt;/usr/include/linux/fs.h&lt;/code&gt; definiert dazu in den Zeilen 35 bis 37 die Werte MAY_EXEC, MAY_WRITE und MAY_READ, die zu einer mask zusammengebaut werden können.
Der &lt;a href=&#34;#experiment-3&#34;&gt;Kasten&lt;/a&gt;

 zeigt den Quelltext von &lt;code&gt;permission()&lt;/code&gt; und die Definitionen aus &lt;code&gt;fs.h&lt;/code&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;experiment-3&#34;&gt;
    &lt;a href=&#34;#experiment-3&#34;&gt;
	Experiment 3
    &lt;/a&gt;
&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;/usr/src/linux/fs/namei.c:
    91  /*
    92   *      permission()
    93   *
    94   * is used to check for read/write/execute permissions on a file.
    95   * We use &amp;#34;fsuid&amp;#34; for this, letting us set arbitrary permissions
    96   * for filesystem access without changing the &amp;#34;normal&amp;#34; uids which
    97   * are used for other things..
    98   */
    99  int permission(struct inode * inode,int mask)
   100  {
   101          int mode = inode-&amp;gt;i_mode;
   102  
   103          if (inode-&amp;gt;i_op &amp;amp;&amp;amp; inode-&amp;gt;i_op-&amp;gt;permission)
   104                  return inode-&amp;gt;i_op-&amp;gt;permission(inode, mask);
   105          else if ((mask &amp;amp; S_IWOTH) &amp;amp;&amp;amp; IS_IMMUTABLE(inode))
   106                  return -EACCES; /* Nobody gets write access
                        to an immutable file */
   107          else if (current-&amp;gt;fsuid == inode-&amp;gt;i_uid)
   108                  mode &amp;gt;&amp;gt;= 6;
   109          else if (in_group_p(inode-&amp;gt;i_gid))
   110                  mode &amp;gt;&amp;gt;= 3;
   111          if (((mode &amp;amp; mask &amp;amp; 0007) == mask) || fsuser())
   112                  return 0;
   113          return -EACCES;
   114  }

/usr/include/linux/kernel.h:
    68  #define fsuser() (current-&amp;gt;fsuid == 0)

/usr/include/linux/fs.h:
    35  #define MAY_EXEC 1
    36  #define MAY_WRITE 2
    37  #define MAY_READ 4
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Die Funktion &lt;code&gt;permission()&lt;/code&gt; ist der zentrale Kontrollpunkt für Zugriffsrechte.
An ihr kann man sehen, nach welchem Verfahren Linux die Zugriffsrechte prüft.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Der Algorithmus, nach dem &lt;code&gt;permission()&lt;/code&gt; die Zugriffsrechte prüft, ist sehr einfach:
Zunächst einmal (Zeile 103-104) wird festgestellt, ob für die zu prüfende I-Node im Feld &lt;code&gt;i_op-&amp;gt;permission()&lt;/code&gt; der I-Node Struktur eine dateisystemspezifische &lt;code&gt;permission()&lt;/code&gt;-Routine definiert ist.
Auf diese Weise können Dateisysteme, die erweiterte oder von UNIX verschiedene Zugriffsrechte implementieren, ihre eigene Routine zum Testen des Zugriffs bereitstellen.
Derzeit (Kernel 1.2.13) tut dies nur das ext2-Dateisystem mit der Funktion &lt;code&gt;ext2_permission()&lt;/code&gt;, die in &lt;code&gt;/usr/src/linux/fs/ext2/acl.c&lt;/code&gt; definiert ist (und die in Kernel 1.2.13 nichts anderes tut als Zeilen 107-113 der normalen &lt;code&gt;permission()&lt;/code&gt;-Funktion, also noch vollkommen sinnlos ist).&lt;/p&gt;
&lt;p&gt;Die Zeilen 105-106 prüfen dann, ob die Datei als immutable file (unveränderliche Datei) gekennzeichnet ist.
Wenn dies der Fall ist und in mask MAY_WRITE gesetzt ist, wird der Zugriff auf die Datei verweigert und der Fehler permission denied (EACCES) zurückgegeben.
Der Code verwendet in Zeile 105 seltsamerweise die Definition S_IWOTH (das Schreibrecht für other aus der Includedatei &lt;code&gt;linux/stat.h&lt;/code&gt;) anstatt korrekterweise die Definition MAY_WRITE zu verwenden.
Da aber beide Definitionen den Wert 2 haben, kommt es nicht zu einem Fehler.
Da das ext2-Dateisystem eine eigene &lt;code&gt;permission()&lt;/code&gt;-Routine bereitstellt, die den Test auf immutable files nicht enthält, kann man dort unveränderliche Dateien beschreiben.
Das ist ein Fehler, denn an anderen Stellen kennt das ext2-Dateisystemen &lt;code&gt;IS_IMMUTABLE()&lt;/code&gt; und nimmt Rücksicht darauf.&lt;/p&gt;
&lt;p&gt;Der entscheidende Code befindet sich dann in den Zeilen 107-113:
&lt;code&gt;current&lt;/code&gt; bezeichnet den &lt;code&gt;struct task&lt;/code&gt; des aktuellen Prozesses, also desjenigen Prozesses, der soeben versucht hat, auf eine Datei zuzugreifen und dessen Zugriffsrechte jetzt geprüft werden müssen.
Falls die &lt;code&gt;fsuid&lt;/code&gt; dieses Prozesses mit der &lt;code&gt;i_uid&lt;/code&gt; der Datei übereinstimmen, werden die Zugriffsrechte des linken &lt;code&gt;rwx&lt;/code&gt;-Tripels der Datei für die Rechteprüfung verwendet (Zeilen 107 und 108).
Andernfalls prüft Linux mit der Funktion &lt;code&gt;in_group_p()&lt;/code&gt;, ob irgendeine GID des aktuellen Prozesses mit der &lt;code&gt;i_gid&lt;/code&gt; der Datei übereinstimmt.
Ist dies der Fall, werden die Zugriffsrechte des mittleren &lt;code&gt;rwx&lt;/code&gt;-Tripels verwendet (Zeilen 109-110).
Ist weder eine Übereinstimmung der User- noch der Group-IDs zu finden, werden die Defaultzugriffsrechte aus dem rechten Tripel verwendet.&lt;/p&gt;
&lt;p&gt;Die Funktion &lt;code&gt;in_group_p()&lt;/code&gt; ist in &lt;code&gt;/usr/src/linux/kernel/sys.c&lt;/code&gt; in den Zeilen 585-599 definiert.
Sie testet, ob ihr Argument gleich der &lt;code&gt;fsgid&lt;/code&gt; des aktuellen Prozesses ist oder ob das Argument gleich einer der Gruppen aus dem &lt;code&gt;groups[]&lt;/code&gt;-Array des Prozesses ist.
Der Name der Funktion erklärt sich aus der &amp;ldquo;p-convention&amp;rdquo; (siehe Jargon-File, ursprünglich eine Sitte aus dem Bereich der LISP-Programmierung):
Es handelt sich um ein Prädikat, also eine Funktion, die entweder &lt;code&gt;true&lt;/code&gt; oder &lt;code&gt;false&lt;/code&gt; liefert, je nachdem ob die zu prüfende Aussage wahr oder falsch ist.&lt;/p&gt;
&lt;p&gt;Die Bedingung in Zeile 111 entscheidet jetzt, ob der Zugriff auf eine I-Node gewährt wird oder nicht.
Wenn mindestens die in &lt;code&gt;mask&lt;/code&gt; gewünschten Rechtebits in den durch &lt;code&gt;mode&lt;/code&gt; schon in Zeile 101 vorab ermittelten Rechten enthalten sind oder der Zugriff mit Superuser-Privilegien erfolgt (&lt;code&gt;fsuser()&lt;/code&gt; ist wahr), wird der Zugriff auf die Datei gewährt.
In allen anderen Fällen wird ein Fehler permission denied (EACCES) geliefert.&lt;/p&gt;
&lt;p&gt;Wir halten fest:
Einzelne Dateisysteme können besondere Rechteroutinen haben.
Im Normalfall gelten aber die Userrechte für den Eigentümer einer Datei, die Gruppenrechte für jeden, der Mitglied in der Gruppe der Datei ist und die Other-Rechte für alle anderen.
Die Prüfung dieser Rechte erledigt Linux an einer zentralen, leicht wartbaren Stelle im System.&lt;/p&gt;
&lt;h2 id=&#34;pfade-und-rechte-entlang-des-pfades&#34;&gt;
    &lt;a href=&#34;#pfade-und-rechte-entlang-des-pfades&#34;&gt;
	Pfade, und Rechte entlang des Pfades
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Alle UNIX-Kernelfunktionen, die mit Dateien hantieren, nehmen Pfadnamen als Parameter an.
Intern verwendet Linux jedoch wie alle Unices ausschließlich I-Nodes, um mit Dateien zu arbeiten.
Die Umwandlung eines Pfadnamens in eine I-Node übernimmt in Linux eine von mehreren leicht unterschiedlichen &lt;code&gt;namei()&lt;/code&gt;-Funktionen, die in &lt;code&gt;/usr/src/linux/fs/namei.c&lt;/code&gt; definiert sind.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;namei()&lt;/code&gt; bekommt, vereinfacht dargestellt, einen Pfadnamen und die I-Node eines Verzeichnisses als Startpunkt übergeben.
In diesem Verzeichnis wird mittels der Funktion &lt;code&gt;lookup()&lt;/code&gt; die I-Node der ersten Komponente des Pfadnamens gesucht.
Diese I-Node wird jetzt als Startpunkt genommen, um die nächste Komponente des Pfadnames durch &lt;code&gt;lookup()&lt;/code&gt; suchen zu lassen und so weiter bis zum Ende des Pfades.
Am Ende des Pfades ist das Ergebnis dieser Operation genau die I-Node des Verzeichnisses, das durch den Pfadnamen bezeichnet wird.&lt;/p&gt;
&lt;p&gt;Der Code von &lt;code&gt;lookup()&lt;/code&gt; ist nicht ganz so einfach wie diese Erklärung, weil er so unschöne Dinge wie Mountpoints, &amp;ldquo;..&amp;quot;-Komponenten im Pfadnamen und ungültige Pfadnamen berücksichtigen muß, aber er ist auch nicht sonderlich kompliziert.
Für unsere Zwecke sind jedoch nur wenige Zeilen von &lt;code&gt;lookup()&lt;/code&gt; wesentlich:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;/usr/src/linux/fs/namei.c:
   163          perm = permission(dir,MAY_EXEC);

   181          if (perm != 0) {
   182                  iput(dir);
   183                  return perm;
   184          }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Um in einem Verzeichnis einen Namen nachschlagen zu können, muß der aufrufende Prozeß das &lt;code&gt;x&lt;/code&gt;-Recht an diesem Verzeichnis haben.
Hat er dieses &lt;code&gt;x&lt;/code&gt;-Recht nicht, schlägt der Aufruf fehl - ganz gleich, welche Kernelfunktion aufgerufen wurde.
Die Folgen können ziemlich fatal sein, wie &lt;a href=&#34;#experiment-4&#34;&gt;Experiment 4&lt;/a&gt;

 demonstriert.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;experiment-4&#34;&gt;
    &lt;a href=&#34;#experiment-4&#34;&gt;
	Experiment 4
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Warnung:&lt;/strong&gt;
Dieses Experiment darf nur durchgeführt werden, wenn in einem zweiten Fenster noch eine weitere Rootshell aktiv ist.
Andernfalls kann man sich so die Systeminstallation ruinieren.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;kris@white:~$ ls -ld /
drwxr-xr-x  20 root     root         1024 Nov 29 22:29 /
kris@white:~$ su - 
root@white:~# chmod go-x /
root@white:~# ls -ld /
drwxr--r--  20 root     root         1024 Nov 29 22:29 /
root@white:~# exit
kris@white:~$ ls 
csh: /bin/ls: Permission denied
kris@white:~$ su
csh: /bin/su: Permission denied
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In einem anderen Fenster mit einer aktiven Rootshell:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;root@white:~# chmod 755 / 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Das Hauptverzeichnis &lt;code&gt;/&lt;/code&gt; hat normalerweise die Rechte 755.
Jeder Benutzer hat also &lt;code&gt;x&lt;/code&gt;-Recht am Verzeichnis &lt;code&gt;/&lt;/code&gt; und kann damit absolute Pfadnamen auflösen.
Nimmt man dem Root-Verzeichnis die &lt;code&gt;x&lt;/code&gt;-Rechte, kann kein normaler Benutzer mehr absolute Pfadnamen auflösen und jeder Aufruf eines Systemkommandos schlägt fehl.
Insbesondere ist auch kein &lt;code&gt;su&lt;/code&gt; mehr möglich, um die Operation rückgängig zu machen.
Daher muß schon vor dem Beginn des Experimentes eine zweite, aktive Rootshell bereitstehen, um die Zugriffsrechte wieder zu reparieren.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Wir halten fest:
Jede richtige Antwort auf die Frage &amp;ldquo;Welche Rechte braucht man, um mit einer Datei  eine bestimmte Operation (Öffnen, Löschen, Umbenennen und so weiter) durchführen zu können?&amp;rdquo; muß mit den Worten &amp;ldquo;Man braucht die &lt;code&gt;x&lt;/code&gt;-Rechte an den Verzeichnissen entlang des Pfades und &amp;hellip;&amp;rdquo; beginnen.
Ohne diese &lt;code&gt;x&lt;/code&gt;-Rechte kann der Pfadname von Linux nicht aufgelöst werden und was immer sich an seinem Ende befindet, ist nicht zugreifbar.
Weil wirklich jede Antwort mit diesem Halbsatz beginnen muß, wird er oft weggelassen - vergessen darf man ihn trotzdem nicht!
Die einzelne Operation (&lt;code&gt;open(2)&lt;/code&gt;, &lt;code&gt;unlink(2)&lt;/code&gt;, &lt;code&gt;rename(2)&lt;/code&gt; und so weiter) kann dann noch zusätzlich weitere Zugriffsrechte verlangen.&lt;/p&gt;
&lt;h2 id=&#34;lese--und-schreibrechte-an-dateien&#34;&gt;
    &lt;a href=&#34;#lese--und-schreibrechte-an-dateien&#34;&gt;
	Lese- und Schreibrechte an Dateien
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Welche Zugriffsrechte werden nun wirklich benötigt, um eine Datei zu öffnen?
Auch dies können wir im Linux-Kernel nachlesen:
In &lt;code&gt;/usr/src/linux/fs/open.c&lt;/code&gt; befindet sich der Code des Systemaufrufes &lt;code&gt;open(2)&lt;/code&gt;.
Die Funktion &lt;code&gt;sys_open()&lt;/code&gt;, die diese Kernelfunktion realisiert, ist nur sehr kurz.
Sie tut kaum mehr, als &lt;code&gt;do_open()&lt;/code&gt; in derselben Datei mit den richtigen Parametern aufzurufen.
Der Code von &lt;code&gt;do_open()&lt;/code&gt; beschäftigt sich hauptsächlich mit der Verwaltung der Dateitabelle des Kernels und ist für die Klärung unserer Frage nicht interessant.&lt;/p&gt;
&lt;p&gt;Die eigentliche Arbeit des Öffnens der Datei überläßt er der Funktion &lt;code&gt;open_namei()&lt;/code&gt;, die wie bereits erklärt, den filename in eine I-Node umwandelt.
Der Aufruf findet sich in Zeile 442 in &lt;code&gt;open.c&lt;/code&gt;:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;   442          error = open_namei(filename,flag,mode,&amp;amp;inode,NULL);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Dabei ist &lt;code&gt;filename&lt;/code&gt; der Name der zu öffnenden Datei, &lt;code&gt;flag&lt;/code&gt; der Modus, in dem die Datei geöffnet werden soll (O_RDONLY, O_CREAT und so weiter) und &lt;code&gt;mode&lt;/code&gt; ist nur interessant, wenn die Datei angelegt werden soll:
Dann soll sie mit den in &lt;code&gt;mode&lt;/code&gt; angegebenen Wunschrechten angelegt werden.
In &lt;code&gt;inode&lt;/code&gt; liefert die Funktion die I-Node der geöffneten Datei  zurück.&lt;/p&gt;
&lt;p&gt;Der Code von &lt;code&gt;open_namei()&lt;/code&gt; steht dann in &lt;code&gt;/usr/src/linux/fs/namei.c&lt;/code&gt;, von dem wir uns ja weiter oben schon Teile angesehen haben.
&lt;code&gt;open_namei()&lt;/code&gt; ist eine lange Funktion, sie erstreckt sich von Zeile 333 bis Zeile 439.
Die Umwandlung des &lt;code&gt;filename&lt;/code&gt;-Parameters in die &lt;code&gt;inode&lt;/code&gt; erfolgt in zwei Schritten.
In einem ersten Schritt wird mithilfe von &lt;code&gt;dir_namei()&lt;/code&gt; erst einmal die I-Node des Verzeichnisses lokalisiert, in dem sich die zu öffnende Datei befindet.
Der zweite Schritt ist dann leicht unterschiedlich, je nachdem, ob die die öffnende Datei bereits existiert oder ob sie wegen eines gesetzten O_CREAT erst noch erzeugt werden muß.&lt;/p&gt;
&lt;p&gt;In Zeile 342 von &lt;code&gt;namei.c&lt;/code&gt; wird zunächst die I-Node des Verzeichnisses lokalisiert, in dem eine Datei geöffnet werden soll. Das ist der erste Schritt zum Öffnen der Datei.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;   342          error = dir_namei(pathname,&amp;amp;namelen,&amp;amp;basename,base,&amp;amp;dir);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Dabei wird von &lt;code&gt;dir_namei()&lt;/code&gt; die Variable &lt;code&gt;basename&lt;/code&gt; mit dem Namen der Datei im Verzeichnis belegt, &lt;code&gt;namelen&lt;/code&gt; mit der Länge dieses Namens. &lt;code&gt;dir&lt;/code&gt; ist ein Zeiger auf die I-Node des Verzeichnisses, indem die Datei geöffnet werden soll, das eigentliche Ergebnis dieses Aufrufes (und wird in Zeile 361 weiterverwendet).
Wenige Zeilen später wird fallweise unterschieden, ob eine Datei angelegt werden soll oder nicht (Zeile 359).&lt;/p&gt;
&lt;p&gt;Soll eine Datei angelegt werden, muß überprüft werden, ob eine Datei dieses Namens schon existiert (Zeile 361).
Wenn dies der Fall ist und außerdem O_EXCL als Parameter beim &lt;code&gt;open()&lt;/code&gt; angegeben war, muß das &lt;code&gt;open()&lt;/code&gt; fehlschlagen (Zeile 362-366).&lt;/p&gt;
&lt;p&gt;Existiert die Datei im Verzeichnis noch nicht, kann versucht werden, sie zu erzeugen.
Dazu müssen w- und x-Recht am Verzeichnis vorhanden sein, daß die Datei einmal enthalten soll (Zeile 367).
Außerdem muß eine &lt;code&gt;create&lt;/code&gt;-Funktion in den I-Node-Operations für das Verzeichnis definiert sein (Zeile 369-370).
Ist dies nicht der Fall, wird ebenfalls  &lt;code&gt;permission denied&lt;/code&gt; gemeldet.&lt;/p&gt;
&lt;p&gt;Auf Dateisystemen, die read-only angemeldet sind, dürfen selbstverständlich ebenfalls keine Dateien angelegt werden (Zeile 371-372).
Erst wenn alle diese Vorbedingungen erfüllt sind, darf die Datei wirklich angelegt werden und ist damit geöffnet.&lt;/p&gt;
&lt;p&gt;Wir halten fest: Um eine Datei in einem Verzeichnis neu anlegen zu können, wird also das x-Recht an allen Verzeichnissen entlang des Pfades dieser Datei benötigt und das w- und das x-Recht an dem Verzeichnis, in dem die Datei neu anzulegen ist.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;   359          if (flag &amp;amp; O_CREAT) {
   361                  error = lookup(dir,basename,namelen,&amp;amp;inode);
   362                  if (!error) {
   363                          if (flag &amp;amp; O_EXCL) {
   364                                  iput(inode);
   365                                  error = -EEXIST;
   366                          }
   367                  } else if ((error = permission(dir,
                                              MAY_WRITE | MAY_EXEC)
   368                          ;       /* error is already set! */
   369                  else if (!dir-&amp;gt;i_op || !dir-&amp;gt;i_op-&amp;gt;create)
   370                          error = -EACCES;
   371                  else if (IS_RDONLY(dir))
   372                          error = -EROFS;
   373                  else {
   
   375                          error = 
                     dir-&amp;gt;i_op-&amp;gt;create(dir,basename,namelen,mode,res_inode);
   
   379                  }
   381          } else
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Soll dagegen eine bereits existierende Datei geöffnet werden, muß zunächst ihr Name im Verzeichnis gesucht werden, um eine I-Node für diese Datei zu bekommen (Zeile 382).&lt;/p&gt;
&lt;p&gt;Es kann sein, daß die so gefundene I-Node nicht die I-Node der wirklich zu öffnenden Datei ist, sondern daß es sich um ein Symlink handelt.
Ein Aufruf von &lt;code&gt;follow_link()&lt;/code&gt; regelt dies (Zeile  387).&lt;/p&gt;
&lt;p&gt;Der folgende Code stellt dann sicher, daß ein Verzeichnis niemals zum Schreiben geöffnet werden darf (Zeile 390-393).
Wäre dies nicht so, könnte man in Verzeichnissen beliebige I-Node-Nummern eintragen und so die Zugriffsrechte entlang des Pfades unterlaufen.&lt;/p&gt;
&lt;p&gt;Der eigentliche Rechtetest erfolgt dann in den Zeilen 394-397, in denen die gewünschten Zugriffsrechte in &lt;code&gt;flag&lt;/code&gt; mit den vorhandenen Rechten in der inode verglichen werden.
Nach diesen Zeilen folgt weiterer Code, der Gerätedateien in mit &lt;code&gt;nodev&lt;/code&gt; gemounteten Dateisystemen, read-only Dateisysteme, append-only Files und die Option O_TRUNC beim Öffnen behandelt, uns hier aber bei unserer Frage nichts neues bringt.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;   382                  error = lookup(dir,basename,namelen,&amp;amp;inode);

   387          error = follow_link(dir,inode,flag,mode,&amp;amp;inode);

   390          if (S_ISDIR(inode-&amp;gt;i_mode) &amp;amp;&amp;amp; (flag &amp;amp; 2)) {
   391                  iput(inode);
   392                  return -EISDIR;
   393          }
   394          if ((error = permission(inode,ACC_MODE(flag))) != 0) {
   395                  iput(inode);
   396                  return error;
   397          }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Wir halten fest: Beim Öffnen einer vorhandenen Datei wird das x-Recht an allen Verzeichnisses entlang des Pfade dieser Datei benötigt und das passende r- und/oder w-Recht an der Datei selbst.&lt;/p&gt;
&lt;p&gt;Offenbar ist das Öffnen einer Datei und die Kontrolle der Zugriffsrechte für ein Betriebssystem eine recht anstrengende und langsame Angelegenheit.
Neben der zeitraubenden Umwandlung von Pfadnamen in I-Nodes müssen auch noch zahlreiche Rechteflags an allen Verzeichnissen und an der Datei selbst kontrolliert werden und zahlreiche Sonderfälle berücksichtigt werden.&lt;/p&gt;
&lt;p&gt;Zum Glück ist dieser ganze Aufwand auf das Öffnen einer Datei beschränkt.
Ist die Datei erst einmal geöffnet, findet keine weitere Rechtekontrolle mehr statt. &lt;code&gt;read()&lt;/code&gt; und &lt;code&gt;write()&lt;/code&gt; können sich also auf ihre eigentliche Aufgabe, das Datenschaufeln, konzentrieren und müssen sich nicht mit der Kontrolle von Zugriffsrechten herumschlagen.&lt;/p&gt;
&lt;h2 id=&#34;ausführungsrechte-an-dateien&#34;&gt;
    &lt;a href=&#34;#ausf%c3%bchrungsrechte-an-dateien&#34;&gt;
	Ausführungsrechte an Dateien
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Um das x-Recht an Dateien zu verstehen, müssen wir uns den Systemaufruf &lt;code&gt;execve(2)&lt;/code&gt; ansehen.
Dieser Systemaufruf ist die einzige Methode, um in UNIX ein neues Programm zu laden.
In Linux, das auf mehr als einer Prozessorplattform ablaufen kann, ist ein Teil des Aufrufes systemspezifisch.
Für Intel-Prozessoren befindet sich in &lt;code&gt;/usr/src/linux/arch/i386/kernel/process.c&lt;/code&gt; der Code von &lt;code&gt;sys_execve()&lt;/code&gt;, der die Parameter des Systemaufrufes beschafft und dann den plattformunabhängigen Code in &lt;code&gt;/usr/src/linux/fs/exec.c&lt;/code&gt; aufruft.
Der Funktion &lt;code&gt;do_execve()&lt;/code&gt; werden außer dem Namen der zu startenden Binärdatei auch noch ein Feld von Parameterstrings und ein Feld von Environmentvariablen sowie ein Satz initiale Prozessorregister mitgegeben.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;do_execve()&lt;/code&gt; beschafft sich durch einen Aufruf von &lt;code&gt;open_namei()&lt;/code&gt; zunächst einmal die I-Node der auszuführenden Datei.
Weiter oben ist schon gezeigt worden, daß dies nur gelingen kann, wenn auf allen Verzeichnissen entlang des Pfades zu dieser Datei x-Rechte vorhanden sind.&lt;/p&gt;
&lt;p&gt;Der folgende Code stellt sicher, daß die ausführbare Datei ein &lt;code&gt;regular file&lt;/code&gt; ist.
Wenn das Dateisystem mit der Option &lt;code&gt;noexec&lt;/code&gt; gemountet ist, schlägt der Aufruf von &lt;code&gt;execve()&lt;/code&gt; in jedem Fall fehl, ebenso wenn der Superblock zugehörigen Dateisystems nicht erreichbar ist.&lt;/p&gt;
&lt;p&gt;Nach diesen elementaren Überprüfungen folgt der Code, der &lt;em&gt;set user id/set group id&lt;/em&gt; handhabt und das x-Recht testet.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;ausführungsrecht-und-suidsgid-beim-execve-systemaufrufh3&#34;&gt;
    &lt;a href=&#34;#ausf%c3%bchrungsrecht-und-suidsgid-beim-execve-systemaufrufh3&#34;&gt;
	Ausführungsrecht und SUID/SGID beim execve() Systemaufruf&lt;/h3&gt;
    &lt;/a&gt;
&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;/usr/src/linux/fs/exec.c:
   586          i = bprm.inode-&amp;gt;i_mode;
   587          if (IS_NOSUID(bprm.inode) &amp;amp;&amp;amp; (((i &amp;amp; S_ISUID)
                &amp;amp;&amp;amp; bprm.inode-&amp;gt;i_uid != current-&amp;gt;
   588              euid) || ((i &amp;amp; S_ISGID) 
                &amp;amp;&amp;amp; 	!in_group_p(bprm.inode-&amp;gt;i_gid))) &amp;amp;&amp;amp; !suser()) {
   589                  retval = -EPERM;
   590                  goto exec_error2;
   591          }
   592          /* make sure we don&amp;#39;t let suid, sgid files be ptraced. */
   593          if (current-&amp;gt;flags &amp;amp; PF_PTRACED) {
   594                  bprm.e_uid = current-&amp;gt;euid;
   595                  bprm.e_gid = current-&amp;gt;egid;
   596          } else {
   597                  bprm.e_uid = 
                        (i &amp;amp; S_ISUID) ? bprm.inode-&amp;gt;i_uid : current-&amp;gt;euid;
   598                  bprm.e_gid = 
                        (i &amp;amp; S_ISGID) ? bprm.inode-&amp;gt;i_gid : current-&amp;gt;egid;
   599          }
   600          if ((retval = permission(bprm.inode, MAY_EXEC)) != 0)
   601                  goto exec_error2;
   602          if (!(bprm.inode-&amp;gt;i_mode &amp;amp; 0111) &amp;amp;&amp;amp; fsuser()) {
   603                  retval = -EACCES;
   604                  goto exec_error2;
   605          }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Im Rahmen der Funktion &lt;code&gt;do_execve()&lt;/code&gt; werden das SUID- und SGID-Bit der auszuführenden Datei geprüft und Linux bestimmt, unter welcher euid und egid das Programm zur Ausführung kommt.
Danach wird getestet, ob ausreichende Rechte vorhanden sind, um das Programm starten zu dürfen.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Zunächst bestimmt der Kernel die Rechtebits der auszuführenden Datei (Zeile 586).
Falls das Dateisystem, auf dem sich diese Datei befindet, mit der Option &lt;code&gt;nosuid&lt;/code&gt; angemeldet ist und die Ausführung der Datei einen Wechsel der effektiven User-ID oder Group-ID bewirken würde, darf nur der Superuser die Datei ausführen (Zeilen 587-591).
Danach wird bestimmt, unter welcher UID und GID das neue Programm zur Ausführung kommen wird.&lt;/p&gt;
&lt;p&gt;Falls das Programm zur Zeit mittels &lt;code&gt;ptrace()&lt;/code&gt; in einem Debugger bearbeitet wird, werden sich seine Rechte nicht ändern (Zeilen 592-595).
Auf diese Weise wird verhindert, daß man durch tracen eines SUID-Programmes und nachträgliches Verändern seines Codes zusätzliche Rechte gewinnen könnte.&lt;/p&gt;
&lt;p&gt;Bei normalen Programmen (Zeilen 596-599) wird die effektive UID aus der I-Node der auszuführenden Datei übernommen, wenn das SUID-Bit an der Datei gesetzt ist, andernfalls wird die UID des Vorläufers ererbt.
Analog wird mit der GID verfahren.&lt;/p&gt;
&lt;p&gt;Der Kernel wird das Programm jedoch nur ausführen, wenn die &lt;code&gt;permission()&lt;/code&gt;-Funktion feststellt, das MAY_EXEC-Recht vorhanden ist (Zeilen 600-601).
Auch ein Superuser kann eine Datei nicht als Programm starten, wenn nicht wenigstens irgendein x-Recht an der Datei vorhanden ist (Zeilen 602-603).&lt;/p&gt;
&lt;p&gt;Der folgende, sehr umfangreiche Code beschäftigt sich dann mit dem Handling von Shellscripten, die durch einen #!-Kommentar eingeleitet werden.
Erst ab Zeile 701 kann der Kernel versuchen, tatsächlich ein Programm mit den gegebenen Eigenschaften auszuführen.&lt;/p&gt;
&lt;p&gt;Wir halten fest:
Um ein Programm starten zu dürfen, muß außer den x-Rechten an den Verzeichnissen entlang des Pfades auch das x-Recht an der Datei vorhanden sein.
Ein Superuser kann eine Datei immerhin dann als Programm starten, wenn wenigsten irgendein x-Recht an der Datei vorhanden ist.
Wenn das SUID-Bit an der zu startenden Datei gesetzt ist, wird die Datei unter der &lt;code&gt;euid&lt;/code&gt; des Dateieigentümers ausgeführt, sonst unter der &lt;code&gt;euid&lt;/code&gt; des aufrufenden Prozesses - Prozesse mit einer bestehenden Verbindung zu einem Debugger werden jedoch aus Sicherheitsgründen immer nur unter der &lt;code&gt;euid&lt;/code&gt; des aufrufenden Prozesses ausgeführt.
Analog wird auch mit dem SGID-Bit verfahren.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id=&#34;experiment-5&#34;&gt;
    &lt;a href=&#34;#experiment-5&#34;&gt;
	Experiment 5
    &lt;/a&gt;
&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;root@white:/tmp# cat &amp;gt;&amp;gt; x
#! /bin/sh --

id
root@white:/tmp# chmod 6555 x
root@white:/tmp# ls -l x
-r-sr-sr-x   1 root     root           18 Dec 10 21:14 x
root@white:/tmp# exit
kris@white:~$ /tmp/x
uid=100(kris) gid=20(users) groups=20(users),11(floppy)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Shellscripte mit gesetztem SUID- und SGID-Bit werden trotzdem mit normalen euid- und egid-Werten aufgerufen.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a href=&#34;#experiment-5&#34;&gt;Experiment 5&lt;/a&gt;

 zeigt, wie der Kernel mit Shellscripten umgeht, die mit SUID- oder SGID-Rechten versehen sind.
Das liegt daran, daß bei der Interpretation von #!-Zeichen der Name des auszuführenden Programmes verändert wird und danach der &lt;code&gt;execve()&lt;/code&gt;-Aufruf komplett neu gestartet wird.
Aus dem Aufruf von &lt;code&gt;/tmp/x&lt;/code&gt; wird so durch die Interpretation der #!-Zeile der Aufruf &lt;code&gt;/bin/sh -- /tmp/x&lt;/code&gt;, der vom Kernel komplett neu bewertet wird.&lt;/p&gt;
&lt;p&gt;An &lt;code&gt;/bin/sh&lt;/code&gt; ist aber weder das SUID- noch das SGID-Bit gesetzt, also wird die Shell mit normalen Rechten gestartet.
Daß es sich bei einem Parameter des Aufrufes um den Namen einer Datei handelt, an der SUID und SGID gesetzt sind, darf den Kernel nicht interessieren und die Shell wertet es nicht aus - sie könnte es auch nicht, wenn sie wollte.
Dieser Effekt ist durchaus beabsichtigt: Ein nichttriviales Shellscript zu schreiben, daß sicher und ohne Lücken für eventuelle Hacker unter einer fremden User-ID laufen kann, ist so gut wie unmöglich.&lt;/p&gt;
&lt;h2 id=&#34;rückblick&#34;&gt;
    &lt;a href=&#34;#r%c3%bcckblick&#34;&gt;
	Rückblick
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Wie wir gesehen haben, findet die Kontrolle der Zugriffsrechte an Dateien in Linux so gut es geht zentral statt.
Wenige Funkionen wie &lt;code&gt;permission()&lt;/code&gt; und die Funktionen der &lt;code&gt;namei()&lt;/code&gt;-Familie spielen dabei eine sehr wichtige Rolle.
Trotzdem muß jeder Systemaufruf noch für sich selbst die Rechte des aufrufenden Prozesses an der Datei testen, die durch den Systemaufruf manipuliert werden soll.
Dabei müssen viele Sonderfälle wie &lt;em&gt;immutable files&lt;/em&gt;, &lt;em&gt;append only directories&lt;/em&gt; und andere exotische Dinge beachtet werden.
Wollte man eine vollständige und genaue Aufstellung von Zugriffsrechten in Linux machen, müßte man eine Liste von Systemaufrufen machen und für jeden Systemaufruf eine vollständige Liste von Vorbedingungen aufschreiben.
Ein Eintrag würde sich dann in etwa so lesen:&lt;/p&gt;
&lt;dl&gt;
&lt;dt&gt;unlink:&lt;/dt&gt;
&lt;dd&gt;&lt;code&gt;unlink()&lt;/code&gt; löscht eine Datei mit einem gegebenen Pfadnamen, wenn alle Verzeichnisse entlang des Pfades x-Recht haben, der Name der Datei im letzten Verzeichnis nicht leer (&amp;rdquo;&amp;quot;) ist, das Dateisystem nicht read only ist, am enthaltenden Verzeichnis w- und x-Recht bestehen, das enthaltende Verzeichnis nicht append only ist und für die I-Node der Datei eine unlink()-Operation definiert ist. Diese unlink()-Operation kann jedoch noch weitere Bedingungen an die Entfernung einer Datei stellen (das ext2-Dateisystem macht dies zum Beispiel, wenn das t-Bit am enthaltenden Verzeichnis gesetzt ist).&lt;/dd&gt;
&lt;/dl&gt;
&lt;p&gt;Letztendlich wird eine solche Tabelle jedoch sehr unübersichtlich und lang.
Man sieht, daß Zugriffsrechte in UNIX im allgemeinen und Linux im besonderen nur auf den ersten Blick einfach und harmlos aussehen.
Wenn man über das einfache &lt;code&gt;rwx&lt;/code&gt; hinausgeht, wird die ganze Angelegenheit ziemlich kompliziert und unübersichtlich, da viele Sonderfälle betrachtet werden müssen.
Zum Glück kommen solche Sonderfälle in einer normalen Installation nur sehr selten vor, denn sonst würde das eingangs erwähnte Kapitel 2 eines UNIX-Handbuches sehr lang werden &amp;hellip;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Samba</title>
      <link>https://blog.koehntopp.info/1996/01/11/samba.html</link>
      <pubDate>Thu, 11 Jan 1996 09:00:00 +0000</pubDate>
      
      <guid>https://blog.koehntopp.info/1996/01/11/samba.html</guid>
      <description>&lt;p&gt;&lt;strong&gt;erschienen in der iX 1/96&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#samba-19&#34;&gt;Text des Artikels&lt;/a&gt;

&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#samba-im-internet&#34;&gt;Samba im Internet&lt;/a&gt;

&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#eine-standardkonfiguration&#34;&gt;Eine Standardkonfiguration&lt;/a&gt;

&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;samba-19&#34;&gt;
    &lt;a href=&#34;#samba-19&#34;&gt;
	Samba 1.9
    &lt;/a&gt;
&lt;/h1&gt;
&lt;h4 id=&#34;samba-ist-ein-softwarepaket-für-unix-das-microsoft-lan-manager-server-funktionen-erbringt-ursprünglich-von-andrew-tridgell-einem-studenten-an-der-australian-national-university-canberra-erstellt-ist-es-inzwischen-unter-der-gnu-general-public-license-verfügbar&#34;&gt;
    &lt;a href=&#34;#samba-ist-ein-softwarepaket-f%c3%bcr-unix-das-microsoft-lan-manager-server-funktionen-erbringt-urspr%c3%bcnglich-von-andrew-tridgell-einem-studenten-an-der-australian-national-university-canberra-erstellt-ist-es-inzwischen-unter-der-gnu-general-public-license-verf%c3%bcgbar&#34;&gt;
	Samba ist ein Softwarepaket für Unix, das Microsoft Lan Manager Server-Funktionen erbringt. Ursprünglich von Andrew Tridgell, einem Studenten an der Australian National University, Canberra erstellt, ist es inzwischen unter der GNU General Public License verfügbar.
    &lt;/a&gt;
&lt;/h4&gt;
&lt;p&gt;Andrew Tridgell, ein Student an der Australian National University Canberra, stand Ende 1991 vor dem Problem, einen Fileserver für SUN Workstations haben zu müssen, der zu DEC Pathworks für kompatibel ist.
Ohne Informationen über die Art des verwendeten Protokolls zu haben, gelang es ihm schon nach wenigen Tagen, das verwendete Protokoll in Teilen zu reverse engineeren.
Erst nachdem eine allererste Version seines Servers schon fertiggestellt war, wies man ihn auf das in RFC 1001 und 1002 definierte &amp;ldquo;NetBIOS on a TCP/UDP transport&amp;rdquo; Protokoll hin.
Im Januar wurde die erste Version seines &amp;ldquo;Server 0.1&amp;rdquo; Paketes auf dem Netz veröffentlicht.
Es sollte jedoch noch bis Ende 1993 dauern, bis Tridgell durch den Einsatz von Linux und die Notwendigkeit, mit PCs unter DOS, Windows und OS/2 zu kommunizieren, die Weiterentwicklung von Samba wieder aufnahm.&lt;/p&gt;
&lt;p&gt;Heute ist Samba ein relativ ausgereiftes, standardkonformes und vor allen Dingen hochportables Softwarepaket, das auf den meisten UNIX-Versionen problemlos installierbar ist und die Möglichkeit bietet, Verzeichnisse und Drucker an PC-Betriebssysteme zu exportieren.
Samba konkurriert hier mit dem von SUN definierten Network File System (NFS).&lt;/p&gt;
&lt;p&gt;Für den Systemadministrator in einem heterogenen Netzwerk von UNIX-Servern und Client-PCs ist Samba dabei wahrscheinlich attraktiver als NFS, denn in den meisten Fällen stehen wenigen UNIX-Servern viele Client-PCs gegenüber.
Beim Einsatz von NFS könnte zwar das mit den meisten UNIX-Versionen mitgelieferte Serverpaket verwendet werden, aber für die Clients müßten nicht nur viele Client-Lizenzen von PC-NFS oder etwas vergleichbarem angeschafft werden, sondern diese Software müßte auch netzwerkweit installiert und gewartet werden.
Windows für Workgroups, Windows 95, Windows NT und OS/2 sprechen aber schon von Haus aus das Lan Manager Protokoll und so ist es effizienter, den wenigen Servern dieses Protokoll beizubringen und auf den Clients mitgelieferte Software zu verwenden.
Diesen Weg geht Samba.&lt;/p&gt;
&lt;p&gt;Da der Samba-Server ein reiner Usermode-Server ist, also ein ganz normales Anwendungsprogramm, ist es möglich, auch Verzeichnisse per Samba zu reexportieren, die der Server per NFS gemountet hat.
Auf diese Weise entsteht eine Protokollbrücke von NFS nach SMB.
Dabei ist natürlich der Performanceverlust durch doppelten Netzzugriff in Kauf zu nehmen.
Auf der anderen Seite ist Samba unter der GNU GPL frei zur Verfügung stehende Software und so steht der Installation des Samba-Servers auf allen Servermaschinen nichts im Weg.&lt;/p&gt;
&lt;p&gt;Es soll jedoch nicht verschwiegen werden, daß Samba aus der Sicht eines UNIX-Systemverwalters schwerwiegende Nachteile hat.
Als Protokoll, das in der PC-Welt entstanden ist, kennt Samba kein Konzept eines Dateieigentümers.
Die Zugriffe auf Ressourcen erfolgen oft mit unklaren Userrechten oder scheinbar willkürlich gewählten Paßworten.
Betriebssysteme wie Windows für Workgroups und Windows&#39;95, die dem Benutzer zwar einen Namen geben, dann aber Netzwerkzugriffe ohne oder unter anderen Namen erzeugen, machen die Sache nicht leichter.
Dazu kommt, daß die Familie der Windows-Betriebssysteme die Groß-/Kleinschreibung von Paßworten in einigen Kombinationen von Betriebssystem/Paßwort verändern.
Samba hat eine ganze Reihe Mechanismen, um diesem Problem abzuhelfen, aber der Verwaltungsaufwand ist anfangs trotzdem höher als bei einer typischen NFS-Installation.&lt;p&gt;&lt;/p&gt;
&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/1996/01/SuperNOS.gif&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;

&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Novell hat versucht, das Super Network Operating System durch Verschmelzung der zugekauften UNIX-Quellen mit ihrem eigenen Serverbetriebssystem zu bauen und ist gescheitert. Klammheimlich hat das frei verfügbare Linux gelernt, die meisten Netzwerkprotokolle zu sprechen und ist auf dem besten Wege, eben dieses SuperNOS zu werden.&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&#34;installation&#34;&gt;
    &lt;a href=&#34;#installation&#34;&gt;
	Installation
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Die Installation gestaltet sich relativ einfach.
Nach dem Auspacken ist das Makefile im &lt;code&gt;source/&lt;/code&gt;-Verzeichnis nach den eigenen Wünschen anzupassen.
Dabei ist es hilfreich, nicht nur die gewünschten Pfadnamen einzutragen, sondern auch schon den Namen der gewünschten Arbeitsgruppe in der Variablen &lt;code&gt;WORKGROUP&lt;/code&gt; einzutragen und einen speziellen  Gastaccount, der nur für SMB genutzt wird, in &lt;code&gt;GUESTACCOUNT&lt;/code&gt; einzucompilieren.
Diese Defaults sind zwar auch zur Laufzeit änderbar, aber anpassen im Quelltext erspart das Schreiben von Konfigurationsdateien.
Weiterhin sind noch die gewünschten &lt;code&gt;make&lt;/code&gt;-Optionen für den verwendeten Betriebssystemtyp zu aktivieren.
Danach steht einem &lt;code&gt;make&lt;/code&gt; nichts mehr im Wege.&lt;/p&gt;
&lt;p&gt;Erzeugt werden die Programme&lt;/p&gt;
&lt;dl&gt;
&lt;dt&gt;nmbd:&lt;/dt&gt;
&lt;dd&gt;NetBios Name Server. Der Name Server ist in der Lage, Hostnamen auf IP-Nummern abzubilden. Gleichzeitig steuert das Programm aber auch das Browsing, d.h. die Anzeige von exportierten Diensten und übernimmt damit Aufgaben, die bei NFS der &lt;code&gt;mountd&lt;/code&gt; wahrnehmen würde.&lt;/dd&gt;
&lt;dt&gt;nmblookup:&lt;/dt&gt;
&lt;dd&gt;NetBios Name Lookup. Das Programm nimmt in etwa dieselbe Funktion wahr wie &lt;code&gt;nslookup&lt;/code&gt; für das DNS, fragt jedoch einen &lt;code&gt;nmbd&lt;/code&gt; ab.&lt;/dd&gt;
&lt;dt&gt;smbclient:&lt;/dt&gt;
&lt;dd&gt;Samba Client. Dient dazu, auf Linux-Seite einen SMB Server zu connecten und Dateien zu übertragen. Die Steuerung erfolgt ähnlich wie bei FTP. Linux bietet auch ein echtes, kernelbasiertes &lt;code&gt;smbfs&lt;/code&gt; an, mit dem man einen Server richtig mounten kann. Andere Betriebssysteme sind auf den &lt;code&gt;smbclient&lt;/code&gt; angewiesen.&lt;/dd&gt;
&lt;dt&gt;smbd:&lt;/dt&gt;
&lt;dd&gt;Der eigentliche Fileserver.&lt;/dd&gt;
&lt;dt&gt;smbpasswd:&lt;/dt&gt;
&lt;dd&gt;Ein Hilfsprogramm des &lt;code&gt;smbd&lt;/code&gt;, mit dem Benutzer vom Client aus ihr Paßwort ändern können sollen. Es hat nur dann Funktion, wenn Samba mit der &lt;code&gt;libdes&lt;/code&gt; und verschlüsselten Paßworten (siehe &lt;strong&gt;Samba im Internet&lt;/strong&gt;) übersetzt wurde.&lt;/dd&gt;
&lt;dt&gt;smbrun:&lt;/dt&gt;
&lt;dd&gt;Ein Hilfsprogramm des &lt;code&gt;smbd&lt;/code&gt;, mit dem Samba zu Beginn und Ende einer Serverconnection Logbucheinträge erzeugt.&lt;/dd&gt;
&lt;dt&gt;smbstatus:&lt;/dt&gt;
&lt;dd&gt;Ein sehr einfaches Programm zur Anzeige des Status aller zum Server bestehenden Verbindungen.&lt;/dd&gt;
&lt;dt&gt;smbtar:&lt;/dt&gt;
&lt;dd&gt;Ein Shellscript, das &lt;code&gt;smbclient&lt;/code&gt; verwendet und das ein von einem PC exportiertes Verzeichnis mit &lt;code&gt;tar&lt;/code&gt; auf dem Bandlaufwerk des UNIX-Servers sichert.&lt;/dd&gt;
&lt;dt&gt;testparm:&lt;/dt&gt;
&lt;dd&gt;Syntaxchecker für die Konfigurationsdatei.&lt;/dd&gt;
&lt;dt&gt;testprns:&lt;/dt&gt;
&lt;dd&gt;Syntaxchecker für die Druckerkonfiguration.&lt;/dd&gt;
&lt;/dl&gt;
&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/1996/01/programme.gif&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;

&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Samba besteht aus einer Reihe von Programmen, die zum Betrieb des Servers (Server-Tools) oder zu seinem Test (Client-Tools) dienen.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Ein &lt;code&gt;make install&lt;/code&gt; installiert diese Programme und die Manualpages dann im gewünschten Verzeichnis.
Damit der Server in Betrieb genommen werden kann, müssen &lt;code&gt;nmbd&lt;/code&gt; und &lt;code&gt;smbd&lt;/code&gt; entweder als permanent laufende Dämonen gestartet werden oder über passende Einträge in der &lt;code&gt;/etc/inetd.conf&lt;/code&gt; bei Bedarf hochgezogen werden.&lt;/p&gt;
&lt;p&gt;Für letzteres sind die Einträge&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;netbios-ns      137/tcp                         # NETBIOS Name Service
netbios-ns      137/udp
netbios-dgm     138/tcp                         # NETBIOS Datagram Service
netbios-dgm     138/udp
netbios-ssn     139/tcp                         # NETBIOS session service
netbios-ssn     139/udp
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;in der Datei &lt;code&gt;/etc/services&lt;/code&gt; notwendig. Dazu passen dann die Zeilen&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#
# SMB Samba File Server
#
netbios-ssn stream tcp  nowait  root    /usr/local/samba/bin/smbd smbd 
netbios-ns  dgram  udp  wait    root    /usr/local/samba/bin/nmbd nmbd -H /usr/local/samba/lib/lmhosts
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;in der &lt;code&gt;/etc/inetd.conf&lt;/code&gt;.
Der &lt;code&gt;inetd&lt;/code&gt; muß nach einer Änderung in seiner Konfigurationsdatei durch ein &lt;code&gt;SIGHUP&lt;/code&gt; geweckt werden, damit er die Datei neu einliest.&lt;/p&gt;
&lt;h2 id=&#34;tests-mit-einer-einfachen-konfiguration&#34;&gt;
    &lt;a href=&#34;#tests-mit-einer-einfachen-konfiguration&#34;&gt;
	Tests mit einer einfachen Konfiguration
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Durch die Verwendung einer &lt;code&gt;lmhosts&lt;/code&gt;-Datei kann der Samba-Server als Nameserver für ein Lan Manager Netzwerk dienen.
Die &lt;code&gt;lmhosts&lt;/code&gt;-Datei entspricht dabei in ihren ersten beiden Spalten einer normalen Hosts-Datei:
In der ersten Spalte wird eine IP-Nummer genannt, der in der zweiten Spalte ein Name zugeordnet wird.
Mit einer optionalen, dritten Spalte können für einzelne Namen bestimmte Flags gesetzt werden:
Der Buchstabe &lt;code&gt;G&lt;/code&gt; kennzeichnet einen Namen als den Namen der eigenen Arbeitsgruppe.
Die zugehörige Adresse ist die Broadcast-Adresse der betreffenden Arbeitsgruppe.
Das Flag &lt;code&gt;S&lt;/code&gt; kennzeichnet die Namen und Broadcastadressen weiterer Arbeitsgruppen, in denen die Dienste unseres Servers ebenfalls angepriesen (registriert) werden sollen.
Und das Flag &lt;code&gt;M&lt;/code&gt; schließlich kennzeichnet diesen Eintrag als den defaultmäßigen Netbios-Namen dieser Maschine.&lt;/p&gt;
&lt;p&gt;Der nächste Schritt ist die Erzeugung der zentralen Konfigurationsdatei.
Wenn Samba im Defaultverzeichnis &lt;code&gt;/usr/local/samba&lt;/code&gt; installiert worden ist, muß diese Datei in &lt;code&gt;/usr/local/samba/lib/smb.conf&lt;/code&gt; angelegt werden.
Ihr Aufbau gleicht syntaktisch dem einer WIN.INI-Datei von MS-Windows:
Sie besteht aus Abschnitten, die jeweils durch einen Namen in eckigen Klammern eingeleitet wird.
Jeder Abschnitt enthält dann eine Reihe von Zuweisungen der Form &lt;code&gt;Parameter = Wert&lt;/code&gt;.
Parameter dürfen genau wie Abschnittnamen Leerzeichen enthalten, die Samba ignoriert.
Ebenso spielt Gross- und Kleinschreibung keine Rolle.&lt;/p&gt;
&lt;p&gt;Jeder Abschnitt der &lt;code&gt;smb.conf&lt;/code&gt; definiert einen Service, der von Samba exportiert wird.
Ein Service kann dabei ein Drucker oder - häufiger - ein Verzeichnis sein.
Samba kennt drei Abschnitte, die besondere Bedeutung haben:&lt;/p&gt;
&lt;dl&gt;
&lt;dt&gt;[global]:&lt;/dt&gt;
&lt;dd&gt;In diesem Abschnitt werden besondere, globale Einstellungen für den Server getroffen.&lt;/dd&gt;
&lt;dt&gt;[printers]:&lt;/dt&gt;
&lt;dd&gt;In diesem Abschnitt kann man alle Drucker der &lt;code&gt;/etc/printcap&lt;/code&gt; exportieren.&lt;/dd&gt;
&lt;dt&gt;[homes]:&lt;/dt&gt;
&lt;dd&gt;In diesem Abschnitt kann man alle Homeverzeichnisse des Servers exportieren.&lt;/dd&gt;
&lt;/dl&gt;
&lt;p&gt;Samba bietet nun buchstäblich Dutzende von Parametern, mit denen man den Server seinen Bedürfnissen anpassen kann.
Zum Glück sind die Defaults jedoch so eingestellt, daß man nur wenige dieser Parameter wirklich anpassen muß.&lt;/p&gt;
&lt;p&gt;Zum Testen sollte man eine minimale &lt;code&gt;smb.conf anlegen.&lt;/code&gt;Sie könnte zum Beispiel so aussehen:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;[global]
        guest account = smbguest

[tmp]
        comment = temporary files 
        path = /tmp
        read only = yes
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Der Account &lt;code&gt;smbguest&lt;/code&gt; ist dabei ein User mit minimalen Rechten.
Der Abschnitt &lt;code&gt;[tmp]&lt;/code&gt; exportiert das lokale &lt;code&gt;/tmp&lt;/code&gt;-Verzeichnis read-only an die Welt.&lt;/p&gt;
&lt;p&gt;Die Korrektheit dieser Konfigurationsdatei kann mit dem Kommando&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ SAM=/usr/local/samba
$ $SAM/bin/testparm $SAM/lib/smb.conf | more
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;schnell überprüft werden.
&lt;code&gt;testparm&lt;/code&gt; liest die Datei ein und zeigt an, ob die Datei syntaktisch korrekt ist.
Danach werden die Werte aller internen Konfigurationsvariablen ausgegeben.
Auf diese Weise kann man schnell sehen, mit welchen internen Parameterwerten Samba wirklich operiert.&lt;/p&gt;
&lt;p&gt;Mit dem &lt;code&gt;smbclient&lt;/code&gt; kann man nun ausprobieren, ob das gewünschte Verzeichnis wirklich exportiert wird:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$SAM/bin/smbclient -L localhost -U%
Server time is Thu Nov 23 11:17:01 1995
Timezone is UTC+1.0
Domain=[DAHEIM] OS=[Unix] Server=[Samba 1.9.15p3]

Server=[localhost] User=[smbguest] Workgroup=[DAHEIM] Domain=[DAHEIM]

        Sharename      Type      Comment
        ---------      ----      -------
        tmp            Disk      temporary files
        IPC$           IPC       IPC Service (Samba 1.9.15p3)


This machine has a browse list:

        Server               Comment
        ---------            -------
        WHITE                Samba 1.9.15p3
        MAHAKI               
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Die Meldung &amp;ldquo;bad password&amp;rdquo; an dieser Stelle würde anzeigen, daß der Gastaccount von Samba nicht richtig gesetzt ist oder nicht verwendet werden kann.
Auch &amp;ldquo;hosts allow&amp;rdquo; und &amp;ldquo;hosts deny&amp;rdquo;-Einträge, die unseren eigenen Rechner ausschließen, oder &amp;ldquo;valid users&amp;rdquo; und &amp;ldquo;invalid users&amp;rdquo;, die zu strikt gesetzt sind, können zu der Fehlermeldung führen.&lt;/p&gt;
&lt;p&gt;Die Meldung &amp;ldquo;connection refused&amp;rdquo; deutet dagegen darauf hin, daß auf den Samba-Sockets kein Dämon zuhört.
Ein häufiger Fehler ist es, den inetd nach Änderungen an der Konfigurationsdatei nicht mit &lt;code&gt;SIGHUP&lt;/code&gt; zu wecken.
&lt;code&gt;netstat -a&lt;/code&gt; zeigt an, ob jemand auf dem Port &lt;code&gt;netbios-ssn&lt;/code&gt; zuhört.&lt;/p&gt;
&lt;p&gt;Ähnlich kann man die Funktionsfähigkeit des &lt;code&gt;nmbd&lt;/code&gt; überprüfen:
Das Kommando&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ $SAM/bin/nmblookup -B localhost __SAMBA__
Sending queries to 127.0.0.1
193.102.57.4 __SAMBA__
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;sollte die IP-Adresse des eigenen Servers zurückliefern. Ebenso sollte ein&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ $SAM/bin/nmblookup -B mahaki &amp;#39;*&amp;#39;
Sending queries to 193.102.57.2
193.102.57.2 *
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;die Adresse des Clients zurückliefern.
Und schließlich sollten sich bei einem&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ $SAM/bin/nmblookup -d 2 &amp;#39;*&amp;#39;
Netmask for eth0 = 255.255.255.0
Derived broadcast address 193.102.57.255
Using broadcast 193.102.57.255
Sending queries to 193.102.57.255
Got a positive name query response from 193.102.57.2 (193.102.57.2)
Got a positive name query response from 193.102.57.4 (193.102.57.4)
193.102.57.4 *
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;alle Teilnehmer des lokalen Netzes melden, falls sie schnell genug sind.
Falls Server und Client nicht auf demselben Subnetz sind, ist es notwendig, die korrekte Broadcast-Adresse des entfernten Subnetzes mit der Option -B anzugeben.&lt;/p&gt;
&lt;p&gt;Wenn man so sichergestellt hat, daß sich alle Rechner untereinander kennen und einander erreichen können, kann man versuchen, erst einmal lokal auf die exportierten Ressourcen
zuzugreifen:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ $SAM/bin/smbclient &amp;#34;\\\\localhost\\tmp&amp;#34;
Server time is Thu Nov 23 11:28:06 1995
Timezone is UTC+1.0
Password: 
Domain=[DAHEIM] OS=[Unix] Server=[Samba 1.9.15p3]
smb: \&amp;gt; dir
  isdnctrl0                                226942  Thu Nov 23 10:14:14 1995
  crond_running                                 0  Thu Nov 23 11:28:01 1995
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Der Name der verwendeten Ressource wird DOS-Konform mit &lt;code&gt;\\rechner\ressource&lt;/code&gt; bezeichnet.
Die verwendete Shell macht es jedoch notwendig, Backslashes als &lt;code&gt;\\&lt;/code&gt; zu escapen.
Die Schreibweise des Kommandos erscheint so etwas merkwürdig.
Samba versucht sich unter dem normalen Usernamen anzumelden.
Das verlangte Paßwort ist also das normale Paßwort des Accounts.
Möchte man unter einem anderen Benutzernamen testen, ist die Option &lt;code&gt;-U username&lt;/code&gt; hinter dem Namen der Ressource anzugeben.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;smbclient&lt;/code&gt; arbeitet ähnlich wie &lt;code&gt;ftp&lt;/code&gt; und versteht Kommandos wie &amp;ldquo;help&amp;rdquo;, &amp;ldquo;get&amp;rdquo;, &amp;ldquo;put&amp;rdquo; und &amp;ldquo;quit&amp;rdquo;.
Wegen der Option &lt;code&gt;read only = yes&lt;/code&gt; in der &lt;code&gt;smb.conf&lt;/code&gt; schlägt ein &amp;ldquo;put&amp;rdquo; wie erwartet fehl:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;smb: \&amp;gt; put username.map
ERRDOS - ERRnoaccess (Access denied.) opening remote file \username.map
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Wenn dies alles funktioniert, kann man versuchen, vom PC aus auf das Verzeichnis zuzugreifen.
Aus einem DOS-Fenster sollte man die exportierten Ressourcen mit&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;E:\users\default&amp;gt;net view &amp;#34;\\white&amp;#34;
Freigegebene Ressourcen auf \\white

Samba 1.9.15p3

Name         Typ          Lokal    Beschreibung

-------------------------------------------------------------------------------
tmp          Platte                temporary files
Der Befehl wurde erfolgreich ausgeführt.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ansehen. Mit&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;E:\users\default&amp;gt;net use &amp;#34;\\white\tmp&amp;#34; /user:kris
Das Kennwort für \\white\tmp ist ungültig.

Geben Sie das Kennwort für \\white\tmp ein:
Der Befehl wurde erfolgreich ausgeführt.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;kann man sich dann beim Server anmelden.
Programme, die erweiterte Pfadnamen mit &lt;code&gt;\\rechnername&lt;/code&gt; verstehen, können jetzt schon auf das Laufwerk zugreifen.
Der Samba-Server sollte nun auch im Dateimanager unter &amp;ldquo;Datenträger&amp;rdquo;, &amp;ldquo;Netzwerklaufwerk verbinden&amp;rdquo; sichtbar sein.&lt;/p&gt;
&lt;p&gt;Die Bemerkung &amp;ldquo;Das Kennwort für &amp;hellip; ist ungültig&amp;rdquo; des Windows NT-Servers aus dem Beispiel tritt übrigens auf, weil der Samba Server ohne verschlüsselte Paßworte  übersetzt wurde.
Wir der Server mit der &lt;code&gt;libdes&lt;/code&gt; und der Option &lt;code&gt;encrypted passswords = yes&lt;/code&gt; in der &lt;code&gt;smb.conf&lt;/code&gt; installiert, erfolgt das Login ohne Rückfrage.&lt;/p&gt;
&lt;h2 id=&#34;geschwindigkeit&#34;&gt;
    &lt;a href=&#34;#geschwindigkeit&#34;&gt;
	Geschwindigkeit
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Samba verwendet ein verbindungsorientiertes und asynchrones Protokoll und unterliegt so nicht den Einschränkungen, die die Geschwindigkeit von NFS begrenzen.
Auf der anderen Seite ist der Samba-Server so natürlich nicht so datensicher wie ein NFS-Server.
In der Praxis sollte das wenig ausmachen, da die Clients PCs sind und so vermutlich häufiger abstürzen&amp;hellip;&lt;/p&gt;
&lt;p&gt;Geschwindigkeitsprobleme kann es beim Einloggen geben, wenn der Client ein Windows für Workgroups ist und Samba das Loginpaßwort raten muß (siehe Kasten &amp;ldquo;Eine Standardkonfiguration&amp;rdquo;).
Falls das richtige Paßwort mehrere Großbuchstaben enthält und die &lt;code&gt;crypt()&lt;/code&gt;-Routine des Servers hinreichend langsam ist, können so einige Sekunden vergehen.&lt;/p&gt;
&lt;p&gt;Der Text &lt;code&gt;SPEED.txt&lt;/code&gt; aus der Samba-Dokumentation enthält außerdem einige weitere Tips, mit der man die Geschwindigkeit des Servers unter Umständen weiter verbessern kann:
Niedrige Debug-Level, große Puffer und überlappende Zugriffe auf Platte und Netzwerk können die Serverperformance weiter steigern.&lt;/p&gt;
&lt;p&gt;Alles in allem erreicht Samba so eine Performance, die einem Windows NT Server oder einem Pathworks Server vergleichbar ist.&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;samba-im-internet&#34;&gt;
    &lt;a href=&#34;#samba-im-internet&#34;&gt;
	Samba im Internet
    &lt;/a&gt;
&lt;/h1&gt;
&lt;p&gt;Die zur Zeit der Entstehung dieses Artikels aktuelle Version von
Samba ist 1.9.15, Patch 3.&lt;/p&gt;
&lt;p&gt;Das Homeverzeichnis von Samba ist &lt;a href=&#34;ftp://nimbus.anu.edu.au/pub/tridge/samba&#34;&gt;ftp://nimbus.anu.edu.au/pub/tridge/samba&lt;/a&gt;

.
Da jedoch die Internet-Anbindung von Australien aus der Sicht von Deutschland nicht überragend ist, ist es vorteilhaft, sich Samba von einem der offiziellen Mirrors zu kopieren.
Die Dokumentation nennt dazu unter anderem
&lt;a href=&#34;ftp://sunsite.unc.edu/pub/Linux/system/Network/Samba&#34;&gt;ftp://sunsite.unc.edu/pub/Linux/system/Network/Samba&lt;/a&gt;


und
&lt;a href=&#34;ftp://ftp.uni-trier.de/pub/unix/network/samba&#34;&gt;ftp://ftp.uni-trier.de/pub/unix/network/samba&lt;/a&gt;

.&lt;/p&gt;
&lt;p&gt;Das Paket liegt außerdem auf vielen deutschen Sunsite-Mirrors und ist praktisch auf jeder besseren Linux CD-ROM auch im Quelltext archviert.
Diese Versionen hinken jedoch, wie üblich, um einige Minor-Releases hinterher.&lt;/p&gt;
&lt;p&gt;Nicht alle Mirrors archivieren
&lt;a href=&#34;ftp://nimbus.anu.edu.au/pub/tridge/libdes/libdes.tar.92-10-13.gz&#34;&gt;ftp://nimbus.anu.edu.au/pub/tridge/libdes/libdes.tar.92-10-13.gz&lt;/a&gt;

,
weil dies administrative Probleme beim FTP-Verkehr von und nach USA machen würde.
Diese Bibliothek ist notwendig, wenn man mit verschlüsselten Paßworten auf dem Netz arbeiten möchte.
Clients und Server unter Windows NT verhalten sich ohne verschlüsselte Paßworte jedoch eigenartig.&lt;/p&gt;
&lt;p&gt;Samba hat eine eigene Newsgroup im USENET, &lt;code&gt;comp.protocols.smb&lt;/code&gt;,
die glücklicherweise nicht sehr überlaufen ist.
Außerdem findet man in den einschlägigen Linux-Newsgroups ebenfalls massenweise Fragen und Antworten rund um Samba.&lt;/p&gt;
&lt;p&gt;Wer an aktuellen Informationen über Samba interessiert ist, kann sich auf der Mailingliste &lt;code&gt;samba-announce&lt;/code&gt; eintragen lassen.
Dazu ist es notwendig, eine Mail an &lt;code&gt;listproc@listproc.anu.edu.au&lt;/code&gt; zu senden, die im Text (nicht im Subject!) das Kommando &lt;code&gt;subscribe samba-announce Vorname Nachname&lt;/code&gt; enthält.&lt;/p&gt;
&lt;p&gt;Es existiert eine weitere Mailingliste, &lt;code&gt;samba&lt;/code&gt;, die der Weiterentwicklung von Samba dient.
Um sich dort einzuschreiben, ist &lt;code&gt;subscribe samba Vorname Nachname&lt;/code&gt; an die oben angegebene Adresse zu senden.&lt;/p&gt;
&lt;p&gt;Die Samba Home-Page ist &lt;a href=&#34;http://lake.canberra.edu.au/pub/samba/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://lake.canberra.edu.au/pub/samba/&lt;/a&gt;

&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;eine-standardkonfiguration&#34;&gt;
    &lt;a href=&#34;#eine-standardkonfiguration&#34;&gt;
	Eine Standardkonfiguration
    &lt;/a&gt;
&lt;/h1&gt;
&lt;p&gt;Die folgende Konfigurationsdatei dürfte die meisten
einfachen Anwendungsfälle abdecken:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;[global]
  ; Gastaccount zuweisen
  guest account = smbguest
  ; Nicht alle User auf dem UNIX-Rechner heißen auf dem Windows NT gleich
  ; Format:
  ; unixuser = dosalias dosalias2 dosalias3...
  ; root = administrator admin
  username map = /usr/local/samba/lib/username.map
  ; Windows NT erfordert libdes und encrypted passwords, siehe Dokumentation
  encrypt passwords = yes
  ; Samba soll Domain Master und Browse Master sein.
   os level = 33
   domain master = yes
  ; nur Verbindungen von vertrauenswürdigen Hosts zulassen
  allow hosts = black, white, mahaki
  ; DOS &amp;#34;share&amp;#34; locking simulieren
  locking = yes
  share modes = yes
  ; Windows NT Protokoll verwenden
  ; Optionen sind CORE, COREPLUS, LANMAN1, LANMAN2 und NT1
  protocol = NT1
  
  ; Dies ist die Workgroup, der wir angehören
  workgroup = DAHEIM
  
[tmp]
  comment = Zwischenablage
  path = /tmp
  read only = no

[faq]
  comment = Haeufig gestellte Fragen (aus USENET)
  path = /scratch/faq
  read only = yes

[homes]
  comment = Homeverzeichnisse
  browseable = no
  read only = no
  create mode = 0750

[printers]
  comment = Alle Drucker aus /etc/printcap
  printing = bsd
  browseable = no
  load printers = yes
  read only = yes
  printable = yes
  path = /tmp
  public = yes
  create mode = 0700
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Diese &lt;code&gt;smb.conf``  versucht einen minimalen Sicherheitslevel herzustellen, indem nur Verbindungen von Hosts von vertrauenswürdigen zugelassen werden. Sie exportiert zwei gewöhnliche Verzeichnisse: &lt;/code&gt;/tmp&lt;code&gt;read-write und&lt;/code&gt;/scratch/faq` read-only.&lt;/p&gt;
&lt;p&gt;Außerdem werden die Drucker der &lt;code&gt;/etc/printcap&lt;/code&gt; durch den besonderen Abschnitt &lt;code&gt;[printers]&lt;/code&gt; und die Home-Verzeichnisse aller Benutzer durch &lt;code&gt;[homes]&lt;/code&gt; exportiert.
Beide Abschnitte sind nicht als Browseable gekennzeichnet.
Dadurch erscheint nur das Home-Verzeichnis des auf dem Windows-Rechner angemeldeten Benutzers in der Browse-List des Dateimanagers.
Ebenso wird nicht &lt;code&gt;[printers]&lt;/code&gt; selbst im Druckmanager angezeigt, sondern die Drucker der &lt;code&gt;/etc/printcap&lt;/code&gt; werden durch das &lt;code&gt;load printers&lt;/code&gt; einzeln angezeigt.&lt;/p&gt;
&lt;p&gt;Dadurch, daß das NT1-Protkoll verwendet wird, ist es möglich, auch lange Dateinamen mit Groß-/Kleinschreibung zu verwenden.
Auch das LANMAN2-Protokoll kann dies.
Windows für Workgroups wandelt alle Paßworte in reine Großschrift um, wenn ein höheres Protokoll als COREPLUS verwendet wird.
In diesem Fall versucht Samba, das Paßwort zu raten, indem das übermittelte Paßwort in Groß- und Kleinschrift ausprobiert wird.
Mit der Option &lt;code&gt;password level = zahl&lt;/code&gt; kann man Samba dazu bewegen, auch Kombinationen von Groß- und Kleinbuchstaben zu testen.
Die Zahl bestimmt dabei die maximale Anzahl von Großbuchstaben im Paßwort.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>init - Starten und Beenden von Linux</title>
      <link>https://blog.koehntopp.info/1995/12/01/init-starten-und-beenden-von-linux.html</link>
      <pubDate>Fri, 01 Dec 1995 09:00:00 +0000</pubDate>
      
      <guid>https://blog.koehntopp.info/1995/12/01/init-starten-und-beenden-von-linux.html</guid>
      <description>&lt;p&gt;&lt;strong&gt;Linux Magazin, Heft 12/1995&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;init---starten-und-beenden-von-linux&#34;&gt;
    &lt;a href=&#34;#init---starten-und-beenden-von-linux&#34;&gt;
	init - Starten und Beenden von Linux
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;Der Prozeß mit der Prozeßnummer 1 ist init. init wird beim Starten des Systems geladen und läuft bis zum Abschalten durch. Er ist der direkte oder indirekte Urahn aller anderen Prozesse eines Linux-Systems. Ein genaues Verständnis der Vorgänge vom Starten von init bis zum Erscheinen des ersten Shellprompts nach dem Login ist notwendig, um fehlerhaft konfigurierte Linuxsysteme wiederzubeleben, ohne neu installieren zu müssen.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Die meisten Linux-Distributionen haben heutzutage den sysvinit 2.4 von Miquel van Smoorenburg (Miquel van Smoorenburg) installiert. Diese init-Version entspricht im Großen und Ganzen den von regulären System V Systemen bekannten inits, ist aber auf PC-Verhältnisse besonders angepaßt. sysvinit kennt zum Beispiel spezielle Optionen betreffend das Verhalten bei einem Stromausfall mit einer USV und weiß mit einem Control-Alt-Delete umzugehen. Mit Smoorenburgs init-Paket kommen außer init auch noch die Programme &lt;code&gt;halt&lt;/code&gt;, &lt;code&gt;last&lt;/code&gt;, &lt;code&gt;mesg&lt;/code&gt;, &lt;code&gt;shutdown&lt;/code&gt; und &lt;code&gt;wall&lt;/code&gt; sowie der Quelltext für den &lt;code&gt;powerd&lt;/code&gt;, ein Auswertedämon für die Statusleitungen von USVs. Eine Version von &lt;code&gt;who&lt;/code&gt;, die auf den init abgestimmt wäre, fehlt.&lt;/p&gt;
&lt;p&gt;Zu dem Zeitpunkt, zu dem init gestartet wird, ist das System soeben gebootet worden. Außer dem Root-Dateisystem, das wahrscheinlich nur read-only gemountet ist und möglicherweise beschädigt ist und der Systemkonsole &lt;code&gt;/dev/console&lt;/code&gt; existieren keine weiteren Ressourcen. Außer init laufen keine anderen Prozesse. Swapspace ist noch nicht angemeldet, was zur Folge hat, daß auf Systemen mit nur 4 MB RAM der Speicher schnell knapp werden könnte. Die Aufgabe von init beim Systemstart ist zunächst einmal, die Dateisysteme zu prüfen, gegebenenfalls zu reparieren und sie sowie eventuell vorhandenen Swapspace anzumelden. Durch die zusätzlichen Dateisysteme und den zusätzlichen Speicher versetzt sich das System in die Lage, die zahlreichen Hintergrundprozesse zu starten, die ein vollständig betriebsbereites Linux auszeichnen. Welche Dämonen gestartet sind, wird durch die Konfigurationsdatei von init, die &lt;code&gt;/etc/inittab&lt;/code&gt; festgelegt. Je nach Run-Level des Systems können dies unterschiedliche Prozesse sein.&lt;/p&gt;
&lt;h2 id=&#34;run-levels&#34;&gt;
    &lt;a href=&#34;#run-levels&#34;&gt;
	Run-Levels
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Ein Run-Level ist dabei einfach nur die numerische Bezeichnung (Okay, es gibt auch noch einen Run-Level S) für eine bestimmte Systemkonfiguration. Abhängig vom aktuellen Run-Level werden bestimmte Zeilen der &lt;code&gt;/etc/inittab&lt;/code&gt; gültig oder ungültig und init stoppt oder startet dementsprechend die zugehörigen Prozesse. Die &lt;code&gt;/etc/inittab&lt;/code&gt; definiert gewissermaßen den Soll-Zustand des Systems in einem bestimmten Run-Level: Fehlende Dämon-Prozesse werden von init nachgestartet, überzählige Dämon-Prozesse werden von init gestoppt.&lt;/p&gt;
&lt;p&gt;Über den Ist-Zustand des Systems führt init parallel dazu in der utmp-Datei Buch. Für jede Zeile der &lt;code&gt;/etc/inittab&lt;/code&gt; steht in der utmp-Datei ein &lt;code&gt;struct utmp&lt;/code&gt;-Eintrag, der über den Verbleib des zugehörigen Prozesses Aufschluß gibt. Außerdem führt init über seine Aktionen noch in der wtmp-Datei ein Logbuch. Auch diese Datei besteht aus &lt;code&gt;struct utmp&lt;/code&gt;-Einträgen, aber im Gegensatz zu utmp, die eine feste Länge hat, wird wtmp als Logbuch fortgeschrieben (und muß regelmäßig gekürzt werden). Programme wie &lt;code&gt;who&lt;/code&gt;, &lt;code&gt;w&lt;/code&gt;, &lt;code&gt;finger&lt;/code&gt; oder der &lt;code&gt;rwhod&lt;/code&gt; können die utmp-Datei auswerten und anzeigen, welche Benutzer gerade im System eingeloggt sind oder welche Schnittstellen gerade unbelegt sind. Programme wie &lt;code&gt;last&lt;/code&gt; oder Accountingtools werten dagegen die wtmp-Datei aus und können so ein Logbuch über die vergangenen Logins erzeugen.&lt;/p&gt;
&lt;p&gt;Auf einem richtigen System V kann who nicht nur eine Liste der eingeloggten Benutzer erzeugen, sondern die komplette utmp-Datei analysieren und auch mit der Option -r den aktuellen Run-Level des Systems anzeigen. Im Umfeld der Slackware-Distributionen paßt der &lt;code&gt;who&lt;/code&gt;-Befehl nicht zum init und ihm fehlen diese Optionen, sodaß man auf selbstgeschriebene Programme angewiesen ist.&lt;/p&gt;
&lt;p&gt;init erzwingt nicht, daß bestimmte Run-Level (ausgenommen S) bestimmte Bedeutungen haben. Das Verhalten des Systems richtet sich ausschließlich nach der Konfiguration in der &lt;code&gt;/etc/inittab&lt;/code&gt;. Per Konvention hat diese auf den meisten Distributionen, die von Slackware abstammen, ein bestimmtes Aussehen. &amp;ldquo;Slackware inittab&amp;rdquo; weiter unten zeigt die &lt;code&gt;/etc/inittab&lt;/code&gt; einer Slackware-Installation.&lt;/p&gt;
&lt;p&gt;Eine Zeile der &lt;code&gt;inittab&lt;/code&gt; hat dabei das folgende Format:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;	id:runlevels:action:process
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Die &lt;strong&gt;id&lt;/strong&gt; stellt dabei einen eindeutigen Identifikator für die Zeile der inittab dar. Er muß genau zwei Buchstaben lang sein und taucht später als &lt;code&gt;ut_id&lt;/code&gt;-Feld in demjenigen Eintrag in der utmp-Datei auf, der zu dieser Zeile der inittab gehört. Das, was &lt;code&gt;finger&lt;/code&gt; in der Spalte Tty ausdruckt, ist der Inhalt dieses &lt;code&gt;ut_id&lt;/code&gt;-Feldes aus der utmp-Datei.&lt;/p&gt;
&lt;p&gt;Das Feld &lt;strong&gt;runlevels&lt;/strong&gt; definiert einen oder mehrere Run-Levels, in denen diese Zeile aktiviert sein soll.Wenn der aktuelle Run-Level des Systems hier nicht aufgeführt ist, ist diese Zeile unwirksam: Ein Eintrag im Feld runlevels mit den Ziffern 123 wäre nur in den Run-Levels 1, 2 und 3 gültig.&lt;/p&gt;
&lt;p&gt;Das Feld &lt;strong&gt;process&lt;/strong&gt; definiert dann den Aufruf eines Prozesses mit allen Parametern, wie er von init gestartet werden soll, wenn das System sich in einem der in runlevels genannten Run-Level befindet. Diese Prozesse sind entweder Dämon-Prozesse wie &lt;code&gt;xdm&lt;/code&gt; oder &lt;code&gt;nnmaster&lt;/code&gt;, Login-Prompts wie &lt;code&gt;getty&lt;/code&gt; oder Scripte und Anweisungen, die beim Wechsel des Run-Levels aktiv werden. init überwacht diese Prozesse. Wenn sich einer von ihnen beendet, bemerkt init dies und entscheidet anhand der &lt;strong&gt;action&lt;/strong&gt; darüber, ob der Dämon neu gestartet werden soll oder was sonst zu tun ist.&lt;/p&gt;
&lt;p&gt;Der Abschnitt &amp;ldquo;Das action Feld in der inittab&amp;rdquo; erklärt die Bedeutung der verschiedenen Schlüsselworte.&lt;/p&gt;
&lt;h2 id=&#34;die-rc-scripte&#34;&gt;
    &lt;a href=&#34;#die-rc-scripte&#34;&gt;
	Die rc-Scripte
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Bei der Slackware startet die inittab einige rc-Scripte, genau wie bei den meisten anderen Unices auch. Die Bezeichnung &lt;code&gt;rc&lt;/code&gt; steht dabei für &amp;ldquo;run command&amp;rdquo;. Sie stammt noch aus der Urzeit der Computerentwicklung und wurde von einem der vergessenen Vorläufer von UNIX übernommen. Heute würde man wohl stattdessen das Kürzel &amp;ldquo;BAT&amp;rdquo; verwenden.&lt;/p&gt;
&lt;p&gt;Die Struktur dieser Scripte orientiert sich bei Linux mehr an der wesentlich primitiveren Konfiguration eines BSD-Systems als an einem normalen System V. Mit unserem Wissen über init können wir inzwischen erkennen, daß Linux nach dem Booten wegen des &lt;code&gt;initdefault&lt;/code&gt;-Schlüsselwortes in der inittab den Run-Level 5 ansteuert. Der &lt;code&gt;sysinit&lt;/code&gt;-Eintrag sorgt dann für die Abarbeitung von &lt;code&gt;/etc/rc.d/rc.S&lt;/code&gt;, gefolgt von &lt;code&gt;/etc/rc.d/rc.M&lt;/code&gt;, da der &lt;code&gt;wait&lt;/code&gt;-Eintrag &amp;ldquo;rc&amp;rdquo; den Run-Level 5 enthält. Nachdem init auf das Ende von &lt;code&gt;rc.M&lt;/code&gt; gewartet hat, startet er die &lt;code&gt;getty&lt;/code&gt;-Einträge &lt;code&gt;c2&lt;/code&gt; bis &lt;code&gt;c6&lt;/code&gt; (&lt;code&gt;c1&lt;/code&gt; ist hier auskommentiert) und den &lt;code&gt;nnmaster&lt;/code&gt;. Der Eintrag &lt;code&gt;x1&lt;/code&gt; wird ignoriert, da er nur für den Run-Level 6 gilt.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;/etc/rc.d/rc.S&lt;/code&gt; ist das Script, das als erstes nach dem Systemstart abgearbeitet wird. Es findet den eingangs erwähnten Rechner ohne Dateisysteme und Ressourcen vor und macht sich daran, diesen Zustand zu ändern. Die ersten Handgriffe nach der Definition eines Suchpfades dienen dazu, den Swapspace zu aktivieren: Dazu muß &lt;code&gt;swapon -a&lt;/code&gt; eine gültige &lt;code&gt;/etc/fstab&lt;/code&gt; vorfinden und dort die Swap-Partitionen benannt bekommen. Der &lt;code&gt;update&lt;/code&gt;-Dämon sorgt dann dafür, daß der Speicherinhalt auch gelegentlich auf die Festplatte geschrieben werden. Jetzt ist auch auf Maschinen mit 4 MB RAM genügend Speicher bereitgestellt, um größere Prozesse ablaufen lassen zu können.&lt;/p&gt;
&lt;p&gt;Die folgenden Anweisungen dienen dazu, die Dateisysteme zu prüfen und - falls möglich - das Root-Dateisystem read-write anzumelden. Wenn der &lt;code&gt;fsck&lt;/code&gt; oder der Remount fehlschlagen, druckt das Script Handlungsanweisungen und versucht noch so etwas wie ein Login hinzubekommen. Die folgenden Anweisungen ab Zeile 92 dienen dann dazu, die üblichen Konfigurations- und Statusdateien zu erzeugen, die beim Systemstart aufgefrischt werden müssen und die Systemzeit zu stellen.&lt;/p&gt;
&lt;p&gt;Startet man Linux im &lt;i&gt;single user mode&lt;/i&gt; oder gerät man auf andere Weise auf ein System mit einer read-only angemeldeten Root-Platte, kann man sich behelfen, indem man &lt;code&gt;/etc/rc.d/rc.S&lt;/code&gt; von Hand ausführt. Mit ein wenig Glück bekommt man so ein halbwegs vernünftig konfiguriertes System, bei dem man immerhin soviele Eingriffsmöglichkeiten hat, daß man die verbleibenden Fehler von Hand korrigieren kann. Auch normale UNIX-Versionen haben ähnliche Scripte. Da das Checken und Anmelden der Platten nach dem Systemstart mit die dringlichste Aufgabe ist, findet man den Namen des Scriptes am einfachsten heraus, indem man sich den sysinit-Eintrag der betreffenden &lt;code&gt;/etc/inittab&lt;/code&gt; ansieht. Ein häufige Name für dieses Script ist zum Beispiel &lt;code&gt;bcheckrc&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;/etc/rc.d/rc.M&lt;/code&gt; kümmert sich dann um die Vorbereitung des Systems auf den Mehrbenutzerbetrieb. Dieses Script kann davon ausgehen, daß alle lokalen Platten schon verfügbar sind und daß ausreichend Swapspace zur Verfügung steht. Hostnamen und andere das Netzwerk betreffende Dinge sind aber noch undefiniert. &lt;code&gt;rc.M&lt;/code&gt; konfiguriert einen Screenblanker, startet den &lt;code&gt;cron&lt;/code&gt;, setzt den Hostnamen und verzweigt dann vorübergehend in die Scripte &lt;code&gt;rc.inet1&lt;/code&gt; und &lt;code&gt;rc.inet2&lt;/code&gt;. Ersteres dient dazu, den Kernelteil des Netzwerkes zu konfigurieren: Die Interfaces erhalten ihre IP-Nummern und werden gestartet, danach setzt sich der Kernel Routingtabellen. Das gesamte Script besteht im Prinzip nur aus glorifizierten Aufrufen von &lt;code&gt;ifconfig&lt;/code&gt; und &lt;code&gt;route&lt;/code&gt;. Die zweite Datei konfiguriert dann den Anwendungsteil des Netzes, indem dort die entsprechenden Serverprozesse gestartet werden. Die folgenden Arbeiten in &lt;code&gt;rc.M&lt;/code&gt; erledigen dann einige Aufräumarbeiten, die zu verschiedenen Subsystemen gehören. Wichtig ist hier vor allen Dingen der Aufruf von &lt;code&gt;ldconfig&lt;/code&gt;, der Links auf die aktuellen Versionen der shared libraries auf den neuesten Stand bringt. Am Ende von &lt;code&gt;rc.M&lt;/code&gt; wird dann noch auf &lt;code&gt;rc.local&lt;/code&gt; verzweigt, in der der Systemverwalter lokale Modifikationen des Systemstarts unterbringen kann. Einige Versionen der Slackware verzweigen bei Bedarf noch in andere, spezialisierte rc-Dateien zum Verstellen des Zeichensatzes oder der Tastaturbelegung.&lt;/p&gt;
&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/1995/12/init-files.gif&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;

&lt;/p&gt;
&lt;h2 id=&#34;erweiterungen-der-rc-dateien&#34;&gt;
    &lt;a href=&#34;#erweiterungen-der-rc-dateien&#34;&gt;
	Erweiterungen der rc-Dateien
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Bei der Konstruktion der rc-Dateien, wie sie im Abschnitt &amp;ldquo;Slackware inittab&amp;rdquo; gezeigt wird, ist einzig die Datei &lt;code&gt;rc.local&lt;/code&gt; für lokale Erweiterungen des Bootvorganges vorgesehen. Der Systemverwalter kann hier neben lokalen Anpassungen für Zeichensatz und Tastatur eigene Dämon-Prozesse starten oder den Weg für den Start solcher Prozesse bereiten (indem zum Beispiel alte Lockdateien abgeräumt werden).&lt;/p&gt;
&lt;p&gt;Dabei sollte man auf jeden Fall darauf achten, daß die &lt;code&gt;rc.local&lt;/code&gt;-Datei beendet wird! &lt;code&gt;rc.S&lt;/code&gt; wird als sysinit-Eintrag ausgeführt und &lt;code&gt;rc.local&lt;/code&gt; ist Bestandteil von &lt;code&gt;rc.M&lt;/code&gt; und wird als wait-Eintrag ausgeführt. In beiden Fällen können die folgenden Einträge der inittab erst dann ausgeführt werden, wenn &lt;code&gt;rc.S&lt;/code&gt; bzw. &lt;code&gt;rc.M&lt;/code&gt; beendet sind. Die folgenden Einträge sind aber die &lt;code&gt;getty&lt;/code&gt;-Prozesse für die Systemkonsole (c1-c6), die das Login überhaupt ermöglichen. Wenn ein Fehler in &lt;code&gt;rc.M&lt;/code&gt; also dazu führt, daß sich das Script niemals beendet, kommen niemals Loginprompts und man kann sich nicht anmelden, um den Fehler zu korrigieren.&lt;/p&gt;
&lt;p&gt;Der Fehler tritt zum Beispiel gerne dann auf, wenn man in &lt;code&gt;rc.local&lt;/code&gt; einen Dämon startet (es ist ein Characteristikum von Dämonen, daß sie sich nach Möglichkeit nicht beenden), der sich nicht automatisch selbst in den Hintergrund schiebt. Zum Beispiel schiebt sich der &lt;code&gt;nnmaster&lt;/code&gt;-Aufruf&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;	/usr/lib/nn/nnmaster -l -r -C
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;automatisch in den Hintergrund, während&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;	/usr/lib/nn/nnmaster -f -l -r -C
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;keinen Hintergrundprozeß erzeugt, sondern ausdrücklich im Vordergrund bleibt. In der &lt;code&gt;rc.local&lt;/code&gt; würde nur der erste Aufruf korrekt funktionieren, der zweite würde das System blockieren.&lt;/p&gt;
&lt;p&gt;In der &lt;code&gt;/etc/inittab&lt;/code&gt; im Abschnitt &amp;ldquo;Slackware inittab&amp;rdquo; ist &lt;code&gt;nnmaster&lt;/code&gt; jedoch in der zweiten Variante eingetragen. Wieso ist das hier notwendig? Nun, in der inittab ist &lt;code&gt;nnmaster&lt;/code&gt; als respawn-Eintrag eingetragen: init bewacht den &lt;code&gt;nnmaster&lt;/code&gt; hier und startet ihn neu, falls notwendig. Wäre &lt;code&gt;nnmaster&lt;/code&gt; hier ohne -f eingetragen, würde der Dämon sich in den Hintergrund schieben und der Vordergrundprozeß würde sich gleich wieder beenden. init bemerkt, daß sich der von ihm gestartete Prozeß beendet hat und würde sogleich einen zweiten &lt;code&gt;nnmaster&lt;/code&gt; starten, wie der respawn-Eintrag es befiehlt. Solche Einträge erzeugen dann die Meldung &amp;ldquo;respawning to rapidly&amp;rdquo;.&lt;/p&gt;
&lt;h2 id=&#34;rc-dateien-im-stile-von-system-v&#34;&gt;
    &lt;a href=&#34;#rc-dateien-im-stile-von-system-v&#34;&gt;
	rc-Dateien im Stile von System V
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Das Konzept der &lt;code&gt;rc.local&lt;/code&gt;-Datei ist zwar schön einfach zu verstehen, aber für die automatische Wartung des Systems ist es nicht besonders elegant. In einer kommerziellen Umgebung würde man davon ausgehen, daß die Benutzer des Systems reine Anwender sind und kaum genug Ausbildung haben, um mit der Anwendung selbst klarzukommen. Auch von der Systemverwaltung kann man nicht in jedem Fall verlangen, daß sie zu selbstständigen Änderungen an rc-Dateien in der Lage ist. Das gilt insbesondere dann, wenn diese Änderung den fehlerfreien Wiederanlauf des Systems gefährden kann. Für Anwendungen, die durch schlecht ausgebildete Personen aus vorgefertigen Packages installiert werden sollen, wäre es wünschenswert, wenn ein Mechanismus besteht, durch den sie sich automatisch und weitgehend fehlerfrei in die Programmfolge beim Systemstart einhängen können.&lt;/p&gt;
&lt;p&gt;Ein ähnliches Problem besteht schon seit Jahren im Bereich MS-DOS, wo Installationsprozeduren von Anwendungspaketen Änderungen an der AUTOEXEC.BAT und der CONFIG.SYS vornehmen müssen. Im Bereich MS-DOS löst man dies, indem jede Anwendung einen großen Installator mit sich herumschleppt, der in der Lage ist, solche Konfigurationsdateien zu parsen und zu korrekt verändern (oder auch nicht). Das so etwas schon bei MS-DOS nicht richtig funktioniert, bemerkt der Autor jedesmal an seiner eigenen Konfiguration, die leider nicht linear ist, sondern mehrere Verzweigungen und Aufrufe von Unterbatches enthält. Praktisch alle DOS-Installationsprogramme führen ihre Änderungen an der falschen Stelle oder nur für eine Konfiguration (meistens nicht die aktive) ein. UNIX Shellscripte sind allerdings noch mächtiger als DOS Batchdateien und für ein Installationsprogramm entsprechend schwieriger zu handhaben. Die Wahrscheinlichkeit, daß ein rc-Modifikator eine etwas komplexere &lt;code&gt;rc.local&lt;/code&gt; durch seine Änderungen zerstört sind viel größer als für ein DOS Installationsprogramm.&lt;/p&gt;
&lt;p&gt;In System V UNIX verwendet man deswegen ein etwas anderes Konzept, daß ohne aufwendige Parser auskommt und trotzdem viel sicherer funktioniert. Statt alle Anweisungen in eine einzige Datei zu quetschen, hat man die rc-Datei dort in viele kleine Module zerlegt, von denen sich jedes um einen Aspekt des Systemstartes kümmert. Man hat für jeden Run-Level ein Unterverzeichnis &lt;code&gt;/etc/rcn.d&lt;/code&gt; (wobei n die Nummer des Run-Levels ist). Dort befinden sich die Startdateien für diesen Run-Level. Das Script &lt;code&gt;/etc/rcn&lt;/code&gt; (wieder ist n der Run-Level) ist für jeden Run-Level gleich und führt nacheinander alle Dateien im zum Run-Level gehörenden Unterverzeichnis aus.&lt;/p&gt;
&lt;p&gt;Per Konvention haben alle Dateien im Unterverzeichnis entweder den Namen KxyNAME oder SxyNAME. Eine K-Datei dient dazu, irgendeinen Dienst beim Betreten des Run-Levels zu stoppen, eine S-Datei dient dazu, einen Dienst zu starten. Die Ziffern xy laufen von 00 bis 99 durch und dienen dazu, eine alphabethische Reihenfolge der Script zu definieren: Das Script führt die einzelnen Module in der Reihenfolge K00 bis K99 und dann S00 bis S99 aus. Es ruft K-Scripte mit dem Parameter &lt;code&gt;stop&lt;/code&gt; auf, S-Scripte werden mit dem Parameter &lt;code&gt;start&lt;/code&gt; aufgerufen. Der Bestandteil NAME dient zur Identifikation des Scriptes und bezeichnet das Subsystem, das durch das Script gestartet oder gestoppt wird.&lt;/p&gt;
&lt;p&gt;Ein Programmpaket kann bei dieser Konstruktion ganz leicht eingefügt werden. Nehmen wir an, ein hypothetischer FAX-Server &lt;code&gt;kfax&lt;/code&gt; braucht beim Systemstart einige Anweisungen, um einen Dämon-Prozeß zu starten und ein wenig aufzuräumen. Das Installationspaket könnte eine Datei mit den benötigten Anweisungen erzeugen und sie als &lt;code&gt;/etc/init.d/kfax&lt;/code&gt; in einem Sammelverzeichnis für alle Startscripte installieren. Das Modul soll beim Betreten von Run-Level 5 getstartet werden. Also erzeugt die Installationsprozedur ein Symlink von &lt;code&gt;/etc/rc5.d/S99kfax&lt;/code&gt; nach &lt;code&gt;/etc/init.d/kfax&lt;/code&gt;. Die Installation braucht also nur eine Datei zu erzeugen und ein Link zu legen, um ihr Modul in die rc-Scripte zu integrieren. Soll das Script in mehr als einem Run-Level aktiviert werden, wird es auch von den anderen &lt;code&gt;/etc/rcn.d&lt;/code&gt;-Verzeichnissen nach &lt;code&gt;/etc/init.d&lt;/code&gt; gelinkt. Lesen und Verstehen von &lt;code&gt;rc.local&lt;/code&gt; oder anderen Scripten ist nicht notwendig. Die Deinstallationsanweisung ist genauso simpel: &amp;ldquo;Löschen Sie die Datei &lt;code&gt;/etc/rc5.d/S99kfax&lt;/code&gt; und starten Sie das System neu.&amp;rdquo;&lt;/p&gt;
&lt;p&gt;Beim Wechsel in den Run-Level 5 wird unser Beispielsystem das Script &lt;code&gt;/etc/rc5&lt;/code&gt; durch einen once-Eintrag aktivieren. Das Script geht alle Dateien in &lt;code&gt;/etc/rc5.d&lt;/code&gt; durch und führt sie der Reihe nach aus. Es wird zunächst alle &lt;code&gt;/etc/rc.d/K*&lt;/code&gt;-Dateien mit dem Parameter &lt;code&gt;stop&lt;/code&gt; aufrufen, danach wird es alle &lt;code&gt;/etc/rc.d/S*&lt;/code&gt;-Dateien mit dem Parameter &lt;code&gt;start&lt;/code&gt; aufrufen. Ganz am Schluss wird &lt;code&gt;S99kfax start&lt;/code&gt; ausgeführt.&lt;/p&gt;
&lt;p&gt;Das folgende Listing zeigt den inittab-Eintrag und ein Listing von &lt;code&gt;/etc/rc5&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&#34;system-v-startscript-etcrc5&#34;&gt;
    &lt;a href=&#34;#system-v-startscript-etcrc5&#34;&gt;
	System V Startscript &lt;code&gt;/etc/rc5&lt;/code&gt;
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Der Eintrag in der &lt;code&gt;/etc/inittab&lt;/code&gt;:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;r5:5:once:/etc/rc5
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Das zugehörige Script:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# /bin/sh --&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;#	Das Script wird ausgefuehrt, wenn das System in den &lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;#	Run-Level 5 wechselt.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;#&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;#	Fuer die anderen Run-Levels sollten &lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;#   analoge Eintraege und Scripte existieren.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nv&#34;&gt;PATH&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;/bin:/sbin:/usr/sbin:/usr/bin
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt; -d /etc/rc5.d &lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;then&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;c1&#34;&gt;# Ausfuehren der Stopscripte&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nv&#34;&gt;MODE&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;stop
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; f in /etc/rc5.d/K*
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;do&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt; -x &lt;span class=&#34;si&#34;&gt;${&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;k&#34;&gt;then&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;			/sbin/sh &lt;span class=&#34;si&#34;&gt;${&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt; stop
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;k&#34;&gt;else&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;			. &lt;span class=&#34;si&#34;&gt;${&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;k&#34;&gt;fi&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;done&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;c1&#34;&gt;# Ausfuehren der Startscripte&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nv&#34;&gt;MODE&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;start
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; f in /etc/rc3.d/S*
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;do&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt; -x &lt;span class=&#34;si&#34;&gt;${&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;k&#34;&gt;then&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;			/sbin/sh &lt;span class=&#34;si&#34;&gt;${&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt; start
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;k&#34;&gt;else&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;			. &lt;span class=&#34;si&#34;&gt;${&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;k&#34;&gt;fi&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;done&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;fi&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;slackware-inittab&#34;&gt;
    &lt;a href=&#34;#slackware-inittab&#34;&gt;
	Slackware inittab
    &lt;/a&gt;
&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#
# inittab       This file describes how the INIT process should set up
#               the system in a certain Run-Level.
#
# Version:      @(#)inittab             2.04    17/05/93        MvS
#
# Author:       Miquel van Smoorenburg, &amp;lt;miquels@drinkel.nl.mugnet.org&amp;gt;
#
# Default runlevel.
id:5:initdefault:

# System initialization (runs when system boots).
si:S:sysinit:/etc/rc.d/rc.S

# Script to run when going single user.
su:S:wait:/etc/rc.d/rc.K

# Script to run when going multi user.
rc:123456:wait:/etc/rc.d/rc.M

# What to do at the &amp;#34;Three Finger Salute&amp;#34;.
ca::ctrlaltdel:/sbin/shutdown -t3 -rf now

# What to do when power fails (shutdown to single user).
pf::powerfail:/sbin/shutdown -f +5 &amp;#34;THE POWER IS FAILING&amp;#34;

# If power is back before shutdown, cancel the running shutdown.
pg:0123456:powerokwait:/sbin/shutdown -c &amp;#34;THE POWER IS BACK&amp;#34;

# If power comes back in single user mode, return to multi user mode.
ps:S:powerokwait:/sbin/init 5

# The getties in multi user mode on consoles an serial lines.
#
# NOTE NOTE NOTE adjust this to your getty or you will not be
#                able to login !!
#
# Note: for &amp;#39;agetty&amp;#39; you use linespeed, line.
# for &amp;#39;getty_ps&amp;#39; you use line, linespeed and also use &amp;#39;gettydefs&amp;#39;
#c1:12345:respawn:/sbin/agetty 38400 tty1
c2:12345:respawn:/sbin/agetty 38400 tty2
c3:12345:respawn:/sbin/agetty 38400 tty3
c4:45:respawn:/sbin/agetty 38400 tty4
c5:45:respawn:/sbin/agetty 38400 tty5
c6:456:respawn:/sbin/agetty 38400 tty6

# nn
nn:23456:respawn:/usr/lib/nn/nnmaster -f -l -r -C

# Serial lines
#s1:45:respawn:/sbin/agetty 19200 ttyS0
#s2:45:respawn:/sbin/agetty 19200 ttyS1

# Dialup lines
#d1:45:respawn:/sbin/agetty -mt60 38400,19200,9600,2400,1200 ttyS0
#d2:45:respawn:/sbin/agetty -mt60 38400,19200,9600,2400,1200 ttyS1

# Runlevel 6 used to be for an X-window only system, until we discovered
# that it throws init into a loop that keeps your load avg at least 1 all 
# the time. Thus, there is now one getty opened on tty6. Hopefully no one
# will notice. ;^)
# It might not be bad to have one text console anyway, in case something 
# happens to X.
x1:6:wait:/etc/rc.d/rc.6

# End of /etc/inittab
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;das-action-feld-in-der-etcinittab&#34;&gt;
    &lt;a href=&#34;#das-action-feld-in-der-etcinittab&#34;&gt;
	Das Action Feld in der &lt;code&gt;/etc/inittab&lt;/code&gt;
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Das Feld &lt;code&gt;action&lt;/code&gt; in der &lt;code&gt;inittab&lt;/code&gt; bestimmt, wie &lt;code&gt;init&lt;/code&gt; mit dem im Feld &lt;strong&gt;process&lt;/strong&gt; genannten Prozeß verfährt. &lt;code&gt;sysvinit&lt;/code&gt; kennt dieselben Schlüsselworte wie ein richtiger &lt;code&gt;init&lt;/code&gt; eines originalen System V UNIX plus einige eigene Schlüsselworte, die spezifisch für Linux sind.&lt;/p&gt;
&lt;h3 id=&#34;start-und-restart-von-prozessen&#34;&gt;
    &lt;a href=&#34;#start-und-restart-von-prozessen&#34;&gt;
	Start und Restart von Prozessen
    &lt;/a&gt;
&lt;/h3&gt;
&lt;dl&gt;
&lt;dt&gt;off:&lt;/dt&gt;
&lt;dd&gt;Zeilen, die als &lt;code&gt;off&lt;/code&gt; gekennzeichnet sind, sind inaktiv. Dies stellt eine gute Methode dar, um Einträge in der &lt;code&gt;inittab&lt;/code&gt; vorübergehend außer Betrieb zu nehmen. Natürlich könnte man sie auch in Kommentarzeilen verwandeln, indem man an den Anfang der Zeile ein &amp;ldquo;#&amp;rdquo; setzt.&lt;/dd&gt;
&lt;dt&gt;respawn:&lt;/dt&gt;
&lt;dd&gt;Dies ist der häufigste Eintrag, wie er für &lt;code&gt;getty&lt;/code&gt;s und für Dämon-Prozesse verwendet wird, die automatisch neu gestartet werden sollen. Wenn sich ein so gekennzeichneter Eintrag beendet, versucht &lt;code&gt;init&lt;/code&gt; den Prozeß erneut zu starten. Kommt es dabei zu einer Endlosschleife (der Prozeß beendet sich aufgrund eines Fehlers sofort wieder, &lt;code&gt;init&lt;/code&gt; startet ihn sofort wieder neu&amp;hellip;), erkennt &lt;code&gt;init&lt;/code&gt; dies und legt den Eintrag für einige Minuten mit der Meldung &amp;ldquo;process respawning too rapidly&amp;rdquo; still.&lt;/dd&gt;
&lt;dt&gt;initdefault:&lt;/dt&gt;
&lt;dd&gt;Der &lt;code&gt;initdefault&lt;/code&gt;-Eintrag hat in gewisser Weise eine Sonderrolle: Er spezifiziert keinen Prozeß, sondern sein &lt;code&gt;runlevel&lt;/code&gt;-Feld gibt an, in welchen Run-Level sich das System beim Systemstart begeben soll. Fehlt dieser Eintrag, wird der gewünschte Run-Level beim Booten an der Console erfragt.&lt;/dd&gt;
&lt;dt&gt;wait:&lt;/dt&gt;
&lt;dd&gt;Mit wait gekennzeichnete Prozesse werden von &lt;code&gt;init&lt;/code&gt; einmal beim Betreten des Run-Levels gestartet. &lt;code&gt;init&lt;/code&gt; wartet dann darauf, daß der entsprechende Prozeß sich wieder beendet, bevor der nächste Eintrag abgearbeitet wird. Da &lt;code&gt;init&lt;/code&gt; die Einträge einer &lt;code&gt;inittab&lt;/code&gt; von oben nach unten abarbeitet, kann man so eine kontrollierte Folge von Scripten beim Erreichen eines Run-Levels starten.&lt;/dd&gt;
&lt;dt&gt;once:&lt;/dt&gt;
&lt;dd&gt;Mit &lt;code&gt;once&lt;/code&gt; gekennzeichnete Prozesse werden von &lt;code&gt;init&lt;/code&gt; einmal beim Betreten des Run-Levels gestartet. Im Gegensatz zur Aktion &lt;code&gt;wait&lt;/code&gt; wartet &lt;code&gt;init&lt;/code&gt; hier aber nicht auf das Ende des Prozesses, bevor der nächste Eintrag der &lt;code&gt;inittab&lt;/code&gt; abgearbeitet wird. &lt;code&gt;once&lt;/code&gt; wird normalerweise verwendet, um einen Dämon zu starten ohne in wie bei &lt;code&gt;respawn&lt;/code&gt; bewachen zu lassen. Sollte der Dämon sich beenden, wird eben kein neuer Prozeß gestartet. In System V UNIX wird &lt;code&gt;once&lt;/code&gt; verwendet, um die &lt;code&gt;/etc/rcn&lt;/code&gt;-Scripte zu starten.&lt;/dd&gt;
&lt;/dl&gt;
&lt;h3 id=&#34;boot&#34;&gt;
    &lt;a href=&#34;#boot&#34;&gt;
	Boot
    &lt;/a&gt;
&lt;/h3&gt;
&lt;p&gt;Weil &lt;code&gt;init&lt;/code&gt; als allererster Prozeß im System gestartet wird, muß es Einträge gegeben, die spezifizieren, wie das System ans Laufen gebracht wird. Bei diesen Einträgen wird das Feld &lt;strong&gt;runlevels&lt;/strong&gt; ignoriert. Sie werden beim Start des Systems schlicht von oben nach unten abgearbeitet.&lt;/p&gt;
&lt;dl&gt;
&lt;dt&gt;sysinit:&lt;/dt&gt;
&lt;dd&gt;Die ersten Prozesse der Bootphase werden durch die &lt;code&gt;sysinit&lt;/code&gt;-Einträge bestimmt. Es handelt sich meistens um Scripte, deren Aufgabe es ist, die Platten zu checken und sie read-write anzumelden.&lt;/dd&gt;
&lt;dt&gt;boot:&lt;/dt&gt;
&lt;dd&gt;Nach den &lt;code&gt;sysinit&lt;/code&gt;-Scripten folgen dann die anderen Scripte der Bootphase.&lt;/dd&gt;
&lt;dt&gt;bootwait:&lt;/dt&gt;
&lt;dd&gt;Bei &lt;code&gt;bootwait&lt;/code&gt;-Einträgen wartet das System mit dem Starten des Folgeeintrags solange, bis der aktuelle Eintrag abgearbeitet ist. Bei &lt;code&gt;boot&lt;/code&gt;-Einträgen wird dagegen nicht gewartet.&lt;/dd&gt;
&lt;/dl&gt;
&lt;h3 id=&#34;speziell-für-linux&#34;&gt;
    &lt;a href=&#34;#speziell-f%c3%bcr-linux&#34;&gt;
	Speziell für Linux
    &lt;/a&gt;
&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;sysvinit&lt;/code&gt; von Linux hat außerdem noch einige Nichtstandard-Aktionen. Sie dienen hauptsächlich der Unterstützung von USVs und zumAbfangen der Tastenkombination Control-Alt-Delete.&lt;/p&gt;
&lt;dl&gt;
&lt;dt&gt;ctrlaltdel:&lt;/dt&gt;
&lt;dd&gt;Bei diesem Eintrag wird das Feld &lt;strong&gt;runlevels&lt;/strong&gt; ebenfalls ignoriert. Er wird aktiviert, wenn jemand an der Console die Tastenkombination Control-Alt-Delete gedrückt hat. Normalerweise wird man hier entweder das System herunterfahren oder in den single user mode wechseln.&lt;/dd&gt;
&lt;dt&gt;powerwait:&lt;/dt&gt;
&lt;dt&gt;powerfail:&lt;/dt&gt;
&lt;dd&gt;Einträge mit der Aktion &lt;code&gt;powerwait&lt;/code&gt; oder &lt;code&gt;powerfail&lt;/code&gt; werden aktiviert, wenn das System ein SIGPWR Signal erhält. Dies ist typischerweise ein Signal, das vom Kernel generiert wird, wenn die Stromversorgung des Systems zusammenbricht und die USV übernimmt. Bei &lt;code&gt;powerwait&lt;/code&gt;-Einträgen wartet &lt;code&gt;init&lt;/code&gt; wieder auf das Ende eines Eintrages, bevor der nächste abgearbeitet wird, während dies bei &lt;code&gt;powerfail&lt;/code&gt;-Einträgen nicht geschieht.&lt;/dd&gt;
&lt;dt&gt;powerokwait:&lt;/dt&gt;
&lt;dd&gt;Dieser Eintrag wird aktiviert, wenn ein SIGPWR auftritt und die Datei &lt;code&gt;/etc/powerstatus&lt;/code&gt; das Wort OK enthält. Sollte die Stromversorgung wieder funktionieren, bevor das System sich auf Grund des ersten SIGPWR abgeschaltet hat, kann durch einen Eintrag hier die Abschaltung verhindert werden.&lt;/dd&gt;
&lt;dt&gt;ondemand:&lt;/dt&gt;
&lt;dd&gt;Ein Eintrag mit der Bezeichnung ondemand funktioniert ähnlich wie ein Eintrag &lt;code&gt;once&lt;/code&gt;. Während ein &lt;code&gt;once&lt;/code&gt;-Eintrag jedoch nur beim Betreten eines Run-Levels aktiviert wird, wird ein &lt;code&gt;ondemand&lt;/code&gt;-Eintrag auch dann aktiviert, wenn das System in den Run-Level wechseln soll, in dem es sich sowieso schon befindet.&lt;/dd&gt;
&lt;/dl&gt;
</description>
    </item>
    
    <item>
      <title>UNIX Dateisysteme</title>
      <link>https://blog.koehntopp.info/1994/02/01/dateisysteme.html</link>
      <pubDate>Tue, 01 Feb 1994 09:00:00 +0000</pubDate>
      
      <guid>https://blog.koehntopp.info/1994/02/01/dateisysteme.html</guid>
      <description>&lt;h1 id=&#34;unix-dateisysteme&#34;&gt;
    &lt;a href=&#34;#unix-dateisysteme&#34;&gt;
	UNIX Dateisysteme
    &lt;/a&gt;
&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;aus »c&amp;rsquo;t - Magazin für Computertechnik«, Ausgabe 2/94&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;die-aufgaben-eines-betriebssystems-bestehen-in-der-fairen-zuteilung-der-systemressourcen-an-alle-bewerber-und-in-der-abstraktion-unterschiedlichster-hardware-zu-einer-virtuellen-maschine-für-den-bereich-der-plattenplatzverwaltung-hat-diese-aufgabe-das-dateisystem-unix-dateisysteme-haben-eine-mehr-als-zwanzigjähirge-entwicklung-hinter-sich-und-dienten-als-vorbild-für-die-dateisysteme-vieler-anderer-betriebssysteme-1-trotz-vieler-mängel-der-ursprünglichen-implementation-haben-sich-die-dahinter-stehenden-ideen-in-den-letzten-zwanzig-jahren-nicht-wesentlich-verändert&#34;&gt;
    &lt;a href=&#34;#die-aufgaben-eines-betriebssystems-bestehen-in-der-fairen-zuteilung-der-systemressourcen-an-alle-bewerber-und-in-der-abstraktion-unterschiedlichster-hardware-zu-einer-virtuellen-maschine-f%c3%bcr-den-bereich-der-plattenplatzverwaltung-hat-diese-aufgabe-das-dateisystem-unix-dateisysteme-haben-eine-mehr-als-zwanzigj%c3%a4hirge-entwicklung-hinter-sich-und-dienten-als-vorbild-f%c3%bcr-die-dateisysteme-vieler-anderer-betriebssysteme-1-trotz-vieler-m%c3%a4ngel-der-urspr%c3%bcnglichen-implementation-haben-sich-die-dahinter-stehenden-ideen-in-den-letzten-zwanzig-jahren-nicht-wesentlich-ver%c3%a4ndert&#34;&gt;
	Die Aufgaben eines Betriebssystems bestehen in der fairen Zuteilung der Systemressourcen an alle Bewerber und in der Abstraktion unterschiedlichster Hardware zu einer virtuellen Maschine. Für den Bereich der Plattenplatzverwaltung hat diese Aufgabe das Dateisystem. UNIX Dateisysteme haben eine mehr als zwanzigjähirge Entwicklung hinter sich und dienten als Vorbild für die Dateisysteme vieler anderer Betriebssysteme [1]. Trotz vieler Mängel der ursprünglichen Implementation haben sich die dahinter stehenden Ideen in den letzten zwanzig Jahren nicht wesentlich verändert.
    &lt;/a&gt;
&lt;/h4&gt;
&lt;h2 id=&#34;daten-wiederfinden&#34;&gt;
    &lt;a href=&#34;#daten-wiederfinden&#34;&gt;
	Daten wiederfinden
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;UNIX schlägt sich auf den höheren Ebenen des Betriebssystems nicht  mit Angaben zur Plattengeometrie herum.
Es betrachtet eine Festplatte als ein langes Band von Plattenblöcken, die linear durchnummeriert sind.
Die Umrechnung von linearen Blockadressen in Angaben von Zylinder, Kopf und Sektor ist entweder Aufgabe eines Festplattengerätetreibers oder - im Fall von SCSI - der Festplatte selbst.
Die ersten paar Datenblöcke einer Festplatte sind reserviert für den Bootloader und ähnliche Dinge, die vor dem Betriebssystem geladen werden und deshalb außerhalb seiner Reichweite gelagert werden.
Der Rest der Platte  wird in Form eines Dateisystems verwaltet.
UNIX operiert bei Dateisystemen mit der Blockgröße des Mediums.
Anders als bei DOS werden die Verwaltungseinheiten auf einer Platte also nicht größer, wenn man sehr große Partitionen anlegt.&lt;/p&gt;
&lt;p&gt;Den Anfang eines Dateisystems bildet der sogenannte Superblock, der das Dateisystem selbst beschreibt.
Er enthält Geometriedaten der Platte, gibt an, wie viele Blöcke das Dateisystem enthält und welche davon Verwaltungsinformationen und welche Daten enthalten.&lt;/p&gt;
&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/1994/02/disklayout.gif&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;

&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Bild 1: Am Anfang des Dateisystems steht der Superblock. Er enthält alle Metainformationen, die das Dateisystem beschreiben. Der &amp;ldquo;vordere&amp;rdquo; Teil des Dateisystems enthält I-Nodes, Dateiköpfe, die alle Metainformationenen über eine Datei speichern. In den Datenblöcken sind dann die eigentlichen Nutzdaten untergebracht. Das Bild zeigt eine I-Node mit ihren Verweisen auf die Datenblöcke der Datei.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Die Basis der Dateiverwaltung bildet in UNIX eine Datenstruktur, die sogenannte &lt;em&gt;index node&lt;/em&gt; oder I-Node (Bild 2).&lt;/p&gt;
&lt;p&gt;In ihr sind - mit einer Ausnahme, dem Dateinamen - alle wesentlichen Informationen über eine Datei gesammelt.
Für jede Datei, jedes Verzeichnis und jedes Gerät legt UNIX eine I-Node an, in der es alles vermerkt, was es über dieses Datenobjekt weiß.
Dazu gehören zum einen Informationen über Zugriffsrechte, Dateieigentümer und Zeitmarken, zum anderen Verweise auf die Datenblöcke, die die Daten der Datei enthalten.
Ursprünglich hat UNIX die I-Nodes eines Dateisystems in Form einer Tabelle zusammengefasst und am Anfang des Dateisystems untergebracht.&lt;/p&gt;
&lt;p&gt;Die Größe dieser Tabelle muss schon beim Anlegen des Dateisystems festgelegt werden, d.h. ein Systemverwalter auf einem UNIX-Rechner muss beim Formatieren einer Platte festlegen, wie viele Dateien später einmal maximal auf dieser Platte angelegt werden können.
Üblicherweise berechnet man mindestens eine I-Node für jeweils 4 KB zur Verfügung stehenden Plattenplatz, sodass auf einer 200 MB Festplatte in etwa 50 000 I-Nodes angelegt werden.
Zum Glück sind I-Nodes relativ kleine Datenstrukturen von nur 128 Bytes.
Im Schnitt verschwinden also auf diese Weise 3 % des gesamten Plattenplatzes in Verwaltungsinformationen.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;struct  dinode
{
/*	Typ     Feldname          Byte-Offset: Beschreibung */
	u_short ino_mode;        /*  0: Dateityp und Zugriffsrechte */
	short   ino_nlink;       /*  2: Anzahl der Namen der Datei  */
        uid_t   ino_uid;         /*  4: Benutzernummer Dateieigentümer */
	gid_t   ino_gid;         /*  6: Gruppennummer Dateieigentümer */
	off_t   ino_size;        /*  8: Größe in Bytes */
	time_t  ino_atime;       /* 16: Zeit des letzten Lesezugriffs */
	long    ino_atspare;     /*     in Sekunden seit 1.1.1970, 0 Uhr */
	time_t  ino_mtime;       /* 24: Zeit des letzten Schreibzugriffs */
	long    ino_mtspare;
	time_t  ino_ctime;       /* 32: Zeit der letzten Statusänderung */
	long    ino_ctspare;
        daddr_t ino_db[NDADDR];  /* 40: Blocknummern der ersten 12 Datenblöcke */
        daddr_t ino_ib[NIADDR];  /* 88: Blocknummern der 3 indirekten Datenblöcke */
        long    ino_blocks;      /* 100: Größe der Datei in Blöcken */
        long    ino_gen;         /* 104: Generationsnummer (NFS) */
};
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;em&gt;Bild 2: Aufbau einer I-Node eines modernen UNIX-Dateisystems. Die Datenstruktur paßt in ein Feld von 128 Bytes, sodas ein Hardware-Plattenblock 8 I-Nodes halten kann. Sie enthält alle Metainformationen über eine Datei mit Ausnahme der Namen der Datei.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Untersucht man die durchschnittliche Länge von Dateien in einem Dateisystem, dann stellt man fest, das kurze Dateien relativ häufig auftreten.
Daher versucht UNIX, die Blocknummern der ersten paar Plattenblöcke einer Datei direkt in der I-Node zu speichern.
In der I-Node aus Bild 2 werden die ersten 12 Datenblöcke einer Datei im Feld &lt;code&gt;ino_db[]&lt;/code&gt; abgelegt.
Wenn über ihre I-Nodenummer auf diese Datei zugegriffen wird, stehen die 12 direkten Datenblöcke der Datei also ohne weitere Leseoperation zur Verfügung.&lt;/p&gt;
&lt;p&gt;Für große Dateien ist dieses Verfahren natürlich nicht praktikabel, denn die I-Node würde dann sehr groß werden.
Wächst eine Datei über die Größe von 12 Datenblöcken hinaus, besorgt UNIX einen freien Datenblock und trägt diesen als ersten indirekten Datenblock einer Datei ein.
In diesem indirekten Datenblock werden jetzt die Blocknummern der weiteren Datenblöcke einer Datei abgelegt.
Bei einer angenommenen Blockgröße von einem Kilobyte können in einem indirekten Block 256 Blocknummern gespeichert werden, von denen jede einen Datenblock von einem Kilobyte adressiert.
Zusammen mit den direkten Datenblöcken können also Dateien bis zu einer Größe von 266 KB angelegt werden, ohne daß mehr als eine Ebene der Indirektion durchlaufen werden muss.
Modernere Dateisysteme, die mit einer Blockgröße von 8 Kilobyte arbeiten, bringen 2048 Blocknummern in einem Block unter und können so bis zu 16 Megabyte große Dateien mit einem einzigen indirekten Block verwalten.&lt;/p&gt;
&lt;p&gt;Für noch größere Dateien sieht UNIX doppelt indirekte Blöcke vor, die die Blocknummern von einfach indirekten Blöcken enthalten.
Diese wiederum zeigen dann endlich auf die Daten.
Bei einer Blockgröße von 8 KB kann man mit diesem Schema schon mehr als die vier Gigabyte verwalten, die sich im Größenfeld &lt;code&gt;ino_size&lt;/code&gt; einer I-Node verwalten lassen.
Bei Dateisystemen mit einer Blockgröße von einem Kilobyte muss dagegen ab einer Dateigröße von 64 MB von einem dreifach indirekten Block Gebrauch gemacht werden (Bild 3).
Zum Glück sind zum Laden eines solchen Datenblockes aber keine vier Plattenzugriffe notwendig, denn alle UNIX-Versionen haben einen Plattencache, der häufig benötigte Daten im RAM präsent hält.&lt;/p&gt;
&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/1994/02/filestructure.gif&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;

&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Bild 3: Von der I-Node zu den Datenblöcken einer Datei&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Bei der Belegung von Plattenblöcken für eine Datei ist UNIX sehr effizient.
Nur diejenigen Blöcke einer Datei, die schon einmal beschrieben wurden, belegen auch wirklich Platz auf der Platte.
Wird beispielsweise begonnen, einen doppelt indirekten Block zu verwenden, so wird für diesen zunächst der erste einfach indirekte Block beschafft und belegt.
Die Blocknummern der anderen indirekten Blöcke werden dagegen einfach auf Null gesetzt.&lt;/p&gt;
&lt;p&gt;Das führt zu interessanten Effekten bei Dateien, die nicht durchgehend beschrieben werden:
Legt man unter UNIX eine neue Datei an und bewegt dann den Dateizeiger irgendwo in die oberen Megabytes, um dort ein einziges Byte zu beschreiben, dann wird nur der eine Datenblock belegt, der notwendig ist, um dieses Byte zu speichern (plus der möglicherweise notwendigen indirekten Blöcke, die notwendig sind, um den Block zu erreichen).
Die Blocknummer aller anderen nicht verwendeten Blöcke bleiben auf Null stehen und es werden auch keine Datenblöcke zwischen dem gespeicherten Byte und dem Dateianfang angefordert.
Es entsteht eine Datei, die in der Verzeichnisausgabe viele Megabytes groß erscheint, in Wirklichkeit aber nur wenige Kilobytes belegt.
Eine solche Datei nennt man in UNIX eine dünn besetzte Datei (sparse file).
Beim Lesen einer solchen Datei werden für die nicht vorhandenen Blöcke entsprechend viele Nullbytes zurückgemeldet.&lt;/p&gt;
&lt;p&gt;Das kann beim Kopieren oder Sichern solcher Dateien natürlich zu seltsamen Effekten führen, wenn man nicht aufpasst:
Beim naiven Kopieren wird eine Datei von vorne nach hinten durchgelesen und die gelesenen Daten werden in die Zieldatei geschrieben.
Während eine dünn besetzte Quelldatei also möglicherweise nur wenige Blöcke wirklich belegt, wird die Zieldatei von vorne nach hinten beschrieben und belegt dann wirklich so viel Platz, wie im Verzeichnis angegeben.
Dateien, die ein Abbild eines häufig ebenfalls dünn besetzten Prozessadressraumes darstellen, sind oft sparse files:
Die shared libraries in einem Linux-System oder Speicherabzüge von gecrashten Programmen unter SunOS sollten tunlichst nicht naiv kopiert werden.&lt;/p&gt;
&lt;h2 id=&#34;dateinamen&#34;&gt;
    &lt;a href=&#34;#dateinamen&#34;&gt;
	Dateinamen
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Die I-Node enthält gesammelt alle Informationen, die UNIX über eine  Datei hat, mit einer Ausnahme: dem Dateinamen.
Dateinamen speichert UNIX in besonderen Dateien, den Verzeichnissen.
Ein Verzeichnis ist n jeder Hinsicht eine normale Datei mit einer I-Node, Datenblöcken und so weiter.
Verzeichnisdateien werden jedoch nicht von Benutzerprogrammen, sondern ausschließlich vom Betriebssystem verwaltet.
Es unterhält in einem Verzeichnis eine feste Satzstruktur.&lt;/p&gt;
&lt;p&gt;Beim älteren UNIX-Dateisystem ist diese sehr einfach aufgebaut:
Ein Verzeichnis besteht aus Datensätzen zu 16 Byte Länge.
Die ersten 2 Byte enthalten die I-Nodenummer einer Datei, die folgenden 14 Byte nehmen einen Dateinamen auf.
Falls ein Dateiname kürzer als 14 Zeichen ist, wird er einfach mit Nullbytes aufgefüllt.
Bei moderneren UNIX-Systemen ist die Verzeichnisstruktur etwas komplizierter, um 4 Byte lange I-Nodenummern und bis zu 255 Byte lange Dateinamen ohne große Platzverschwendung verwalten zu können, aber im Prinzip handelt es sich immer noch um eine einfache Zuordnung von Name zu I-Nodenummer.&lt;/p&gt;
&lt;p&gt;Es ist in UNIX ohne weiteres möglich, mehr als einen Dateinamen für eine Datei zu vergeben.
Dazu wird einfach mit der Systemfunktion link() in einem weiteren Verzeichnis ein Namenseintrag gemacht, der dieselbe I-Nodenummer hat wie der erste Name der Datei.
Im Feld &lt;code&gt;ino_nlink&lt;/code&gt; einer I-Node wird die Anzahl der Namen einer Datei gezählt.
Beide Namen einer Datei sind gleichberechtigt und nicht voneinander zu unterscheiden:
Man kann nicht sagen, welcher von zwei Namen einer Datei der erste und welcher der zweite Name der Datei war.
Anstatt eine Datei zu löschen, kann man in UNIX nur die Anzahl ihrer Namen um Eins vermindern.
Sobald die Anzahl der Namen einer Datei Null wird, gibt das Betriebssystem dem Plattenplatz frei, der zu einer Datei gehört.&lt;/p&gt;
&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/1994/02/verzeichnis.gif&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;


&lt;em&gt;Bild 4: Das alte System V UNIX Dateisystem behandelt Verzeichnisse als gewöhnliche Dateien mit einer festen Satzstruktur von 16 Byte. Die ersten beiden Byte enthalten die I-Node Nummer einer Datei, die folgenden 14 Bytes stellen den Namen der Datei (mit Nullbytes aufgefüllt) dar.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Im BSD Dateisystem sind längere Dateinamen erlaubt. Um die Platzverschwendung zu minimieren, ist die Struktur eines Verzeichnisses etwas komplizierter, aber das Prinzip der Zuordnung eines Namens zu einer
I-Nodenummer wird nicht verletzt.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Um eine Datei zu öffnen, muß ihr Name in eine I-Nodenummer übersetzt werden.
Nach dem Öffnen der Datei arbeitet das Betriebssystem dann intern ausschließlich mit der I-Nodenummer weiter.
Die Übersetzung von Namen in Nodenummern wird in UNIX an einer zentralen Stelle im Betriebssystemkern abgehandelt, in der Kern-internen Funktion &lt;code&gt;namei()&lt;/code&gt;.
Für jeden Prozess verwaltet UNIX in der Prozessstruktur zwei Einträge, in denen die I-Nodenummer des Hauptverzeichnisses und des aktuellen Verzeichnisses dieses Prozesses hinterlegt sind.
Wenn dem Betriebssystem in einem Systemaufruf ein Pfadname übermittelt wird, wird zunächst geprüft, ob es sich um einen absoluten oder relativen Pfadnamen handelt.
Je nachdem, ob der Pfadname mit einem führenden &amp;ldquo;&lt;code&gt;/&lt;/code&gt;&amp;rdquo; beginnt, wird entweder im Hauptverzeichnis oder im aktuellen Verzeichnis des Prozesses begonnen, den Pfadnamen aufzulösen.
&lt;code&gt;namei()&lt;/code&gt; isoliert dazu die erste Komponente des Pfadnamens und sucht diese im Startverzeichnis der Suche.
Sobald der gesuchte Namenseintrag dort gefunden ist, kann die zugehörige I-Nodenummer abgelesen werden und das nächste Stück des Pfadnamens aufgelöst werden.&lt;/p&gt;
&lt;p&gt;In Bild 5 ist zu sehen, was bei der Auflösung eines Pfadnamens wie &amp;ldquo;&lt;code&gt;/bin/ls&lt;/code&gt;&amp;rdquo; passiert:
Weil der Pfadname mit einem &amp;ldquo;&lt;code&gt;/&lt;/code&gt;&amp;rdquo; beginnt, durchsucht &lt;code&gt;namei()&lt;/code&gt; das Hauptverzeichnis des Prozesses, der den Systemaufruf getätigt hat, nach einem Eintrag für &amp;ldquo;&lt;code&gt;bin&lt;/code&gt;&amp;rdquo;.
Sobald die I-Nodenummer für das &amp;ldquo;&lt;code&gt;bin&lt;/code&gt;&amp;quot;-Verzeichnis gefunden ist, kann es nach einem Eintrag für &amp;ldquo;&lt;code&gt;ls&lt;/code&gt;&amp;rdquo; durchsucht werden.
Erst wenn die I-Nodenummer von &amp;ldquo;&lt;code&gt;ls&lt;/code&gt;&amp;rdquo; bekannt ist, kann die Datei geöffnet oder geladen werden.
Bei der Auflösung von Pfadnamen ergibt sich also eine wechselseitige Verkettung von Datenblöcken und I-Nodes: I-Nodes enthalten Zeiger auf Datenblöcke und die Datenblöcke eines Verzeichnisses enthalten Zeiger auf I-Nodes.&lt;/p&gt;
&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/1994/02/nameiresolver.gif&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;

&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Bild 5: Zugriffe beim Auflösen eines Pfadnamens&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&#34;zugriffsrechte&#34;&gt;
    &lt;a href=&#34;#zugriffsrechte&#34;&gt;
	Zugriffsrechte
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;In der I-Node existiert ein Feld &lt;code&gt;ino_mode&lt;/code&gt;.
Es enthält neben anderen Informationen 9 Bits, die die Zugriffsrechte auf die Datei festlegen.
UNIX unterscheidet an jedem Objekt im Dateisystem 3 Rechte: r-Recht bestimmt, ob eine Datei zu Lesen geöffnet werden darf, w-Recht bestimmt, ob eine Datei beschrieben werden darf und x-Recht bestimmt, ob eine Datei ausgeführt werden kann.
Diese Rechte rwx sind jeweils einmal für den Eigentümer der Datei, für Angehörige seiner Benutzergruppe und für den Rest der Welt vorhanden, sodass sich insgesamt 9 Rechte-Bits ergeben.&lt;/p&gt;
&lt;p&gt;Da Verzeichnisse auch Dateien sind, haben auch sie diese Zugriffsrechte.
In Zusammenhang mit Verzeichnissen werden sie jedoch etwas anders interpretiert: r-Recht an einem Verzeichnis erlaubt einem Benutzer, die Namensliste eines Verzeichnisses zu lesen.
w-Recht an einem Verzeichnis gestattet es ihm, Dateien anzulegen oder zu löschen.
x-Recht schließlich ist notwendig, um auf die Dateien in einem Verzeichnis zuzugreifen. In Bild 5 ist zu sehen, an welchen Stellen welche Zugriffsrechte geprüft werden, wenn die Datei &amp;ldquo;&lt;code&gt;/bin/ls&lt;/code&gt;&amp;rdquo; zum Lesen geöffnet werden soll:
Zunächst einmal muss am Hauptverzeichnis x-Recht vorhanden sein, damit auf die Datei &amp;ldquo;&lt;code&gt;bin&lt;/code&gt;&amp;rdquo; zugegriffen werden kann, die im Hauptverzeichnis enthalten ist.
Danach wird auf ein x-Recht am &amp;ldquo;&lt;code&gt;bin&lt;/code&gt;&amp;quot;-Verzeichnis geprüft, um auf die Datei &amp;ldquo;&lt;code&gt;ls&lt;/code&gt;&amp;rdquo; zugreifen zu können.
Und schließlich muss an der Datei &amp;ldquo;&lt;code&gt;ls&lt;/code&gt;&amp;rdquo; selbst noch r-Recht vorhanden sein, damit auf die Datenblöcke der Datei lesen zugegriffen werden darf.&lt;/p&gt;
&lt;p&gt;x-Recht an einem Verzeichnis ist also immer dann erforderlich, wenn &lt;code&gt;namei()&lt;/code&gt; einem Zeiger aus diesem Verzeichnis in die I-Nodetabelle folgen muss.
In Bild 5 sind diese aufwärts führenden Pfeile etwas  dicker hervorgehoben.&lt;/p&gt;
&lt;h2 id=&#34;fragmente&#34;&gt;
    &lt;a href=&#34;#fragmente&#34;&gt;
	Fragmente
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Dateisysteme verwalten den Plattenplatz in Form von Blöcken fester Größe.
Deswegen ist am Ende der meisten Dateien ein Block vorhanden, der nicht ganz ausgenutzt werden kann, denn bei den meisten Dateien ist die Dateilänge nicht genau ein Vielfaches der Blockgröße des Dateisystems.
So geht, abhängig von der mittleren Dateigröße und der Blockgröße des Dateisystems ein mehr oder weniger großer Anteil des Plattenplatzes verloren.
Je kleiner die Verwaltungseinheiten des Dateisystems sind, umso effektiver kann es seinen Platz verwalten.
Andererseits ist der Datendurchsatz eines Dateisystems um so größer, je größer die Blöcke sind, die es verwaltet.
Und schließlich kann man bei der Verwendung von großen Datenblöcken oft mehrfach indirekte Blöcke einsparen und macht das Dateisystem auf diese Weise schneller und reduziert den Verwaltungsaufwand.
In modernen UNIX-Dateisystem löst man dieses Dilemma, indem man ein Dateisystem mit einer relativ großen Blockgröße (meistens 8 Kilobyte) anlegt, Dateienden aber in speziellen Blöcken, den Fragmenten, speichert.
Fragmente werden erzeugt, in dem man einen normalen Plattenblock in mehrere gleichgrosse Teilblöcke unterteilt, die jeweils das Dateiende einer anderen Datei aufnehmen können.&lt;/p&gt;
&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/1994/02/bsdfragment.gif&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;

&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Bild 6: Zwei Dateienden in einem fragmentierten Block&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Auf diese Weise werden die Dateienden verschiedener Dateien praktisch in einem Block zusammen komprimiert und der Verlust an Plattenplatz durch nicht ausgenutzte Blöcke wird reduziert.
Trotzdem kann das Dateisystem die meiste Zeit mit vollständigen, großen Blöcken arbeiten und so hohe Geschwindigkeiten erreichen.
Der Nachteil dieses Systems ist, daß ein Dateiende unter Umständen mehrfach umkopiert werden muss, wenn eine Datei wächst:
Zunächst passt das Dateiende noch in sein Fragment hinein, wenn es wächst, muss jedoch ein größeres Fragment gesucht werden, das jedoch durch weitere Schreiboperationen sofort wieder überläuft, bis die Datei endlich den nächsten vollständigen Block füllt.
Solche Kopieroperationen lassen sich vermeiden, wenn Anwendungsprogramme ihre Schreiboperationen der Blockgröße des Dateisystems anpassen.
Da so etwas sehr unbequem ist, wenn man es selber programmieren muss, nimmt die C-Standardbibliothek in einem UNIX-System einem diese Arbeit ab:
Sie fragt die Blockgröße des unterliegenden Dateisystems ab und stimmt ihre Schreibzugriffe so ab, daß mit maximaler Geschwindigkeit geschrieben werden kann.&lt;/p&gt;
&lt;p&gt;Weitere Geschwindigkeitsvorteile lassen sich erzielen, wenn man dafür sorgen kann, daß Dateien möglichst hintereinanderliegende Blöcke auf einer Platte belegen.
Die Platte kann in diesem Fall ihren internen Cache füllen und die Daten schneller abliefern.
Außerdem entfallen Bewegungen des Schreib-/Lesekopfes der Platte.
Wie man am Beispiel von DOS sehen kann, ist es leider ist es nicht damit getan, die Blöcke einer Datei hintereinander anzuordnen.
Man muss außerdem auch Platz lassen, damit Dateien wachsen können.&lt;/p&gt;
&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/1994/02/fragmentierung.gif&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;

&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Bild 7: Durch unkluge Anordnung von Daten zerstückelt MS-DOS Dateien in kleine, nicht zusammenhängende Fragmente.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Moderne UNIX-Dateisysteme unterteilen eine Festplatte deswegen in Streifen von einigen Megabyte Größe, sogenannte cylinder groups.
Jeder dieser Streifen enthält eine eigene kleine I-Nodetabelle und seinen Anteil an Datenblöcken.
Neue Dateien werden in derjenigen Zylindergruppe angelegt, die im Verhältnis am meisten freie Datenblöcke aufzuweisen hat.
Dadurch wird sichergestellt, daß solche Dateien gerade nicht direkt hintereinanderliegen, sondern genügend freien Platz haben, um zu wachsen.
Bei sehr langen Dateien wird außerdem nach dem Schreiben von jeweils einem Megabyte an Daten ein Wechsel der Zylindergruppe erzwungen:
Man geht davon aus, daß man sehr lange Dateien sowieso nicht in einem Stück zusammenhängend lagern kann.
Stattdessen versucht man, die einzelnen Stücke möglichst groß zu machen.&lt;/p&gt;
&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/1994/02/bsdlayout.gif&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;

&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Bild 8: Das BSD Fast Filing System unterteilt die Platte in Streifen von einigen MB Größe. Das Betriebssystem versucht durch verschiedene Verfahren,
das Verhältnis von belegten Datenblöcken zu belegten I-Nodes in allen cylinder groups einer Platte in etwa ausgewogen zu halten. Dadurch ist das Dateisystem effektiv selbstdefragmentierend.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Außerdem würde eine sehr lange Datei alle Datenblöcke, aber nur eine einzige I-Node in einer Zylindergruppe belegen.
Die Daten zu den I-Nodes aller weiteren Dateien in derselben Zylindergruppe müssten dann auf andere Zylindergruppen verlagert werden, was dort wiederum das ausgewogene Verhältnis zwischen freien I-Nodes und freien Datenblöcken stören würde.
Dadurch, daß man  jeweils ein Megabyte einer sehr großen Datei auf eine andere Zylindergruppe verlagert, wird der Platz auf der Platte gleichmäßig verbraucht.
Man verhindert, daß andere Dateien dann nicht mehr günstig auf der Platte angeordnet werden können.&lt;/p&gt;
&lt;h2 id=&#34;abgeleitete-dateisysteme&#34;&gt;
    &lt;a href=&#34;#abgeleitete-dateisysteme&#34;&gt;
	Abgeleitete Dateisysteme
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Die grundlegenden Strukturen des UNIX-Dateisystems wurden von Ritchie und Thompson vor 20 Jahren in den Laboratorien von AT&amp;amp;T entwickelt und haben sich grundsätzlich bewährt.
Selbst das Entwicklerteam von BSD UNIX, das das Dateisystem vor 10 Jahren einer gründlichen Überarbeitung unterzogen hat, hat die zugrundeliegenden Ideen nicht verändert, sondern UNIX lediglich beigebracht, auf die Geometrie der Platte Rücksicht zu nehmen, um weitere Geschwindigkeitsgewinne zu erzielen.&lt;/p&gt;
&lt;p&gt;Das UNIX-Dateisystem ist dem nur halb so alten, aber wesentlich weniger effektiv organisierten MS-DOS Dateisystem in Sachen Geschwindigkeit, Zugriffsschutz und Benutzerfreundlichkeit weit überlegen.
Die Ideen der UNIX-Entwickler waren letztlich so überzeugend, daß sie sich letztendlich im OS/2 HPFS und schließlich auch im Dateisystem von Windows NT wiederfinden.&lt;/p&gt;
&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/1994/02/mount.gif&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;

&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Bild 9: 26 Laufwerksbuchstaben wären für eine gut ausgelastete Workstation viel zu wenig. UNIX kennt deswegen nur einen einzigen Dateibaum. Beim Anmelden (mounten) eines Dateisystems wird eine Platte an einer
bestimmten Stelle in den Verzeichnisbaum eingehängt. Beim Wechsel des Verzeichnisses wechselt man so auch gleich die Platte oder bei Netzwerkplatten sogar den Rechner, auf dem man aktiv ist.&lt;/em&gt;&lt;/p&gt;
&lt;h1 id=&#34;literatur&#34;&gt;
    &lt;a href=&#34;#literatur&#34;&gt;
	Literatur
    &lt;/a&gt;
&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&amp;ldquo;The UNIX Time Sharing System&amp;rdquo;, Ritchie, Thompson, Communications of the ACM 7/74, p.365&lt;/li&gt;
&lt;li&gt;&amp;ldquo;A Fast File System for UNIX&amp;rdquo;, McKusick et. al, ACM Trans. on Computer Systems, August 84, p.181&lt;/li&gt;
&lt;li&gt;&amp;ldquo;Operating Systems&amp;rdquo;, A. Tanenbaum, Prentice-Hall&lt;/li&gt;
&lt;li&gt;&amp;ldquo;The Design of the UNIX Operating System&amp;rdquo;, M.Bach, Prentice-Hall&lt;/li&gt;
&lt;li&gt;&amp;ldquo;The Design of the 4.3 BSD UNIX Operating System&amp;rdquo;, McKusick, Addison-Wesley&lt;/li&gt;
&lt;li&gt;&amp;ldquo;Advanced Programming in the UNIX Environment&amp;rdquo;, W.R.Stevens, Addison-Wesley&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>

