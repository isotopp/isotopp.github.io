<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Unix on Die wunderbare Welt von Isotopp</title>
    <link>https://blog.koehntopp.info/tags/unix.html</link>
    <description>Recent content in Unix on Die wunderbare Welt von Isotopp</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <managingEditor>kris-blog@koehntopp.de (Kristian Köhntopp)</managingEditor>

    
    <webMaster>kris-blog@koehntopp.de (Kristian Köhntopp)</webMaster>

    
    <lastBuildDate>Tue, 21 Jan 2025 12:20:50 +0000</lastBuildDate><atom:link href="https://blog.koehntopp.info/tags/unix/feed.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Invalid-UTF8 vs the filesystem</title>
      <link>https://blog.koehntopp.info/2023/09/14/invalid-utf8-vs-the-filesystem.html</link>
      <pubDate>Thu, 14 Sep 2023 01:02:03 +0000</pubDate><author>kris-blog@koehntopp.de (Kristian Köhntopp)</author>

      <guid>https://blog.koehntopp.info/2023/09/14/invalid-utf8-vs-the-filesystem.html</guid>
      <description>&lt;p&gt;A UNIX filename can contain arbitrary bytes in an arbitrary sequence, with two exceptions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;It cannot contain NUL (&lt;code&gt;\0&lt;/code&gt;).&lt;/li&gt;
&lt;li&gt;It cannot contain slash (&lt;code&gt;/&lt;/code&gt;), because that is the directory separator.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;But will all filesystems accept such filenames?
And how will this work with languages such as Python, which require all strings to be valid &lt;code&gt;utf-8&lt;/code&gt; and
which declare the filesystem interface to accept and return strings?&lt;/p&gt;
&lt;h1 id=&#34;a-test-program&#34;&gt;
    &lt;a href=&#34;#a-test-program&#34;&gt;
	A test program
    &lt;/a&gt;
&lt;/h1&gt;
&lt;p&gt;Let&amp;rsquo;s check.
Here is a small C program, based on &lt;a href=&#34;https://stackoverflow.com/questions/1301402/example-invalid-utf8-string&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;this stackoverflow article&lt;/a&gt;

.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;sys/stat.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;examples&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;s&#34;&gt;&amp;#34;a&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\xc3\xb1&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\xc3\x28&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\xa0\xa1&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\xe2\x82\xa1&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\xe2\x28\xa1&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\xe2\x82\x28&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\xf0\x90\x8c\xbc&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\xf0\x28\x8c\xbc&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\xf0\x90\x28\xbc&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\xf0\x28\x8c\x28&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\xf8\xa1\xa1\xa1\xa1&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\xfc\xa1\xa1\xa1\xa1\xa1&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;result&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;FILE&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;result&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;mkdir&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;keks&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mo&#34;&gt;0755&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// don&amp;#39;t care if exists
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;result&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;chdir&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;keks&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;       &lt;span class=&#34;c1&#34;&gt;// don&amp;#39;t care if succeed.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;examples&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nf&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;%s&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;examples&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;fp&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;fopen&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;examples&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;w&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;!&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;nf&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;unable to open %d (%s)!&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;examples&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;k&#34;&gt;continue&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;nf&#34;&gt;fprintf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;keks&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;nf&#34;&gt;fclose&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;xfs&#34;&gt;
    &lt;a href=&#34;#xfs&#34;&gt;
	XFS
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;When running this on a Linux system with XFS, this works:&lt;/p&gt;
&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/2023/09/invalid-utf8-xfs.png&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;

&lt;/p&gt;
&lt;p&gt;&lt;em&gt;The program runs and generates all files. Even those with byte sequences that are not valid utf-8.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;This works the same with ext4 on Linux.&lt;/p&gt;
&lt;h2 id=&#34;zfs&#34;&gt;
    &lt;a href=&#34;#zfs&#34;&gt;
	ZFS
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;When running this on a Linux system with ZFS, filenames containing invalid utf-8 sequences are rejected.&lt;/p&gt;
&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/2023/09/invalid-utf8-zfs.png&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;

&lt;/p&gt;
&lt;p&gt;&lt;em&gt;The program runs and generates files with valid utf-8 names. The &lt;code&gt;open(2)&lt;/code&gt; syscall fails for names with invalid utf-8 filenames.&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&#34;apfs&#34;&gt;
    &lt;a href=&#34;#apfs&#34;&gt;
	APFS
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;When running this on a MacOS Ventura system with APFS, filenames containing invalid utf-8 sequences are rejected.&lt;/p&gt;
&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/2023/09/invalid-utf8-apfs.png&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;

&lt;/p&gt;
&lt;p&gt;&lt;em&gt;The program runs and generates files with valid utf-8 names. The &lt;code&gt;open(2)&lt;/code&gt; syscall fails for names with invalid utf-8 filenames.&lt;/em&gt;&lt;/p&gt;
&lt;h1 id=&#34;unpacking-invalid-utf-8-filenames-with-python&#34;&gt;
    &lt;a href=&#34;#unpacking-invalid-utf-8-filenames-with-python&#34;&gt;
	Unpacking invalid utf-8 filenames with Python
    &lt;/a&gt;
&lt;/h1&gt;
&lt;p&gt;I went and creates a &lt;code&gt;tar&lt;/code&gt; archive of the files generated on XFS and copied it over to my Mac.&lt;/p&gt;
&lt;p&gt;The following test program was used to unpack the &lt;code&gt;tar&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;ch&#34;&gt;#! /usr/bin/env python&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kn&#34;&gt;from&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;tarfile&lt;/span&gt; &lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;TarFile&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;chardet&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;os&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;with&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;TarFile&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;open&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;test.tar&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;r&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;as&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;names&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;getnames&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;name&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;names&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;bname&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;bytearray&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;raw&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nb&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;chardet&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;detect&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The test run fails:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;(venv) $ python tarnames.py
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;Traceback (most recent call last):
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;  File &amp;#34;.../tarnames.py&amp;#34;, line 15, in &amp;lt;module&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;    bname = bytearray(name, &amp;#39;raw&amp;#39;)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;            ^^^^^^^^^^^^^^^^^^^^^^
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;LookupError: unknown encoding: raw
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;intermediate-result&#34;&gt;
    &lt;a href=&#34;#intermediate-result&#34;&gt;
	Intermediate result
    &lt;/a&gt;
&lt;/h1&gt;
&lt;p&gt;It probably is useful to restrict POSIX further and demand that filenames are always valid utf-8.
But that is not what the standard currently says, and also not what all filesystems guarantee.
And it can lead to unexpected behavior.&lt;/p&gt;
&lt;p&gt;Also, some programming languages such as Python demand of strings that they have valid utf-8 encoding,
but use filenames and strings equivalently.&lt;/p&gt;
&lt;p&gt;That can lead to weird behavior.&lt;/p&gt;
&lt;h1 id=&#34;further-research&#34;&gt;
    &lt;a href=&#34;#further-research&#34;&gt;
	Further research
    &lt;/a&gt;
&lt;/h1&gt;
&lt;p&gt;Apparently there is a function
&lt;a href=&#34;https://docs.python.org/3/library/sys.html#sys.getfilesystemencoding&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;sys.getfilesystemencoding()&lt;/code&gt;&lt;/a&gt;


without parameters.
Python seems to assume that all filesystems have the same encoding and that it is not path dependent.&lt;/p&gt;
&lt;p&gt;Apparently there are &lt;code&gt;os.fsencode()&lt;/code&gt; and
&lt;a href=&#34;https://docs.python.org/3/library/os.html#os.fsencode&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;os.fsdecode()&lt;/code&gt;&lt;/a&gt;

.&lt;/p&gt;
&lt;h2 id=&#34;modified-python-code&#34;&gt;
    &lt;a href=&#34;#modified-python-code&#34;&gt;
	Modified Python code
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;We are using &lt;code&gt;os.fsencode()&lt;/code&gt; to get &lt;code&gt;bytes&lt;/code&gt; from the filesystem interface.
We are then using &lt;code&gt;chardet.detect()&lt;/code&gt; on this byte-string and check the guesses.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;ch&#34;&gt;#! /usr/bin/env python&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kn&#34;&gt;from&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;tarfile&lt;/span&gt; &lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;TarFile&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;chardet&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;os&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;with&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;TarFile&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;open&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;test.tar&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;r&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;as&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;names&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;getnames&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;name&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;names&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;bname&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;os&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fsencode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nb&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;sa&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bname&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;=}&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nb&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;chardet&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;detect&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bname&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The result:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;bname=b&amp;#39;keks&amp;#39;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;{&amp;#39;encoding&amp;#39;: &amp;#39;ascii&amp;#39;, &amp;#39;confidence&amp;#39;: 1.0, &amp;#39;language&amp;#39;: &amp;#39;&amp;#39;}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;bname=b&amp;#39;keks/a&amp;#39;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;{&amp;#39;encoding&amp;#39;: &amp;#39;ascii&amp;#39;, &amp;#39;confidence&amp;#39;: 1.0, &amp;#39;language&amp;#39;: &amp;#39;&amp;#39;}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;bname=b&amp;#39;keks/\xc3\xb1&amp;#39;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;{&amp;#39;encoding&amp;#39;: &amp;#39;ISO-8859-1&amp;#39;, &amp;#39;confidence&amp;#39;: 0.73, &amp;#39;language&amp;#39;: &amp;#39;&amp;#39;}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;bname=b&amp;#39;keks/\xc3(&amp;#39;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;{&amp;#39;encoding&amp;#39;: &amp;#39;ISO-8859-1&amp;#39;, &amp;#39;confidence&amp;#39;: 0.73, &amp;#39;language&amp;#39;: &amp;#39;&amp;#39;}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;bname=b&amp;#39;keks/\xa0\xa1&amp;#39;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;{&amp;#39;encoding&amp;#39;: &amp;#39;IBM866&amp;#39;, &amp;#39;confidence&amp;#39;: 0.99, &amp;#39;language&amp;#39;: &amp;#39;Russian&amp;#39;}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;bname=b&amp;#39;keks/\xe2\x82\xa1&amp;#39;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;{&amp;#39;encoding&amp;#39;: &amp;#39;Windows-1252&amp;#39;, &amp;#39;confidence&amp;#39;: 0.73, &amp;#39;language&amp;#39;: &amp;#39;&amp;#39;}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;bname=b&amp;#39;keks/\xe2(\xa1&amp;#39;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;{&amp;#39;encoding&amp;#39;: &amp;#39;ISO-8859-1&amp;#39;, &amp;#39;confidence&amp;#39;: 0.73, &amp;#39;language&amp;#39;: &amp;#39;&amp;#39;}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;bname=b&amp;#39;keks/\xe2\x82(&amp;#39;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;{&amp;#39;encoding&amp;#39;: &amp;#39;Windows-1252&amp;#39;, &amp;#39;confidence&amp;#39;: 0.73, &amp;#39;language&amp;#39;: &amp;#39;&amp;#39;}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;bname=b&amp;#39;keks/\xf0\x90\x8c\xbc&amp;#39;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;{&amp;#39;encoding&amp;#39;: &amp;#39;Windows-1254&amp;#39;, &amp;#39;confidence&amp;#39;: 0.48310298982778344, &amp;#39;language&amp;#39;: &amp;#39;Turkish&amp;#39;}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;bname=b&amp;#39;keks/\xf0(\x8c\xbc&amp;#39;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;{&amp;#39;encoding&amp;#39;: &amp;#39;Windows-1252&amp;#39;, &amp;#39;confidence&amp;#39;: 0.73, &amp;#39;language&amp;#39;: &amp;#39;&amp;#39;}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;bname=b&amp;#39;keks/\xf0\x90(\xbc&amp;#39;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;{&amp;#39;encoding&amp;#39;: &amp;#39;Windows-1254&amp;#39;, &amp;#39;confidence&amp;#39;: 0.5521177026603239, &amp;#39;language&amp;#39;: &amp;#39;Turkish&amp;#39;}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;bname=b&amp;#39;keks/\xf0(\x8c(&amp;#39;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;{&amp;#39;encoding&amp;#39;: &amp;#39;Windows-1252&amp;#39;, &amp;#39;confidence&amp;#39;: 0.73, &amp;#39;language&amp;#39;: &amp;#39;&amp;#39;}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;bname=b&amp;#39;keks/\xf8\xa1\xa1\xa1\xa1&amp;#39;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;{&amp;#39;encoding&amp;#39;: &amp;#39;ISO-8859-1&amp;#39;, &amp;#39;confidence&amp;#39;: 0.73, &amp;#39;language&amp;#39;: &amp;#39;&amp;#39;}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;bname=b&amp;#39;keks/\xfc\xa1\xa1\xa1\xa1\xa1&amp;#39;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;{&amp;#39;encoding&amp;#39;: &amp;#39;ISO-8859-1&amp;#39;, &amp;#39;confidence&amp;#39;: 0.73, &amp;#39;language&amp;#39;: &amp;#39;&amp;#39;}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The guesses are trying to find a valid charset for the bytestring, and they find the lowest (least large) charset that matches.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>MacOS, vim, git and exit...</title>
      <link>https://blog.koehntopp.info/2023/08/17/macos-vim-git-and-exit.html</link>
      <pubDate>Thu, 17 Aug 2023 01:02:03 +0000</pubDate><author>kris-blog@koehntopp.de (Kristian Köhntopp)</author>

      <guid>https://blog.koehntopp.info/2023/08/17/macos-vim-git-and-exit.html</guid>
      <description>&lt;p&gt;On &lt;code&gt;git commit&lt;/code&gt;, &lt;code&gt;git&lt;/code&gt; invokes an editor (by default: &lt;code&gt;vi&lt;/code&gt;) and allows you to edit a commit message.
If the editor exits with status code 0, the commit message is accepted and used.
If the editor exists with status code &amp;gt;0, this is an error and the commit is aborted.
The commit message is lost.&lt;/p&gt;
&lt;p&gt;On MacOS, calling &lt;code&gt;/usr/bin/vi&lt;/code&gt;, the editor shipped with the OS, starts vim 9.0.1424 in vi mode.
In this mode, if you enter an illegal editor command such as &lt;code&gt;:W&lt;/code&gt;, the editor will exit with status 1.
This will happen even when you enter a legal editor command afterwards.
So&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;:W keks
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;:w keks
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;:q
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;will&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;kk:~ kris$ vi
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;kk:~ kris$ echo $?
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;1
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This does not happen if the same editor is called as &lt;code&gt;vim&lt;/code&gt;.
This does not happen on Ubuntu 22.04, which as vim 8.2.4919 installed – it will exit 0 as &lt;code&gt;vi&lt;/code&gt; or &lt;code&gt;vim&lt;/code&gt;.
This suggests that this behavior of vim 9, when called as &amp;ldquo;vi&amp;rdquo; in compatibility mode, is an &amp;ldquo;improvement&amp;rdquo; that has been added on purpose.
I wonder if that is really the case.&lt;/p&gt;
&lt;p&gt;In &lt;code&gt;vim&lt;/code&gt;, the command &lt;code&gt;:&amp;lt;status&amp;gt;cq&lt;/code&gt; to force an exit status.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;:1cq
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;kk:~ kris $ echo $?
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;1
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;You can also &lt;code&gt;:0cq&lt;/code&gt; to force a zero.
This also works in compatibility mode.
You can, of course, also&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;gp&#34;&gt;$&lt;/span&gt; git config --global core.editor &lt;span class=&#34;s2&#34;&gt;&amp;#34;vim&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>50 years in filesystems: towards 2004 – LFS</title>
      <link>https://blog.koehntopp.info/2023/05/17/50-years-in-filesystems-towards-2004-lfs.html</link>
      <pubDate>Wed, 17 May 2023 01:02:03 +0000</pubDate><author>kris-blog@koehntopp.de (Kristian Köhntopp)</author>

      <guid>https://blog.koehntopp.info/2023/05/17/50-years-in-filesystems-towards-2004-lfs.html</guid>
      <description>&lt;p&gt;This is part 5 of a series.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&amp;ldquo;&lt;a href=&#34;https://blog.koehntopp.info/2023/05/05/50-years-in-filesystems-1974.html&#34;&gt;1974&lt;/a&gt;

&amp;rdquo; on the traditional Unix Filesystem.&lt;/li&gt;
&lt;li&gt;&amp;ldquo;&lt;a href=&#34;https://blog.koehntopp.info/2023/05/06/50-years-in-filesystems-1984.html&#34;&gt;1984&lt;/a&gt;

&amp;rdquo; on the BSD Fast File System.&lt;/li&gt;
&lt;li&gt;&amp;ldquo;&lt;a href=&#34;https://blog.koehntopp.info/2023/05/12/50-years-in-filesystems-1994.html&#34;&gt;1994&lt;/a&gt;

&amp;rdquo; on SGI XFS.&lt;/li&gt;
&lt;li&gt;&amp;ldquo;&lt;a href=&#34;https://blog.koehntopp.info/2023/05/15/50-years-in-filesystems-vnodes.html&#34;&gt;Vnodes&lt;/a&gt;

&amp;rdquo; on how to have multiple filesystems in Unix.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Progress is sometimes hard to see, especially when you have been part of it or otherwise lived through it.
Often, it is easier to see by comparing modern educational material and the problems discussed with older material.
Or look for the research papers and sources that fueled the change. So this is what we do.&lt;/p&gt;
&lt;h1 id=&#34;frontiers-in-the-nineties&#34;&gt;
    &lt;a href=&#34;#frontiers-in-the-nineties&#34;&gt;
	Frontiers in the Nineties
    &lt;/a&gt;
&lt;/h1&gt;
&lt;p&gt;SGI&amp;rsquo;s XFS is pretty much the culmination point in filesystem technology for anything that does in-place updates.
Extents, generous usage of B+-trees and lock splitting across allocation groups make it a great filesystem that is fast and scales well.
The introduction of a metadata log allows it to recover quickly.&lt;/p&gt;
&lt;p&gt;The Nineties were also busy with operating systems research.
Specifically, cluster operating systems were very much en vogue:
Tanenbaum was in Amsterdam, busy with &lt;a href=&#34;https://en.wikipedia.org/wiki/Amoeba_%28operating_system%29&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Amoeba&lt;/a&gt;

.
Bell Labs was busy with &lt;a href=&#34;https://en.wikipedia.org/wiki/Plan_9_from_Bell_Labs&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Plan 9&lt;/a&gt;

.
And at the UCB, Ousterhout was working on &lt;a href=&#34;https://en.wikipedia.org/wiki/Sprite_%28operating_system%29&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Sprite&lt;/a&gt;

.&lt;/p&gt;
&lt;p&gt;All were experimenting with cluster-unified filesystems, distributed processing, workload migration,
and generally trying to build what 20 years later would become the &lt;a href=&#34;https://www.amazon.com/Datacenter-Computer-Introduction-Warehouse-Scale-Architecture/dp/159829556X&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Warehouse-Scale Computer&lt;/a&gt;

.&lt;/p&gt;
&lt;p&gt;Part of the Sprite development at UCB, specifically, was the Log-Structured File System (LFS), and
Mendel Rosenblum and John K. Ousterhout present it in &lt;a href=&#34;https://www.usenix.org/legacy/publications/library/proceedings/sd93/seltzer.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;this paper&lt;/a&gt;

 from 1992.
This is a long paper, 27 pages, but if you read it with hindsight, you can really appreciate how enlightened it was.&lt;/p&gt;
&lt;h1 id=&#34;lfs&#34;&gt;
    &lt;a href=&#34;#lfs&#34;&gt;
	LFS
    &lt;/a&gt;
&lt;/h1&gt;
&lt;p&gt;Filesystems with in-place updates are in part already using logs for faster recovery in 1992.
The paper poses the question &amp;ldquo;What if we had a filesystem that only had a log, and never did in-place updates?&amp;rdquo;,
calling it a log-structured file system.
It then proceeds to present an implementation and benchmarks for such a thing.&lt;/p&gt;
&lt;h2 id=&#34;reads-are-cached-only-writes-matter&#34;&gt;
    &lt;a href=&#34;#reads-are-cached-only-writes-matter&#34;&gt;
	&amp;ldquo;Reads are cached, only writes matter&amp;rdquo;
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;In working with distributed operating systems, the Sprite team noticed that they have a lot of memory available.
They found with increasing memory sizes, the probability of a file being served by the buffer cache instead of reading it from disk increased by a lot,
and eventually almost all disk reads are being served from memory.&lt;/p&gt;
&lt;p&gt;Writes cannot be cached very well, and eventually they need to hit persistent storage,
but with the reads being cached it would be worthwhile and possible to construct a filesystem optimized for writes.&lt;/p&gt;
&lt;p&gt;The team also observes that CPU speeds grow exponentially, following Moore&amp;rsquo;s law.
The same seems to be true for memory sizes, which being on-chip silicon structures also obey this law.
But disks do not work that way.
While their capacity grows, their transfer speed and seek time does not improve much, because mechanical parts do not obey Moore&amp;rsquo;s law.
Disks are a problem: While linear writes perform well, seeks are slow and are not getting faster much.&lt;/p&gt;
&lt;p&gt;So they propose never overwriting any data, but always appending changed blocks to the end of a log.&lt;/p&gt;
&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/2023/05/log-adoption.png&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;


&lt;em&gt;“Ah you think the log is your ally? You merely adopted the log. I was born with it, designed for it.”&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&#34;garbage-collection&#34;&gt;
    &lt;a href=&#34;#garbage-collection&#34;&gt;
	Garbage collection
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Of course, disks in the Nineties were finite, as they are now.
So there has to be a &lt;em&gt;cleaner&lt;/em&gt; process that identifies, frees and compacts space that is no longer needed by any current view of the filesystem.&lt;/p&gt;
&lt;p&gt;This is much like the Garbage Collection in Java Virtual Machines, which were invented around the same time.
And much like the GC in JVMs, it would turn out to be the weak spot of the system.&lt;/p&gt;
&lt;p&gt;A lot of the paper busies itself with simulating workloads on the filesystem with different cleaner policies,
and the team then lands on a system that very much evolves in the same way Java GC evolved,
with a multi-tier compaction process that mirrors the &amp;ldquo;Young&amp;rdquo;, &amp;ldquo;Old&amp;rdquo;, and &amp;ldquo;Permanent&amp;rdquo; generations of Java objects.
This is not entirely surprising from hindsight:
Other, newer systems such as Cassandra, Zookeeper and other storages that use LSM Trees are using a very similar strategy with good success.&lt;/p&gt;
&lt;p&gt;Specifically, LFS partitions the storage into contiguous segments, and cleans storage segment by segment:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;We used a simulator to explore different cleaning policies and discovered a simple but effective algorithm based on cost and benefit:
it segregates older, slowly changing data from younger rapidly changing data and treats them differently during cleaning.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Other code takes multiple nearly empty segments of the same age and copies them together into a single segment, freeing up the others.&lt;/p&gt;
&lt;p&gt;This creates a certain amount of background copy activity from the cleaner process.
It also creates a race between the writers to the system using up free space,
and the cleaner process trying to provide sufficient free space.
If the system writes data heavily and free space goes down, the cleaner may need to be prioritized higher,
consuming more I/O, in order to make sufficient progress in providing clean segments to write to.
This will also slow down the writers.&lt;/p&gt;
&lt;p&gt;Benchmarks executed as part of the research show that the system can indeed write to disk at up to 70% of the theoretically available maximum bandwidth.
But this is true only under ideal conditions.
Also, the data is not stored in read-order at all, so read performance is only good if data is actually cached.&lt;/p&gt;
&lt;p&gt;Segments are sufficiently large to amortize the cost of seeking to them.
In the Mid-Nineties, that meant a size of around 0.5 to 1 MB.&lt;/p&gt;
&lt;p&gt;Cleaning is then a three-step process:
After suitable segments have been identified from metadata,
the cleaner reads multiple segments into memory, compacts them into a smaller number of segments,
and writes them out to disk in a single large I/O operation.
The old segments can now be marked as clean, and be returned to the free segment pool.&lt;/p&gt;
&lt;h2 id=&#34;using-ffs-data-structures&#34;&gt;
    &lt;a href=&#34;#using-ffs-data-structures&#34;&gt;
	Using FFS data structures
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;LFS uses data structures from FFS almost unchanged:
The filesystem has superblocks, inodes, direct and indirect blocks, and uses the same structures for directories, too.
All information changed is buffered and then written out sequentially in a single disk write that appends atomically and asynchronously to the log.&lt;/p&gt;
&lt;p&gt;Not overwriting things means duplicating things, so when a file grows by appending a block, the file&amp;rsquo;s inode changes.
This means the block containing the changed inode needs to be written out again, together with block added to the file.
LFS needs to keep track of inodes in an &lt;em&gt;inode map&lt;/em&gt;, and this now also needs to be updated and written out:
even if it is small enough to be cached in memory, it needs to be persisted.&lt;/p&gt;
&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/2023/05/lfs-structures.png&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;


&lt;em&gt;LFS does indeed do limited in-place updates: The superblock and checkpoint region are written in fixed locations.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;LFS stops short of also appending new copies of the inode map and ultimately the superblock for each disk write,
and puts these things into fixed locations.
So we do have in-place updates for certain limited metadata structures.
This is unfortunate, as we will see when we are looking at LFS&amp;rsquo; legacy.&lt;/p&gt;
&lt;h2 id=&#34;soft-updates&#34;&gt;
    &lt;a href=&#34;#soft-updates&#34;&gt;
	Soft Updates
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;In order for LFS to write out changes to data and metadata such as indirect blocks, direct blocks, inodes and directories,
updates had to be written in the proper order, even if the entire write happened in a single big I/O operation.
Writing out data &amp;ldquo;from the leaves of the filesystem tree to the top&amp;rdquo; sorts the updates in a way that made recovery easier,
because each data structure that had pointers to dependent blocks would be written out only after these blocks had already been persisted.&lt;/p&gt;
&lt;p&gt;It turns out that this logic also has merit for traditional filesystems that do in-place updates.
It allows &lt;a href=&#34;https://www.usenix.org/legacy/publications/library/proceedings/bsdcon02/mckusick.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;file system checking to go on in the background&lt;/a&gt;

 while the filesystem is already being made available,
and it can &lt;a href=&#34;https://www.usenix.org/legacy/publications/library/proceedings/usenix99/mckusick.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;eliminate almost all synchronous metadata updates&lt;/a&gt;

 in the filesystem.&lt;/p&gt;
&lt;h1 id=&#34;lfs-in-bsd&#34;&gt;
    &lt;a href=&#34;#lfs-in-bsd&#34;&gt;
	LFS in BSD
    &lt;/a&gt;
&lt;/h1&gt;
&lt;p&gt;The BSD FFS crew, also at UCB, was very aware of Ousterhout&amp;rsquo;s work, and picks it up the year after he publishes.
They port the filesystem to BSD and &lt;a href=&#34;https://www.usenix.org/legacy/publications/library/proceedings/sd93/seltzer.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;write a 1993 paper about it&lt;/a&gt;

&lt;/p&gt;
&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/2023/05/lfs-ffs-feature-comparison.png&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;

&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Features and subsystems of BSD FFS are matched with the equivalent structures and concepts on the BSD LFS side.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;They note a few shortcomings, and present improvements:
The cleaner was single-threaded. No matter how many LFS filesystems were mounted, there was only a single cleaner process.
Now there is one per mounted filesystem.
They also provide a structural verifier for the filesystem, something similar to a &lt;code&gt;fsck&lt;/code&gt;, but a thing that can run in the background,
while the filesystem is mounted.&lt;/p&gt;
&lt;p&gt;Also, the original LFS code was using more memory than necessary, and BSD LFS was made a lot more memory efficient.&lt;/p&gt;
&lt;p&gt;A lot of the paper is then a validation that their implementation is indeed a faithful port, and an improvement over original LFS,
and benchmarking.&lt;/p&gt;
&lt;p&gt;The benchmarks confirm improved write performance, but also show weakness concerning read workloads.
This is for two reasons: data is possibly fragmented,
and the file system buffer cache in their machines is often too small to soak up the disk reads.
And secondly, when the cleaner process is running, it interacts badly with both the disk reads and writes via disk seeks,
and that costs more performance than anticipated.
This is in particular true for a database-like (TPC-B) benchmark load,
which performs badly and requires extensive tuning.&lt;/p&gt;
&lt;p&gt;Notably, the paper already hints at several improvements:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;There are two places where in-place updates still happen.
By removing them, the filesystem would automatically become transactional and gain snapshot functionality.
In fact, each disk write would eventually create a snapshot, and actually &amp;ldquo;snapshotting&amp;rdquo; the filesystem would simply mean
to prevent the cleaner from collecting certain snapshots.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Adding checksums to disk blocks already has happened in a few places.
Turning this into a Merkle tree would be a trivial extension, and make validating the complete integrity not only of the
structure, but also of the file data a lot easier.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The paper already notes that ordering writes in the log in a certain way makes background validation easier:
If blocks being pointed to are written before blocks that point to them, referential integrity of the filesystem is being kept at all times.
It is just that a transaction may be incomplete, but because it&amp;rsquo;s not referenced anywhere that is not a problem,
and the disk blocks will be eventually collected and freed by the cleaner.&lt;/p&gt;
&lt;p&gt;Nothing in this idea is actually dependent on the filesystem being LFS.
In fact, it can and was successfully applied to BSD FFS, too, under the name of
&lt;a href=&#34;https://www.usenix.org/legacy/publications/library/proceedings/usenix99/mckusick.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;em&gt;soft updates&lt;/em&gt;&lt;/a&gt;

,
allowing to mount unchecked filesystems and then running a check in the background.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;performance-war&#34;&gt;
    &lt;a href=&#34;#performance-war&#34;&gt;
	Performance War
    &lt;/a&gt;
&lt;/h1&gt;
&lt;p&gt;While Seltzer, Bostic, McKusick et al., the original authors of the BSD FFS, were busy porting Sprite LFS to BSD,
and tuning it,
Larry McVoy and S.R. Kleiman pick up the BSD FFS sources at Sun and add support for extents to it.
The resulting patch is tiny, and the work is being documented in
&lt;a href=&#34;https://people.freebsd.org/~pfg/docs/fs/ExtentlikePerformanceforUFS.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Extent-like Performance from a UNIX File System&lt;/a&gt;

.&lt;/p&gt;
&lt;p&gt;To Seltzers chagrin, EFS often and consistently outperforms LFS, requires little to no tuning.
In &lt;a href=&#34;https://people.freebsd.org/~pfg/docs/fs/ExtentlikePerformanceforUFS.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;File System Logging Versus Clustering: A Performance Comparison&lt;/a&gt;


this is confirmed, even if it takes a long paper with many benchmarks to arrive at this finding.
The problem is mostly with the disk seeks induced from running the cleaner.&lt;/p&gt;
&lt;p&gt;If only something could be done about this&amp;hellip;&lt;/p&gt;
&lt;p&gt;Something could be done, but it would happen at Sun and NetApp, and not in BSD: We&amp;rsquo;re getting ZFS and WAFL.&lt;/p&gt;
&lt;p&gt;Also, we&amp;rsquo;re getting things that can seek a lot faster than disks: Flash Storage.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>50 years in filesystems: A detour on vnodes</title>
      <link>https://blog.koehntopp.info/2023/05/15/50-years-in-filesystems-vnodes.html</link>
      <pubDate>Mon, 15 May 2023 01:02:03 +0000</pubDate><author>kris-blog@koehntopp.de (Kristian Köhntopp)</author>

      <guid>https://blog.koehntopp.info/2023/05/15/50-years-in-filesystems-vnodes.html</guid>
      <description>&lt;p&gt;This is part 4 of a series.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&amp;ldquo;&lt;a href=&#34;https://blog.koehntopp.info/2023/05/05/50-years-in-filesystems-1974.html&#34;&gt;1974&lt;/a&gt;

&amp;rdquo; on the traditional Unix Filesystem.&lt;/li&gt;
&lt;li&gt;&amp;ldquo;&lt;a href=&#34;https://blog.koehntopp.info/2023/05/06/50-years-in-filesystems-1984.html&#34;&gt;1984&lt;/a&gt;

&amp;rdquo; on the BSD Fast File System.&lt;/li&gt;
&lt;li&gt;&amp;ldquo;&lt;a href=&#34;https://blog.koehntopp.info/2023/05/12/50-years-in-filesystems-1994.html&#34;&gt;1994&lt;/a&gt;

&amp;rdquo; on SGI XFS.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Progress is sometimes hard to see, especially when you have been part of it or otherwise lived through it.
Often, it is easier to see by comparing modern educational material and the problems discussed with older material.
Or look for the research papers and sources that fueled the change. So this is what we do.&lt;/p&gt;
&lt;h1 id=&#34;how-to-have-multiple-filesystems&#34;&gt;
    &lt;a href=&#34;#how-to-have-multiple-filesystems&#34;&gt;
	How to have multiple filesystems
    &lt;/a&gt;
&lt;/h1&gt;
&lt;p&gt;Steve Kleiman wrote
&amp;ldquo;&lt;a href=&#34;https://www.semanticscholar.org/paper/Vnodes%3A-An-Architecture-for-Multiple-File-System-in-Kleiman/e0d14c74f23ef9b21c2fc37b5197fbfe348a7fcf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Vnodes: An Architecture for Multiple File System Types in Sun UNIX&lt;/a&gt;

&amp;rdquo;
in 1986.&lt;/p&gt;
&lt;p&gt;This is a short paper, with little text, because most of it is listing of data structures and diagrams of C language &lt;code&gt;struct&lt;/code&gt;&amp;rsquo;s pointing at each other.
Kleiman wanted to have multiple file systems in Unix, but wanted the file systems to be able to share interfaces and internal memory, if at all possible.
Specifically, he wanted a design that provided&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;one common interface with multiple implementations,&lt;/li&gt;
&lt;li&gt;supporting BSD FFS, but also NFS and RFS, two remote filesystems, and Non-Unix filesystems, specifically MS-DOS,&lt;/li&gt;
&lt;li&gt;with the operations being defined by the interface being atomic.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;And the implementations should be able to handle memory and structures dynamically, without performance impact,
reentrant and multicore capable, and somewhat object-oriented.&lt;/p&gt;
&lt;h1 id=&#34;two-abstractions&#34;&gt;
    &lt;a href=&#34;#two-abstractions&#34;&gt;
	Two abstractions
    &lt;/a&gt;
&lt;/h1&gt;
&lt;p&gt;He looked at the various operations, and decided to provide two major abstractions:
The filesystem (&lt;code&gt;vfs&lt;/code&gt;, virtual filesystem) and the inode (&lt;code&gt;vnode&lt;/code&gt;, virtual inode), representing a filesystem and a file.&lt;/p&gt;
&lt;p&gt;In true C++ style (but expressed in C), we get a virtual function table for each type, representing the class:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;For the &lt;code&gt;vfs&lt;/code&gt; type, this is a &lt;code&gt;struct vfsops&lt;/code&gt;,
a collection of function pointers with operations such as &lt;code&gt;mount&lt;/code&gt;, &lt;code&gt;unmount&lt;/code&gt;, &lt;code&gt;sync&lt;/code&gt; and &lt;code&gt;vget&lt;/code&gt;.
Later in the paper, prototypes and functionality of these functions are explained.&lt;/li&gt;
&lt;li&gt;For the &lt;code&gt;vnode&lt;/code&gt; type, likewise, we get &lt;code&gt;struct vnodeops&lt;/code&gt;.
The functions here are &lt;code&gt;open&lt;/code&gt;, &lt;code&gt;rdwr&lt;/code&gt; and &lt;code&gt;close&lt;/code&gt;, of course, but also &lt;code&gt;create&lt;/code&gt;, &lt;code&gt;unlink&lt;/code&gt;, and &lt;code&gt;rename&lt;/code&gt;.
Some functions are specific to a filetype such as &lt;code&gt;readlink&lt;/code&gt;, &lt;code&gt;mkdir&lt;/code&gt;, &lt;code&gt;readdir&lt;/code&gt; and &lt;code&gt;rmdir&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Actual mounts are being tracked in &lt;code&gt;vfs&lt;/code&gt; objects, which point to the operations applicable to this particular subtree with their &lt;code&gt;struct vfsops *&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Similarly, open files are being tracked in &lt;code&gt;vnode&lt;/code&gt; instances, which again, among other things, have a &lt;code&gt;struct *vnodeops&lt;/code&gt; pointer.
&lt;code&gt;vnodes&lt;/code&gt; are part of their &lt;code&gt;vfs&lt;/code&gt;, so they also have &lt;code&gt;struct *vfs&lt;/code&gt; to their filesystem instance.&lt;/p&gt;
&lt;p&gt;Both, the &lt;code&gt;vfs&lt;/code&gt; and the &lt;code&gt;vnode&lt;/code&gt; need to provide a way for the implementation to store implementation specific data (&amp;ldquo;subclass private fields&amp;rdquo;).
So both structures end with &lt;code&gt;caddr_t ...data&lt;/code&gt; pointers.
That is, the private data is not part of the virtual structure, but located elsewhere and pointed to.&lt;/p&gt;
&lt;h2 id=&#34;vnodes-in-action&#34;&gt;
    &lt;a href=&#34;#vnodes-in-action&#34;&gt;
	Vnodes in action
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/2023/05/vfs-vnode-structures.png&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;


&lt;em&gt;One full page in the paper is dedicated to showing the various structures pointing at each other.
What looks confusing at first glance is actually pretty straightforward and elegant, once you trace it out.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Kleiman sets out to explain how things work using the &lt;code&gt;lookuppn()&lt;/code&gt; function, which replaces the older &lt;code&gt;namei()&lt;/code&gt; function from traditional Unix.
Analogous to &lt;code&gt;namei()&lt;/code&gt;, the function consumes a path name, and returns a &lt;code&gt;struct vnode *&lt;/code&gt; to the vnode represented by that pathname.&lt;/p&gt;
&lt;p&gt;Pathname traversal starts at the root vnode or the current directory vnode for the current process,
depending on the first character of a pathname being &lt;code&gt;/&lt;/code&gt; or not.&lt;/p&gt;
&lt;p&gt;The function then takes the next pathname component, iteratively, and calls the &lt;code&gt;lookup&lt;/code&gt; function for the current vnode.
This function takes a pathname component, and a current &lt;code&gt;vnode&lt;/code&gt; assuming it is a directory.
It then returns the &lt;code&gt;vnode&lt;/code&gt; representing that component.&lt;/p&gt;
&lt;p&gt;If a directory is a mountpoint, it has &lt;code&gt;vfsmountedhere&lt;/code&gt; set.
This is a &lt;code&gt;struct vfs *&lt;/code&gt;. &lt;code&gt;lookuppn&lt;/code&gt; follows the pointer,
and can call the &lt;code&gt;root&lt;/code&gt; function for that &lt;code&gt;vfs&lt;/code&gt; to get the root &lt;code&gt;vnode&lt;/code&gt; for that filesystem, replacing the current &lt;code&gt;vnode&lt;/code&gt; being worked on.&lt;/p&gt;
&lt;p&gt;The inverse must also be possible:
When resolving a &amp;ldquo;&lt;code&gt;..&lt;/code&gt;&amp;rdquo; component and the current &lt;code&gt;vnode&lt;/code&gt; has a root flag set in its &amp;ldquo;flags&amp;rdquo; field,
we go from the current &lt;code&gt;vnode&lt;/code&gt; to the &lt;code&gt;vfs&lt;/code&gt; following the &lt;code&gt;vfsmountedhere&lt;/code&gt; pointer.
Then we can use the &lt;code&gt;vnodecovered&lt;/code&gt; field in that &lt;code&gt;vfs&lt;/code&gt; to get the &lt;code&gt;vnode&lt;/code&gt; of the superior filesystem.&lt;/p&gt;
&lt;p&gt;In any case, upon successful completion, a &lt;code&gt;struct vnode*&lt;/code&gt; representing the consumed pathname is returned.&lt;/p&gt;
&lt;h2 id=&#34;new-system-calls&#34;&gt;
    &lt;a href=&#34;#new-system-calls&#34;&gt;
	New system calls
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;In order to make things work,
and to make things work efficiently, a few new system calls had to be added to round out the interfaces.&lt;/p&gt;
&lt;p&gt;It is here in Unix history that we get &lt;code&gt;statfs&lt;/code&gt; and &lt;code&gt;fstatfs&lt;/code&gt;, to get an interface to filesystems in userland.
We also gain &lt;code&gt;getdirentries&lt;/code&gt; (plural) to get multiple directory entries at once (depending on the size of the buffer provided),
which makes directory reading faster a lot for remote filesystems.&lt;/p&gt;
&lt;h1 id=&#34;in-linux&#34;&gt;
    &lt;a href=&#34;#in-linux&#34;&gt;
	In Linux
    &lt;/a&gt;
&lt;/h1&gt;
&lt;p&gt;Looking at the Linux kernel source, we can find the general structure of Kleiman&amp;rsquo;s design,
even if the complexity and richness of the Linux kernel obscure most of it.
The Linux kernel has a wealth of file system types, and added also a lot of functionality that wasn&amp;rsquo;t present in BSD 40 years ago.
So we find a lot more structures and system calls,
implementing namespaces, quotas, attributes, read-only modes, directory name caches, and other things.&lt;/p&gt;
&lt;h2 id=&#34;the-file&#34;&gt;
    &lt;a href=&#34;#the-file&#34;&gt;
	The file
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Still, if you squint, the original structure can still be found:
Linux splits the in-memory structures around files in two, the opened &lt;code&gt;file&lt;/code&gt;, which is an inode with a current position associated,
and the &lt;code&gt;inode&lt;/code&gt;, which is the whole file.&lt;/p&gt;
&lt;p&gt;We find instances of file objects, &lt;code&gt;struct file&lt;/code&gt;, defined
&lt;a href=&#34;https://github.com/torvalds/linux/blob/v6.3/include/linux/fs.h#L942C3-L981&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;here&lt;/a&gt;

.
Among all the other things a file has, it has most notably a field &lt;code&gt;loff_t f_pos&lt;/code&gt;,
an offset (in bytes) from the start of the file,
the current position.&lt;/p&gt;
&lt;p&gt;The file&amp;rsquo;s class is defined via a virtual function table.
We find the pointer as &lt;code&gt;struct file_operations *f_op&lt;/code&gt;,
and the definition &lt;a href=&#34;https://github.com/torvalds/linux/blob/v6.3/include/linux/fs.h#L1754-L1798&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;here&lt;/a&gt;

.
It shows all the things a file can do, most notable, &lt;code&gt;open&lt;/code&gt;, &lt;code&gt;close&lt;/code&gt;, &lt;code&gt;lseek&lt;/code&gt; and then &lt;code&gt;read&lt;/code&gt; and &lt;code&gt;write&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The file also contains pointers to the inode, &lt;code&gt;struct inode *f_inode&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&#34;the-inode&#34;&gt;
    &lt;a href=&#34;#the-inode&#34;&gt;
	The inode
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Operations on files without the need of an offset work on the file as a whole,
defined as &lt;code&gt;struct inode *&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Check the definition &lt;a href=&#34;https://github.com/torvalds/linux/blob/v6.3/include/linux/fs.h#L595-L705&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;here&lt;/a&gt;

.
We see other definitions in here that have no equivalent in BSD from 40 years ago, such as ACLs and attributes.&lt;/p&gt;
&lt;p&gt;We find the inode&amp;rsquo;s class is defined via a virtual function table,
&lt;code&gt;struct inode_operations *i_op&lt;/code&gt;,
and the definition &lt;a href=&#34;https://github.com/torvalds/linux/blob/v6.3/include/linux/fs.h#L1800-L1840&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;here&lt;/a&gt;

.
Again, a lot of them deal with new features such as ACLs and extended attributes,
but we also find those we expect such as &lt;code&gt;link&lt;/code&gt;, &lt;code&gt;unlink&lt;/code&gt;, &lt;code&gt;rename&lt;/code&gt; and so on.&lt;/p&gt;
&lt;p&gt;The inode also contains a pointer to a filesystem, the &lt;code&gt;struct super_block *i_sb&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&#34;the-superblock&#34;&gt;
    &lt;a href=&#34;#the-superblock&#34;&gt;
	The superblock
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;A mountpoint is represented as an instance of &lt;code&gt;struct super_block&lt;/code&gt;,
defined &lt;a href=&#34;https://github.com/torvalds/linux/blob/v6.3/include/linux/fs.h#L1136-L1268&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;here&lt;/a&gt;

.
Again, the class is a &lt;code&gt;struct super_operations *s_op&lt;/code&gt;, defined
&lt;a href=&#34;https://github.com/torvalds/linux/blob/v6.3/include/linux/fs.h#L1886-L1918&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;here&lt;/a&gt;

.&lt;/p&gt;
&lt;p&gt;As an added complexity, there is no finite list of filesystems.
It is instead extensible through loadable modules, so we also have a &lt;code&gt;struct file_system_type&lt;/code&gt;,
&lt;a href=&#34;https://github.com/torvalds/linux/blob/v6.3/include/linux/fs.h#L1886-L1918&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;here&lt;/a&gt;

.
This is basically a class with only one class method as a factory for superblocks, &lt;code&gt;mount&lt;/code&gt;.&lt;/p&gt;
&lt;h1 id=&#34;summary&#34;&gt;
    &lt;a href=&#34;#summary&#34;&gt;
	Summary
    &lt;/a&gt;
&lt;/h1&gt;
&lt;p&gt;Unix changed.
It became a lot more runtime extensive, added a lot of new functionality and gained system calls.
Things became more structured.&lt;/p&gt;
&lt;p&gt;But the original design and data structures conceived by Kleiman and Joy held up, and can still be found in current Linux, 40 years later.
We can point to concrete Linux code, which while looking completely different, is structurally mirroring the original design ideas.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>50 years in filesystems: 1994</title>
      <link>https://blog.koehntopp.info/2023/05/12/50-years-in-filesystems-1994.html</link>
      <pubDate>Fri, 12 May 2023 12:13:14 +0000</pubDate><author>kris-blog@koehntopp.de (Kristian Köhntopp)</author>

      <guid>https://blog.koehntopp.info/2023/05/12/50-years-in-filesystems-1994.html</guid>
      <description>&lt;p&gt;This is part 3 of a series.
The first part is &amp;ldquo;&lt;a href=&#34;https://blog.koehntopp.info/2023/05/05/50-years-in-filesystems-1974.html&#34;&gt;1974&lt;/a&gt;

&amp;rdquo;.
The second part is &amp;ldquo;&lt;a href=&#34;https://blog.koehntopp.info/2023/05/06/50-years-in-filesystems-1984.html&#34;&gt;1984&lt;/a&gt;

&amp;rdquo;.&lt;/p&gt;
&lt;p&gt;Progress is sometimes hard to see, especially when you have been part of it or otherwise lived through it.
Often, it is easier to see if you compare modern educational material, and the problems discussed with older material.
And then look for the research papers and sources that fueled the change.&lt;/p&gt;
&lt;p&gt;In Linux (and Unix in general), this is easy.&lt;/p&gt;
&lt;h1 id=&#34;1994--the-sgi-xfs-filesystem&#34;&gt;
    &lt;a href=&#34;#1994--the-sgi-xfs-filesystem&#34;&gt;
	1994 — The SGI XFS Filesystem
    &lt;/a&gt;
&lt;/h1&gt;
&lt;p&gt;In 1994, the paper &lt;a href=&#34;http://www.scs.stanford.edu/nyu/02fa/sched/xfs.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Scalability in the XFS File System&lt;/a&gt;

 saw publication.
Computers got faster since 1984, and so did storage.
Notably, we are now seeing boxes with multiple CPUs, and with storage reaching into the Terabytes.
The improvements to the 4.3BSD fast filing system (or the modified version in SGI IRIX called EFS) were no longer sufficient.&lt;/p&gt;
&lt;p&gt;SGIs benchmarks cite machines that had large backplanes with many controllers (one benchmark cites a box with 20 SCSI controllers),
many disks (three-digit-numbers of hard drives),
and many CPUs (the benchmarks quote 12 socket machines) with a lot of memory (up to one gigabyte quoted in the benchmarks).&lt;/p&gt;
&lt;p&gt;Filesystems became larger than FFS could handle,
files became larger than FFS could handle,
the number of files per directory led to large lookup times,
central data structures such as allocation bitmaps did no longer scale,
and global locks made concurrent access to the file system with many CPUs inefficient.
SGI set out to design a fundamentally different filesystem.&lt;/p&gt;
&lt;p&gt;Also, the Unix community as a whole was challenged by Cutler and Custer,
who showed with NTFS for Windows NT 4.0 what was possible if you redesign from scratch.&lt;/p&gt;
&lt;h1 id=&#34;requirements&#34;&gt;
    &lt;a href=&#34;#requirements&#34;&gt;
	Requirements
    &lt;/a&gt;
&lt;/h1&gt;
&lt;p&gt;The XFS filesystem was a firework of new ideas, and a large deviation from traditional Unix filesystem design.
The list of new things is long:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Facilitate concurrency with
&lt;ul&gt;
&lt;li&gt;allocation zones&lt;/li&gt;
&lt;li&gt;inode lock splitting&lt;/li&gt;
&lt;li&gt;facilities for large, parallel I/O requests, DMA and Zero-Copy I/O&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Scalability of access by building the filesystem around the concepts of
&lt;ul&gt;
&lt;li&gt;B+-Trees&lt;/li&gt;
&lt;li&gt;Extents: pairs of (start, length) descriptors&lt;/li&gt;
&lt;li&gt;decoupling &amp;ldquo;file write&amp;rdquo; and &amp;ldquo;file layout&amp;rdquo; on disk to allow for contiguous files by using delayed allocation and preallocation.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Introduce a write-ahead log to journal metadata changes
&lt;ul&gt;
&lt;li&gt;log asynchronously to allow for write coalescence&lt;/li&gt;
&lt;li&gt;leveraging the log for recovery, so that recovery time is proportional to the amount of data in flight, not the size of the filesystem&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;XFS was written with these requirements,
and primarily in order to provide a filesystem that could leverage all the performance of large SGI boxes for video editing, video serving and scientific computing.&lt;/p&gt;
&lt;h2 id=&#34;a-logging-filesystem-but-not-a-log-structured-filesystem&#34;&gt;
    &lt;a href=&#34;#a-logging-filesystem-but-not-a-log-structured-filesystem&#34;&gt;
	A logging filesystem, but not a log structured filesystem
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;This is also happening at about the same time as John K. Ousterhout asking
&amp;ldquo;&lt;a href=&#34;https://web.stanford.edu/~ouster/cgi-bin/papers/osfaster.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Why Aren’t Operating Systems Getting Faster As Fast as Hardware?&lt;/a&gt;

&amp;rdquo;.
Ousterhout started to explore the ideas of a log-based filesystem with the experimental Sprite operating system.&lt;/p&gt;
&lt;p&gt;Log-based filesystems are an extremely radical idea that we need to discuss later, even if they originally predate XFS by a bit.
But they weren&amp;rsquo;t very usable originally, because they need different hardware which can offer a lot more disk seeks.
Log structured file system ideas had to become a lot more refined to actually have an impact,
so we are going to discuss them later in the series.&lt;/p&gt;
&lt;h2 id=&#34;what-irix-had-before&#34;&gt;
    &lt;a href=&#34;#what-irix-had-before&#34;&gt;
	What IRIX had before
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;IRIX as coming already with EFS, the specially sauced-up version of BSD FFS that used extents.
It suffered from an 8 GB filesystem size limit, a 2 GB filesize limit, and it could not utilize the full hardware I/O bandwidth,
which made many customers of these fantastically expensive machines somewhat sad.&lt;/p&gt;
&lt;p&gt;Demands for video playback and from the database community led to requirements
that stated the new filesystem needed to support hundreds of TB of disk space,
hundreds of MB/s of I/O bandwidth and many parallel I/O requests in order to be able to saturate the hardware provided,
and all this without running out of CPU.&lt;/p&gt;
&lt;p&gt;The title of the paper is &amp;ldquo;Scalability in the XFS File System&amp;rdquo; and not &amp;ldquo;Implementation of …&amp;rdquo;,
so it is more a show of the features provided and a superficial discussion of the implementation and the design decisions around it.
It is not an in-depth discussion of the implementation,
nor are extensive benchmarks provided.&lt;/p&gt;
&lt;h1 id=&#34;features&#34;&gt;
    &lt;a href=&#34;#features&#34;&gt;
	Features
    &lt;/a&gt;
&lt;/h1&gt;
&lt;h2 id=&#34;large-filesystems&#34;&gt;
    &lt;a href=&#34;#large-filesystems&#34;&gt;
	Large filesystems
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;XFS supports large filesystems.
Previous filesystems use 32-bit pointers to blocks.
At 8 KB block size, with 32-bit block pointers, the limit is 32 TB.&lt;/p&gt;
&lt;p&gt;Moving to 64-bit block pointers would make many data structures multiple of 8 bytes in size, which seemed like a waste.&lt;/p&gt;
&lt;p&gt;For concurrency (see below), XFS introduces the concept of &lt;strong&gt;allocation groups&lt;/strong&gt; (AGs), which are always smaller than 4 GB.
Allocation groups have local instances of the filesystem data structures, for example, inode maps or free block tracking.
These are independently locked and so allow for concurrent operations in different allocation groups.&lt;/p&gt;
&lt;p&gt;Allocation groups also help to save on pointer sizes:
Where possible, AG-relative block numbers are being used, and these always fit into 32-bit pointers.
In fact, a 4G allocation group can have only 1M blocks or fewer blocks (at 4K minimum blocksize),
so a single maximum sized extent within a single AG can be packed into 40 bits (5 bytes).&lt;/p&gt;
&lt;p&gt;The maximum file size and filesystem size is 8 EB (2^63-1).&lt;/p&gt;
&lt;h2 id=&#34;bandwidth-and-concurrency&#34;&gt;
    &lt;a href=&#34;#bandwidth-and-concurrency&#34;&gt;
	Bandwidth and Concurrency
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Concurrent operations are a design goal for XFS.
1994 is the age of 20 MB/s SCSI controllers, but SGI built machines with large chassis that could house many controllers and many drives.
Benchmarks quote machines with an aggregate bandwidth of 480 MB/s delivering file I/O performance of over 370 MB/s with no tuning, including all overheads.
This is quite an impressive result for everyday usage in 1994.&lt;/p&gt;
&lt;p&gt;XFS achieves this using large blocks (4 KB or 8 KB block size), and the concept of extents.&lt;/p&gt;
&lt;h3 id=&#34;extents-and-b-trees&#34;&gt;
    &lt;a href=&#34;#extents-and-b-trees&#34;&gt;
	Extents and B-Trees.
    &lt;/a&gt;
&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Extents&lt;/strong&gt; are a core concept in XFS.
They are tuples, most of the time pairs of &lt;code&gt;(startblock, length)&lt;/code&gt;.
For mapping file blocks to disk blocks (&amp;ldquo;bmap&amp;rdquo;), they are triples &lt;code&gt;(offset, length, startblock)&lt;/code&gt;.
Using truncated values, because of the size limits imposed by the maximum AG size,
they can describe a contiguous sequence of blocks up to 2M blocks in size in 4 bytes,
which is a lot more efficient than what BSD FFS did before.&lt;/p&gt;
&lt;p&gt;Extents also allow XFS to do large I/O requests because they describe sections of contiguous blocks,
making it easy to create read or write requests for several blocks apiece.
It does I/O by default with 64 KB memory buffers, unless special provisions are being made to make them even larger.&lt;/p&gt;
&lt;p&gt;The filesystem assumes an underlying disk structure with striping, and provides a number of 2 or 3 outstanding I/O requests to allow for concurrent I/O.
It checks for backpressure, that is, it checks that the application is actually reading data.
If it does, it issues additional read requests to keep the number of requests in flight at 3 by default,
good for 192 KB in flight at once.&lt;/p&gt;
&lt;p&gt;Groups of Extents can be collected in linear lists, but that will lead to scaling problems.
So XFS uses &lt;strong&gt;B+-Trees&lt;/strong&gt;, which degrade to linear lists if there is only one single index block.&lt;/p&gt;
&lt;p&gt;Usually tuples are indexed on their first value, but for some structures such as free lists, multiple indexes are kept:
It is useful to index free space by &lt;code&gt;startblock&lt;/code&gt; for closeness, but also by &lt;code&gt;length&lt;/code&gt; to fit free spaces in the right size.&lt;/p&gt;
&lt;h3 id=&#34;breaking-the-single-writer-inode-lock&#34;&gt;
    &lt;a href=&#34;#breaking-the-single-writer-inode-lock&#34;&gt;
	Breaking the single-writer inode lock
    &lt;/a&gt;
&lt;/h3&gt;
&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/2023/05/overlapping-write.png&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;


&lt;em&gt;Posix locks the in-memory inode to guarantee &lt;a href=&#34;https://blog.koehntopp.info/2018/11/29/but-is-it-atomic.html&#34;&gt;atomic writes&lt;/a&gt;

.
This makes sure any two large multiple-block writes always happen one-before-the-other.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;XFS also breaks the in-memory inode locks:
Posix demands that large, overlapping, multiple block writes are totally ordered.
When they overlap, it must not happen that there is a block soup of alternating blocks from write A and write B.&lt;/p&gt;
&lt;p&gt;The default implementation in most kernels is simply a file-global lock placed at the in-memory inode, making sure there can be only one writer per inode.
Implementers of databases hate that because it limits the write concurrency on any single file to One.
This is, for example, why Oracle recommends that you make tablespaces from multiple files, each no larger than one GB.&lt;/p&gt;
&lt;p&gt;XFS, in &lt;code&gt;O_DIRECT&lt;/code&gt; mode, removes this lock and allows atomic, concurrent writes, making database people very happy.&lt;/p&gt;
&lt;h2 id=&#34;dynamic-inodes-and-improved-free-space-tracking&#34;&gt;
    &lt;a href=&#34;#dynamic-inodes-and-improved-free-space-tracking&#34;&gt;
	Dynamic Inodes and improved Free Space Tracking
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;With large filesystems, you can never know:
The applications may need a large number of inodes for many small files, or a small number of large files.
Also, what is a good distance between the inode and the data blocks that belong to the file?&lt;/p&gt;
&lt;p&gt;There is no good answer to the first question, and &amp;ldquo;as close as possible&amp;rdquo; is the answer to the second question.
So XFS creates Inodes dynamically, as needed, in chunks of 64 inodes.&lt;/p&gt;
&lt;p&gt;The relatively large inode size of 256 bytes (compared to 128 in BSD FFS and 64 in traditional Unix)
is being compensated by the fact that XFS creates Inodes only as needed, and places them relatively closely to the file start.
This frees up a substantial amount of disk space –
in Unix filesystems with fixed inode counts as much as 3-4% of the disk space can be locked up in pre-allocated inodes.
And even with cylinder groups, there will be considerable distance between an inode and the first data block.&lt;/p&gt;
&lt;p&gt;Because inodes can reside anywhere on the disk and not just behind the superblock, they need to be tracked.
XFS does with one B+-tree per allocation group.
The tree is indexed by the start block, and records for each inode in the chunk if it is available or in-use.
The inodes themselves are not kept in the tree, but in the actual chunks which are close to the file data.&lt;/p&gt;
&lt;p&gt;Similarly, free space is tracked in chunks, and kept in per-AG trees, indexed twice: by start block and by length.&lt;/p&gt;
&lt;h2 id=&#34;write-ahead-log&#34;&gt;
    &lt;a href=&#34;#write-ahead-log&#34;&gt;
	Write-Ahead Log
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Recovering a large filesystem after a crash can be slow.
The recovery time is proportional to the size of the filesystem, and the number of files in it,
because the system basically has to scan the entire filesystem and rebuild the directory tree in order to ensure things are consistent.
With XFS, the filesystem also is a lot more fragile, as it provides a variable number of inodes, spread out non-contiguously over the disk.
Recovering them would be extra expensive.&lt;/p&gt;
&lt;p&gt;Using write-ahead logging for metadata, this can be avoided most of the time.
Recovery time is proportional to the size of the log, that is, the amount of data in flight at the time of the crash.&lt;/p&gt;
&lt;p&gt;The log contains log entries containing a descriptor header and a full image of all changed metadata structures:
inodes, directory blocks, free extent tree blocks, inode allocation tree blocks, allocation group blocks, and the superblock.
Because full images are stored in the block, recovery is simple: the recovery process simply copies these new, changes images into the place where they are supposed to be, without needing to understand what kind of structure it changes.&lt;/p&gt;
&lt;p&gt;The trust of the authors into the log was huge:
Initially XFS had no &lt;code&gt;fsck&lt;/code&gt; program.
This turned out to be overly optimistic, and so now &lt;code&gt;xfs_repair&lt;/code&gt; exists.&lt;/p&gt;
&lt;h3 id=&#34;metadata-update-performance&#34;&gt;
    &lt;a href=&#34;#metadata-update-performance&#34;&gt;
	Metadata update performance
    &lt;/a&gt;
&lt;/h3&gt;
&lt;p&gt;XFS is logging metadata updates, which means they need to be written to the filesystem log.
By default, this log is placed inline, in the filesystem.
But it is also possible to take it out, and put onto other media, for example, flash storage or battery-backed memory.&lt;/p&gt;
&lt;p&gt;Writes to the log are asynchronous, if possible, but with partitions serving NFS they cannot be.
Asynchronous writes allow for write batching, with speeds things up.
But NFS servers profit a lot from accelerated log storage.&lt;/p&gt;
&lt;p&gt;Because all metadata updates need to be logged, it can happen that intense metadata operations flood the log.
A &lt;code&gt;rm -rf /usr/src/linux&lt;/code&gt; for example is not an operation where XFS is particularly fast, because the metadata update stream will eventually overflow the log.
And because everything else in XFS is parallel by AG, the log is usually the only source of contention.&lt;/p&gt;
&lt;h2 id=&#34;large-files-and-sparse-files&#34;&gt;
    &lt;a href=&#34;#large-files-and-sparse-files&#34;&gt;
	Large files and sparse files
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;In FFS, files are mapped by the classical dynamic array, with direct blocks and up to three levels of indirect blocks.
With 64-bit filesize, this becomes unwieldy: there will be more than three levels of indirect blocks required,
and a substantial number of blocks would be required what essentially becomes a list of incrementing numbers.
FFS (and EFS) are also forced to layout blocks the moment each block is allocated in the filesystem buffer pool.
So effectively, no attempt to contiguously layout files on disk is being made.
Instead, blocks are placed individually.&lt;/p&gt;
&lt;p&gt;XFS replaces this dynamic array with extents.&lt;/p&gt;
&lt;p&gt;In file placement maps, these mapping extents are triples &lt;code&gt;(blockoffset, length, disk block)&lt;/code&gt;.
These extents are stored in the inode itself until this overflows.
Then XFS starts to root a B+-tree of the mapping extents in the inode, indexed by logical block number for fast seeks.&lt;/p&gt;
&lt;p&gt;This data structure allows compressing a substantial number of blocks (up to 2M blocks) in a single descriptor,
assuming contiguous allocation is possible.
So even large files could be stored in very few extents, in the optimal case one extent per AG.&lt;/p&gt;
&lt;h3 id=&#34;delayed-allocation-and-preallocation-for-contiguous-layout&#34;&gt;
    &lt;a href=&#34;#delayed-allocation-and-preallocation-for-contiguous-layout&#34;&gt;
	Delayed allocation and Preallocation for contiguous layout
    &lt;/a&gt;
&lt;/h3&gt;
&lt;p&gt;XFS also provides a new concept, delayed allocation, in which virtual extents can be allocated in the file system buffer pool.
These are blocks full of yet unwritten data that have not been layouted, and hence lack a physical position.
Only on flush these blocks are layouted, contiguously, and then written out linearly in large writes, to speed things up.&lt;/p&gt;
&lt;p&gt;This is a fundamental change to how the filesystem buffer cache works –
previously it was possible to use &lt;code&gt;(device, physical block number)&lt;/code&gt; to identify buffer cache blocks and prevent duplicate buffer allocation.
When porting XFS to Linux, the Linux kernel initially could not accommodate strategies that do not use such identification in the normal buffer cache, so at first XFS required a separate buffer cache.
This got fixed later, as the porting progressed.&lt;/p&gt;
&lt;p&gt;To ensure that files can be layouted without fragmentation, in a single extent, XFS aggressively preallocates storage for open files.
The default amount of disk space preallocated is dependent on the amount of free space in the filesystem, and can be substantial.&lt;/p&gt;
&lt;p&gt;The internet is littered with questions by XFS users asking where their disk space is, and the answer is always &amp;ldquo;in the open file handles of &lt;code&gt;/var/log&lt;/code&gt;. Also, check the &lt;a href=&#34;https://man7.org/linux/man-pages/man5/xfs.5.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;manpage&lt;/a&gt;

 for &lt;code&gt;allocsize=&lt;/code&gt; and also check &lt;a href=&#34;https://linux-xfs.oss.sgi.narkive.com/jjjfnyI1/faq-xfs-speculative-preallocation&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;/proc/sys/fs/xfs/speculative_prealloc_lifetime&lt;/code&gt;&lt;/a&gt;

.&amp;rdquo;&lt;/p&gt;
&lt;h3 id=&#34;locality&#34;&gt;
    &lt;a href=&#34;#locality&#34;&gt;
	Locality
    &lt;/a&gt;
&lt;/h3&gt;
&lt;p&gt;XFS does not use allocation groups for locality much.
They exist mostly for concurrency.
Instead, file placement is mostly around directories and existing blocks of the current file.
The only exception is &amp;ldquo;new directories&amp;rdquo;, which are placed &amp;ldquo;away&amp;rdquo; from their parent directory by putting them into a different AG.&lt;/p&gt;
&lt;p&gt;In large files, if new extents need to be placed, they go &amp;ldquo;initially near the inode, then near the existing block in the file which is closest to the offset in the file for which we are allocating space&amp;rdquo;, as the paper specifies.
This places the inode close to the start of the file, and blocks added later to whatever is already present.&lt;/p&gt;
&lt;h2 id=&#34;large-directories&#34;&gt;
    &lt;a href=&#34;#large-directories&#34;&gt;
	Large directories
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;In the traditional Unix filesystem and in BSD FFS, directory name lookups are linear operations.
Large directories slow this down a lot, for any kind of pathname to inode translation.&lt;/p&gt;
&lt;p&gt;XFS chose the ubiquitous B+-Tree as a structure for directories, too, but with a quirk:
Since the keys are supposed to be filenames, a variable length structure, they would be completely different from all the other tree implementations in the filesystem.
The XFS authors did not like this idea, so they are hashing the filename into a fixed 4-byte name hash, and then store one or more directory entries as &lt;code&gt;(name, inode)&lt;/code&gt; pairs in the value.&lt;/p&gt;
&lt;p&gt;There was some tradeoff discussion involved in this, but the authors found that short keys allow storing many entries per block,
leading to wide trees, and thus faster lookups.
They boast &amp;ldquo;We can have directories with millions of entries&amp;rdquo;, something that was previously unthinkable in Unix filesystems.&lt;/p&gt;
&lt;h1 id=&#34;a-lot-of-code&#34;&gt;
    &lt;a href=&#34;#a-lot-of-code&#34;&gt;
	A lot of code
    &lt;/a&gt;
&lt;/h1&gt;
&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/2023/05/xfs-scaling.png&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;


&lt;em&gt;XFS Benchmarks in 1994 show nice and welcome linear scaling behavior that utilizes the hardware offered well.
It handles well on large boxes with (for 1994) high core-counts.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;XFS is a large filesystem.
Linux ext2 is only 5000 lines of kernel code (and about 10x this in user-land).
XFS is 50.000 lines of kernel code, and that is without the IRIX volume manager XLV (in Linux, the XFS port uses LVM2 instead).&lt;/p&gt;
&lt;p&gt;XFS was released under the GNU GPL in May 1999, and was ported into the Linux kernel starting in 2001.
As of 2014, it was supported in most Linux distributions and RHEL used it as the default filesystem.
And even in 2024 it is still holding up reasonably well, on HDD and on flash.&lt;/p&gt;
&lt;p&gt;It still is the filesystem with the best scaling behavior, the best concurrency behavior, and the most consistent commit times,
which makes it the preferred filesystem for any kind of database usage.
This is due to the elimination of several global locks that impair concurrent usage and performance in large filesystems,
and due to the consistent use of B+-Tree structures with &lt;code&gt;O(log(n))&lt;/code&gt; scaling behavior where before algorithms with worse scaling behavior have been used.
The use of extents also allows dynamically growing I/O sizes, benefiting throughput,
and together with the novel idea of delayed allocation encourage contiguous file placement.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>50 years in filesystems: 1984</title>
      <link>https://blog.koehntopp.info/2023/05/06/50-years-in-filesystems-1984.html</link>
      <pubDate>Sat, 06 May 2023 12:13:14 +0000</pubDate><author>kris-blog@koehntopp.de (Kristian Köhntopp)</author>

      <guid>https://blog.koehntopp.info/2023/05/06/50-years-in-filesystems-1984.html</guid>
      <description>&lt;p&gt;This is part 2 of a series. The first part is &amp;ldquo;&lt;a href=&#34;https://blog.koehntopp.info/2023/05/05/50-years-in-filesystems-1974.html&#34;&gt;1974&lt;/a&gt;

&amp;rdquo;.&lt;/p&gt;
&lt;p&gt;Progress is sometimes hard to see, especially when you have been part of it or otherwise lived through it.
Often, it is easier to see if you compare modern educational material, and the problems discussed with older material.
And then look for the research papers and sources that fueled the change.&lt;/p&gt;
&lt;p&gt;In Linux (and Unix in general), this is easy.&lt;/p&gt;
&lt;h1 id=&#34;1984--the-bsd-fast-filing-system&#34;&gt;
    &lt;a href=&#34;#1984--the-bsd-fast-filing-system&#34;&gt;
	1984 — The BSD Fast Filing System
    &lt;/a&gt;
&lt;/h1&gt;
&lt;p&gt;The original Unix filesystem was doing well, but also had a large number of obvious problems.
BSD Unix undertook an effort to fix them, and this is documented in the book
&amp;ldquo;&lt;a href=&#34;https://www.amazon.de/Design-Implementation-4-3Bsd-Operating-System/dp/0201061961&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;The Design and Implementation of the 4.3BSD UNIX Operating System&lt;/a&gt;

&amp;rdquo;
by Leffler, McKusick et. al&lt;a href=&#34;http://libgen.rs/book/index.php?md5=61457A629D5DE3B8966141A9D51FE89B&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;.&lt;/a&gt;

&lt;/p&gt;
&lt;p&gt;A more concise, but also more academic discussion can be found in the classic 1984 paper &lt;a href=&#34;https://dsf.berkeley.edu/cs262/FFS.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;A Fast File System for UNIX&lt;/a&gt;

,
which lists Marshall McKusick, Bill Joy (then at Sun), Samuel Leffler (then at LucasFilm) and Robert Fabry as authors.
The paper promises a reimplementation of the Unix filesystem for higher throughput, better allocation and better locality of reference.&lt;/p&gt;
&lt;h2 id=&#34;the-hardware&#34;&gt;
    &lt;a href=&#34;#the-hardware&#34;&gt;
	The hardware
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;It is 1984.
The computers targeted by 4.3BSD are desktop and cabinet workstations.
These are machines with 32-bit data registers and 32-bit address registers.&lt;/p&gt;
&lt;p&gt;External data and address bus sizes vary:
Earlier 68k CPUs had smaller sized buses, but in 1984 the Motorola 68020 debuted.
It was the first 68k to offer buses with the full width of 32 bits, at a budget of ca. 200k transistors on the die.
Later the 68030 integrated the MMU, previously a separate chip,
and the 68040 also integrated the FPU, again previously a separate chip.&lt;/p&gt;
&lt;p&gt;Early Sun workstations, the Sun-3 series, feature these CPUs.
But Sun took the designs from the experimental Berkeley RISC systems and released the Sun-4 series in 1986 with SPARC architecture RISC chips.
SPARC architecture is not without compromises, but was very viable and saw continuous development until after the purchase of Sun by Oracle, which then killed both the SPARC, and later also the Itanium CPU architecture.&lt;/p&gt;
&lt;p&gt;Curt Schimmel discusses the tradeoffs made by SPARC in the MMU, register and memory access design, and why they made sense. See &lt;a href=&#34;https://www.amazon.de/UNIX-Systems-Modern-Architectures-Multiprocessing/dp/0201633388&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;UNIX Systems for Modern Architectures&lt;/a&gt;

&lt;a href=&#34;http://libgen.rs/book/index.php?md5=0E4A02E80A6250838CB1D3C3A1405CAD&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;.&lt;/a&gt;

&lt;/p&gt;
&lt;p&gt;In between, in 1985, the MIPS architecture debuted, which is another series of RISC CPU architectures. It also starts out as a fully 32-bit type of system, and found use in SGI workstations.&lt;/p&gt;
&lt;p&gt;HP had another RISC-type of CPU, the PA-RISC, an outgrowth of their &amp;ldquo;Spectrum&amp;rdquo; research programme, coming to market in 1986 (and later replaced by Intel&amp;rsquo;s failed Itanium).&lt;/p&gt;
&lt;p&gt;Systems pioneer DEC themselves had the VAX, a 32-bit cabinet computer with a CISC CPU, and that since 1977 already.
They would not go RISC until 1992, but then fully 64-bit with the Alpha AXP (&amp;ldquo;DEC Alpha&amp;rdquo;) architecture.
While interesting, this did not last long: with the sale to Compaq in 1998, the CPU was discontinued, and the IP was sold to Intel in 2001.&lt;/p&gt;
&lt;p&gt;In general, workstation type systems in 1984 had main memory in the low two-digit MB range, and ran at clock speeds of two-digit MHz system clocks.&lt;/p&gt;
&lt;h1 id=&#34;43bsds-fast-filing-system&#34;&gt;
    &lt;a href=&#34;#43bsds-fast-filing-system&#34;&gt;
	4.3BSD&amp;rsquo;s Fast Filing System
    &lt;/a&gt;
&lt;/h1&gt;
&lt;h2 id=&#34;the-traditional-filesystems-shortcomings&#34;&gt;
    &lt;a href=&#34;#the-traditional-filesystems-shortcomings&#34;&gt;
	The traditional filesystems shortcomings
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;The 32-bit VAX systems were being used for typical 1980&amp;rsquo;s workstation work, which include things such as image processing or VLSI chip design.
On these systems, the original Unix filesystem showed structural problems in keeping up with file size, I/O speed, and simple number of files.
Also, the tiny 512-byte I/O size slowed disk subsystem performance considerably.&lt;/p&gt;
&lt;p&gt;The paper mentions the strict segregation of filesystem metadata at the front of the file system from the actual data in the back part of the filesystem.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A 150 MB traditional UNIX file system consists of 4 megabytes of inodes followed by 146
megabytes of data.
This organization segregates the inode information from the data; thus accessing a file
normally incurs a long seek from the file’s inode to its data.
Files in a single directory are not typically
allocated consecutive slots in the 4 megabytes of inodes, causing many non-consecutive blocks of inodes to
be accessed when executing operations on the inodes of several files in a directory.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;This defines one major goal for BSD FFS: Better filesystem layout, bringing metadata and data closer together,
storing files in a single directory closer together,
and preventing fragmentation of a file into small fragments that can be loaded only inefficiently.&lt;/p&gt;
&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/2023/05/filesystem-fragmentierung.png&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;


&lt;em&gt;Fragmentation: Initially, four files are being created, each using 2 blocks.
Then the files B and D are being deleted.
The free space is then being reclaimed by the three-block-sized file E, which is stored in non-adjacent blocks.
This causes small disk seeks, and slow I/O.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Another goal stated is to increase disk block size.
Larger disk blocks benefit throughput in two ways:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Larger disk blocks provide larger units of I/O, so more data is transferred in a single I/O operation.&lt;/li&gt;
&lt;li&gt;Larger disk blocks also allow the filesystem to store more file pointers in an indirect block, greatly reducing the number of indirect block accesses.
This is primarily a problem if indirect blocks are not cached in a file system buffer cache.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The paper quotes the throughput of an already marginally optimized, traditional Unix filesystem at around 4% of the theoretical maximum,
which is abysmally bad.
This is mainly attributed to fragmentation, non-contiguous storage of adjacent blocks in a file.
Defragmentation, already suggested in 1976, was discarded as a non-viable idea.
The authors instead aim for a solution that places files sensibly in the first place.&lt;/p&gt;
&lt;h2 id=&#34;bsd-ffs-innovations&#34;&gt;
    &lt;a href=&#34;#bsd-ffs-innovations&#34;&gt;
	BSD FFS innovations
    &lt;/a&gt;
&lt;/h2&gt;
&lt;h3 id=&#34;cylinder-groups-and-understanding-chs&#34;&gt;
    &lt;a href=&#34;#cylinder-groups-and-understanding-chs&#34;&gt;
	Cylinder Groups and understanding CHS
    &lt;/a&gt;
&lt;/h3&gt;
&lt;p&gt;The BSD FFS understands the physical layout of a harddisk, with &lt;a href=&#34;https://en.wikipedia.org/wiki/Cylinder-head-sector&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;cylinders, heads and sectors&lt;/a&gt;

 (CHS).
It divides the disk into cylinder groups, adjacent tracks of all disk heads.&lt;/p&gt;
&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/2023/05/cylinder-groups.png&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;


&lt;em&gt;As the disk rotates, various disk heads reach inside the platter stack like a comb.
Each head marks a track on the disk, which is subdivided into physical disk blocks by the controller hardware.
Together, all tracks marked by all heads form a cylinder.
A cylinder group is a set of consecutive cylinders. (Image: &lt;a href=&#34;https://pages.cs.wisc.edu/~remzi/OSTEP/file-ffs.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OSTEP&lt;/a&gt;

, page 3)&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Each cylinder group becomes a mini-version of a traditional Unix filesystem, with a copy of the superblock, its own local inode area, and local inode and block usage bitmaps.
The usage of bitmaps is also novel, as they replace the free lists used in the traditional filesystem.
As the filesystem has information about the CHS layout, it also makes sure that the superblock is not always placed on the same platter for each copy,
trying to make the filesystem better redundant against harddisk failure.&lt;/p&gt;
&lt;blockquote&gt;
&lt;h1 id=&#34;excursion-raid-and-other-efforts-at-berkeley&#34;&gt;
    &lt;a href=&#34;#excursion-raid-and-other-efforts-at-berkeley&#34;&gt;
	Excursion: Raid and other Efforts at Berkeley
    &lt;/a&gt;
&lt;/h1&gt;
&lt;p&gt;The &lt;a href=&#34;https://www2.eecs.berkeley.edu/Pubs/TechRpts/1987/CSD-87-391.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;RAID paper&lt;/a&gt;

 was published only several years later,
but &lt;a href=&#34;http://web.eecs.umich.edu/~michjc/eecs584/Papers/katz-2010.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;according to Katz&lt;/a&gt;

 was developed also in Berkeley, during the same time frame, 1983/1984.&lt;/p&gt;
&lt;p&gt;Katz also mentions that during that time Stonebraker was around, working on Ingres (a Postgres predecessor),
and refers to his demands for low-commit latency as driving the attempts on improving disk bandwidth with FFS and, later,  RAID.
Serious work on the RAID taxonomy we know today did not begin before 1987, though.&lt;/p&gt;
&lt;p&gt;The RAID paper was used by many startups and storage companies as the foundation of their development,
among them NetApp, and EMC (via Data General&amp;rsquo;s Clariion Disk Array)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;BSD FFS not only understood CHS geometry of disks, but also processor speed and disk rotational speed.
This allowed it to configure and record in the superblock an &lt;a href=&#34;https://en.wikipedia.org/wiki/Interleaving_%28disk_storage%29&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;interleave factor&lt;/a&gt;

 to optimize disk I/O throughput.&lt;/p&gt;
&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/2023/05/interleave.jpg&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;


&lt;em&gt;The harddisk rotates continuously, but the CPU needs time to set up the next transfer.
During this time the head may have moved already past the next block start boundary, and now the system would need to wait one full rotation to be able to write.
Using an appropriate interleave factor, blocks of adjacent numbers are not stored adjacently on disk, but instead other blocks are interleaved in-between.
This gives the CPU enough time to think and set up the next block transfer.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;The faster the CPU, the lower the interleave factor required.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;All of these optimizations became irrelevant relatively quickly the moment harddrives were sold with integrated controllers,
started to lie about their CHS geometry and ultimately as linear block addresses (LBA) took over.
But for ten to 15 years, this provided a nice performance advantage.&lt;/p&gt;
&lt;h3 id=&#34;large-blocks-smaller-fragments-and-tail-packing&#34;&gt;
    &lt;a href=&#34;#large-blocks-smaller-fragments-and-tail-packing&#34;&gt;
	Large blocks, smaller fragments, and tail packing
    &lt;/a&gt;
&lt;/h3&gt;
&lt;p&gt;Internally, FFS uses logical blocks of at least 4 KB size.
Anything with at least 4 KB block size can create files of 4 GB size with at most two levels of indirection.&lt;/p&gt;
&lt;p&gt;Large blocks make for faster I/O, but they also come with storage overhead, as files grow in sizes of blocks.
Since logical blocks in FFS are made up from multiple physical blocks, FFS introduces the concept of fragments to expose the smaller internal physical blocks.
Through tail packing, the ends of multiple files can be stored together in the same logical block, using only as many physical blocks as necessary.&lt;/p&gt;
&lt;p&gt;Additional logic was necessary to prevent a slowly growing file from going through phases of fragment-by-fragment growth and constant re-layouting.
To overcome this, space is being pre-allocated to full logical blocks, and tail packing only happens on file close when the preallocation is canceled.&lt;/p&gt;
&lt;h3 id=&#34;long-seek-layout-policy&#34;&gt;
    &lt;a href=&#34;#long-seek-layout-policy&#34;&gt;
	Long Seek Layout Policy
    &lt;/a&gt;
&lt;/h3&gt;
&lt;p&gt;BSD FFS introduces a number of layout policies that control the placement of new directories, new files and the handling of large files.
Global policies are mostly concerned with choosing a well-suited cylinder group to place data in,
while local policies then handle the placement inside a cylinder group.&lt;/p&gt;
&lt;p&gt;The new filesystem layout has cylinder groups. Each has their own inode table, and free space bitmaps for inodes and blocks.
The filesystem aims to prevent fragmentation.&lt;/p&gt;
&lt;p&gt;This is of course impossible in certain circumstances:
If, for example, a cylinder group is 512 MB in size, and a file larger than 512 MB is to be written, it will use up one inode in that cylinder group, but all available free blocks are gone.
If a second file is to be placed into this cylinder group, the inode can be used, but the data blocks for that file need to be placed somewhere else – which is undesirable.&lt;/p&gt;
&lt;p&gt;It would be better to force a long seek, a switch from one cylinder group to the next, for large files.
The filesystem would profit from forcing such a long seek every megabyte of filesize or so.
This would use up free blocks from one cylinder group to the next, evenly, while at the same time leaving some number of free blocks for other files in each cylinder group.&lt;/p&gt;
&lt;p&gt;This would, of course, fragment a file, on purpose, but also make sure the fragments are sufficiently large to allow large file I/O.
Fragmentation (non-adjacent placement of blocks in a file) is only really a performance problem if the fragments are too small to be read efficiently.&lt;/p&gt;
&lt;h3 id=&#34;directory-layout-policy&#34;&gt;
    &lt;a href=&#34;#directory-layout-policy&#34;&gt;
	Directory Layout Policy
    &lt;/a&gt;
&lt;/h3&gt;
&lt;p&gt;Files in the same directory are often used together.
It is useful to place all files in the same directory together in the same cylinder group.&lt;/p&gt;
&lt;p&gt;Of course, when this is done, it is also necessary to put different directories into different cylinder groups, to ensure even use of the filesystem space available.
That means a shell script such as&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#! /usr/bin/bash
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; i in &lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;seq -w &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt; 10&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;do&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  touch file&lt;span class=&#34;nv&#34;&gt;$i&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  mkdir dir&lt;span class=&#34;nv&#34;&gt;$i&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;done&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;will create ten files named &lt;code&gt;fileXX&lt;/code&gt;, which will all be placed in the same cylinder group as the current directory.&lt;/p&gt;
&lt;p&gt;It will also create ten subdirectories of the current directory named &lt;code&gt;dirXX&lt;/code&gt;.
Each of them will be placed in a different cylinder group, if possible.
FFS will choose the cylinder group that has a greater than average number of free inodes, and the smallest number of directories already in it.&lt;/p&gt;
&lt;p&gt;The actual choice of the inode in a cylinder group is &amp;ldquo;next available&amp;rdquo;, so pretty simple.
But that is not a problem, because the whole cylinder group inode table fits into 8-16 blocks.&lt;/p&gt;
&lt;p&gt;For placement of data blocks, a lot of effort is invested into finding rotationally optimal block, given the needed interleave factor for this machine.&lt;/p&gt;
&lt;p&gt;BSD FFS requires some free space to be available in the filesystem at all times.
Many of its algorithms degenerate to the performance of the traditional file system if the filesystem fills up more than 90%.&lt;/p&gt;
&lt;h2 id=&#34;other-changes-and-improvements&#34;&gt;
    &lt;a href=&#34;#other-changes-and-improvements&#34;&gt;
	Other changes and improvements
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;BSD FFS also removes several limits that came with the traditional filesystem.&lt;/p&gt;
&lt;h3 id=&#34;long-inode-numbers-and-block-addresses&#34;&gt;
    &lt;a href=&#34;#long-inode-numbers-and-block-addresses&#34;&gt;
	Long Inode Numbers and Block Addresses
    &lt;/a&gt;
&lt;/h3&gt;
&lt;p&gt;For example, &lt;a href=&#34;https://github.com/dspinellis/unix-history-repo/blob/BSD-4_3_Tahoe-Snapshot-Development/.ref-BSD-4_3/usr/src/sys/h/dir.h#L42&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Inode numbers are now 32-bit numbers&lt;/a&gt;

.
This increases the number of files possible per filesystem from 64 K to 4 G.&lt;/p&gt;
&lt;p&gt;The size of an &lt;a href=&#34;https://github.com/dspinellis/unix-history-repo/blob/BSD-4_3_Tahoe-Snapshot-Development/.ref-BSD-4_3/usr/src/sys/h/inode.h#L40-L59&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;inode&lt;/a&gt;

 has doubled:
It is now &lt;a href=&#34;https://github.com/dspinellis/unix-history-repo/blob/BSD-4_3_Tahoe-Snapshot-Development/.ref-BSD-4_3/usr/src/sys/h/inode.h#L61-L65&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;forced to be 128 bytes&lt;/a&gt;

 in size (with 20 unused bytes)
Also, disk block addresses are now 4 bytes.
At 4 KB block size, this is sufficient to account for 4 G blocks, or a maximum of 16 TB filesystem size.&lt;br&gt;
File length is recorded in a &lt;code&gt;quad&lt;/code&gt;, allowing for more than 4 G individual filesize.&lt;/p&gt;
&lt;p&gt;Inodes now contain 12 direct blocks, and three types of indirect blocks.
At 4 KB block size, this is good for 1024 block addresses per indirect block, resulting in
&lt;code&gt;12 + 1024 + 1024^2 + 1024^3 = 1074791436&lt;/code&gt; blocks per file, or a maximum filesize just north of 4 TB.&lt;/p&gt;
&lt;p&gt;Unix User-ID and Group-ID are still limited to a short, limiting the number of users and groups per system to 64 K.&lt;/p&gt;
&lt;p&gt;Space has been preallocated for 8-byte timestamps, even if the time types in the inode are still limited to 4 bytes.&lt;/p&gt;
&lt;h3 id=&#34;long-filenames&#34;&gt;
    &lt;a href=&#34;#long-filenames&#34;&gt;
	Long filenames
    &lt;/a&gt;
&lt;/h3&gt;
&lt;p&gt;The traditional filesystem has directory slots of a fixed 16-byte length,
with 2 bytes for the inode number and 14 bytes for the filename.&lt;/p&gt;
&lt;p&gt;BSD FFS defined a &lt;a href=&#34;https://github.com/dspinellis/unix-history-repo/blob/BSD-4_3_Tahoe-Snapshot-Development/.ref-BSD-4_3/usr/src/sys/h/inode.h#L61-L65&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;more complex directory entry structure&lt;/a&gt;

.
A single entry contains a 4-byte inode number, a 2-byte record length and a 2-byte name length, and then the actual filename.
Filenames are limited to 255 bytes for each pathname component,
and directory entries are rounded up in length to the next 4-byte boundary.&lt;/p&gt;
&lt;p&gt;Directories are still essentially a linked list, and searching for names in large directories is slow.&lt;/p&gt;
&lt;p&gt;Searching for free space in directories is now more complicated:
To create a new directory entry, we now need to search through the directory from the start, trying to find a gap in the current structure that is large enough for the name we are being asked to create.
If none is found, the new name is appended at the end, growing the directory in size.&lt;/p&gt;
&lt;p&gt;Free space in directories is never reclaimed through compaction, only eventually re-used if a new name happens to fit.&lt;/p&gt;
&lt;h3 id=&#34;symlinks&#34;&gt;
    &lt;a href=&#34;#symlinks&#34;&gt;
	Symlinks
    &lt;/a&gt;
&lt;/h3&gt;
&lt;p&gt;The traditional filesystem allowed a file to have multiple names, using the &lt;code&gt;link()&lt;/code&gt; system call and the hardlink mechanism.
Hardlinks are limited in number (a &lt;code&gt;short&lt;/code&gt;, so 64 K names).&lt;/p&gt;
&lt;p&gt;They can be lost accidentally, for example, by saving a hardlinked file with certain editors.
If the editor does write a file as &lt;code&gt;filename.new&lt;/code&gt;, then unlinks the old &lt;code&gt;filename&lt;/code&gt; and moves the new file into place, the hardlinked nature of the file will be modified.&lt;/p&gt;
&lt;p&gt;Hardlinks also reference the original inode of the file multiple times, so they cannot span filesystem boundaries.&lt;/p&gt;
&lt;p&gt;BSD introduces a new filetype (&lt;code&gt;l&lt;/code&gt;, symlink), and places a &amp;ldquo;replacement filename&amp;rdquo; in the linked file, which determines the link target location.
It can be an absolute or relative name (relative to the location of the symlink file).&lt;/p&gt;
&lt;p&gt;This creates a &amp;ldquo;soft&amp;rdquo; or &amp;ldquo;symbolic link.
Trying to access a symlink will kick off a reinterpretation of the filename in &lt;code&gt;namei()&lt;/code&gt; using the replacement filename,
resulting in the attempted &lt;code&gt;open()&lt;/code&gt; system call being deflected to the link target location.&lt;/p&gt;
&lt;p&gt;Since the deflection happens in &lt;code&gt;namei()&lt;/code&gt;, which can traverse filesystem boundaries, the new link type is not subject to the single filesystem limitation.
It is also not counting towards any link count limits.&lt;/p&gt;
&lt;h3 id=&#34;rename-system-call&#34;&gt;
    &lt;a href=&#34;#rename-system-call&#34;&gt;
	Rename System Call
    &lt;/a&gt;
&lt;/h3&gt;
&lt;p&gt;BSD introduces the &lt;code&gt;rename()&lt;/code&gt; system call, which previously needed to be implemented as a library function using calls to &lt;code&gt;unlink()&lt;/code&gt; and &lt;code&gt;link()&lt;/code&gt;.
Since this uses more than one system call, the operation is not atomic:
It is subject to partial execution, and it is subject to malicious interferences, because it is a multistep process.&lt;/p&gt;
&lt;h3 id=&#34;quotas&#34;&gt;
    &lt;a href=&#34;#quotas&#34;&gt;
	Quotas
    &lt;/a&gt;
&lt;/h3&gt;
&lt;p&gt;BSD also introduces the idea of filesystem usage quotas:
These are soft and hard limits on the number of files and the amount of disk space that a user or a group can use.&lt;/p&gt;
&lt;p&gt;In order to implement them in a useful way, the behavior of the filesystem had to be modified:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;It is now a privileged operation to change the owner of a file away from oneself.
Without that, it is possible to create a directory that is only accessible for oneself, and then gift all files in it to another user.
The files would then count against that user&amp;rsquo;s quota.&lt;/li&gt;
&lt;li&gt;Similarly, it is now no longer possible to change the group membership of files to just any group.
Instead, only groups from the user&amp;rsquo;s group set can be used.&lt;/li&gt;
&lt;li&gt;And finally, new directories and files inherit their group from their parent directory, not from a users primary group.
That way, project directories would contain files counting against a project&amp;rsquo;s quota, not a user&amp;rsquo;s primary group quota.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;advisory-locking&#34;&gt;
    &lt;a href=&#34;#advisory-locking&#34;&gt;
	Advisory Locking
    &lt;/a&gt;
&lt;/h3&gt;
&lt;p&gt;Advisory file locking is already introduced in 4.2BSD.
For this, the new &lt;code&gt;flock()&lt;/code&gt; syscall has been implemented.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Locks can be shared (read locks) or exclusive (write locks).&lt;/li&gt;
&lt;li&gt;They always apply to the entire file, and not to byte ranges.&lt;/li&gt;
&lt;li&gt;No deadlock detection is attempted.&lt;/li&gt;
&lt;li&gt;They are tied to a file descriptor.
So when a process dies, its file-handles are automatically closed, which also automatically releases all locks held.
This is very robust, until &lt;code&gt;dup()&lt;/code&gt; and &lt;code&gt;fork()&lt;/code&gt; are coming into play.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Posix later tried to improve on this, introducing a second, completely different system of locks, using &lt;code&gt;fcntl()&lt;/code&gt;.
This is flawed in different ways, but can do byte-ranges, and it implements some rudimentary deadlock detection.&lt;/p&gt;
&lt;p&gt;Kernels that implement both systems such as Linux now have two different,
incompatible file locking implementations that do not know of each other.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://loonytek.com/2015/01/15/advisory-file-locking-differences-between-posix-and-bsd-locks/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;This article&lt;/a&gt;

 discusses all of this some more,
and has example programs.&lt;/p&gt;
&lt;h2 id=&#34;performance&#34;&gt;
    &lt;a href=&#34;#performance&#34;&gt;
	Performance
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;The authors note the following advantages in their paper:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ls&lt;/code&gt; and &lt;code&gt;ls -l&lt;/code&gt; are fast, because the inodes of the files in a single directory are within the same cylinder group.
Hence, reading and listing a directory is very low on seeks, and on seek distance (except for subdirectories, which are guaranteed to be far away).
They measure a 8x speedup for directories without subdirectories.&lt;/li&gt;
&lt;li&gt;Utilization of the theoretical maximal bandwidth increased from 3% in the traditional filesystem to 22% or even 47%, depending on the controller hardware used.
The authors are very proud of the results because they have been achieved on an actual production system with real user production data being layouted,
and not on a synthetic benchmark layout. Throughput is stable over the lifetime of the filesystem, as its file population changes.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This solves the main drivers for the improvements: Better throughput and a stable layout that does not degrade performance over time.&lt;/p&gt;
&lt;p&gt;Additionally, a number of quality-of-life enhancements have been made, enabling more comfortable working in groups, and unlocking new functionality.&lt;/p&gt;
&lt;p&gt;While Linux contains no BSD code, the ext2 filesystem is pretty much an implementation-blind rewrite of the BSD FFS for Linux,
recreating the features as described in the literature without using any BSD code.&lt;/p&gt;
&lt;p&gt;Both BSD FFS and Linux ext2 are still non-logging filesystems that require a filesystem check after a crash.
They also cannot deal well with directories with many entries, and deal only slightly better with deep directory hierarchies.
Additional changes are required to enable truly large filesystems in order to keep up with increasing storage sizes.&lt;/p&gt;
&lt;p&gt;Also, other limitations of more hidden nature still apply:
Several places in the filesystem code are guarded by locks that make scaling certain operations hard on systems with high concurrency.&lt;/p&gt;
&lt;p&gt;It would take another ten years, until 1994, for SGI&amp;rsquo;s XFS to tackle these things.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>50 years in filesystems: 1974</title>
      <link>https://blog.koehntopp.info/2023/05/05/50-years-in-filesystems-1974.html</link>
      <pubDate>Fri, 05 May 2023 12:13:14 +0000</pubDate><author>kris-blog@koehntopp.de (Kristian Köhntopp)</author>

      <guid>https://blog.koehntopp.info/2023/05/05/50-years-in-filesystems-1974.html</guid>
      <description>&lt;p&gt;Progress is sometimes hard to see, especially when you have been part of it or otherwise lived through it.
Often, it is easier to see if you compare modern educational material, and the problems discussed with older material.
And then look for the research papers and sources that fueled the change.&lt;/p&gt;
&lt;p&gt;In Linux (and Unix in general), this is easy.&lt;/p&gt;
&lt;h1 id=&#34;1974---unix-v7-file-system&#34;&gt;
    &lt;a href=&#34;#1974---unix-v7-file-system&#34;&gt;
	1974 - Unix V7 File System
    &lt;/a&gt;
&lt;/h1&gt;
&lt;p&gt;We find the Unix Version 7 Research Release in Diomidis Spinellis &lt;a href=&#34;https://github.com/dspinellis/unix-history-repo/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;unix-history-repo&lt;/code&gt;&lt;/a&gt;

.
If we are reading
&lt;a href=&#34;https://www.amazon.de/Design-UNIX-Operating-System-Prentice/dp/0132017997&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;The Design of the Unix Operating System&lt;/a&gt;


by Maurice J. Bach
&lt;a href=&#34;https://www.pdfdrive.com/the-design-of-the-unix-operating-system-maurice-bach-e25830714.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;,&lt;/a&gt;


we would want to look at the
&lt;a href=&#34;https://github.com/dspinellis/unix-history-repo/tree/Research-V7-Snapshot-Development&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Research V7 Snapshot&lt;/a&gt;


branch of that Repository.&lt;/p&gt;
&lt;h2 id=&#34;machines&#34;&gt;
    &lt;a href=&#34;#machines&#34;&gt;
	Machines
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;It is 1974.
Computers have a single &amp;ldquo;core&amp;rdquo;, the central processing unit.
In some computers, this is no longer a device with parts, such as boards for the arithmetic logic unit, registers, sequencers and microcode memory, but a single integrated chip.
The new devices are called microcomputers, as opposed to the older generation of minicomputers.
These new CPUs sometimes have thousands of transistors on a single chip.&lt;/p&gt;
&lt;h2 id=&#34;kernels&#34;&gt;
    &lt;a href=&#34;#kernels&#34;&gt;
	Kernels
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;In Unix, we are dealing with system resources as configured in a header file.
&lt;a href=&#34;https://github.com/dspinellis/unix-history-repo/blob/Research-V7-Snapshot-Development/usr/sys/h/param.h&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Default values&lt;/a&gt;


are shown here, and the data structures are arrays, with the values shown being the respective array sizes.
To change them, you edit the file, recompile and relink the kernel, and then reboot.&lt;/p&gt;
&lt;p&gt;We have a file system buffer cache using &lt;code&gt;NBUF&lt;/code&gt; (29) disk blocks of 512 bytes.
We have an inode array of &lt;code&gt;NINODE&lt;/code&gt; (200) entries, and we can mount up to &lt;code&gt;NMOUNT&lt;/code&gt; (8) filesystems concurrently.
A user can have &lt;code&gt;MAXUPRC&lt;/code&gt; (25) processes running, for a total of &lt;code&gt;NPROC&lt;/code&gt; (150) system processes.
Each process can have up to &lt;code&gt;NOFILE&lt;/code&gt; (20) files open.&lt;/p&gt;
&lt;p&gt;Reading Bach and the original V7 sources is interesting, despite the fact that things are completely outdated, because a lot of core concepts are much clearer,
and a lot of structures are a lot simpler.
Sometimes even archaic.
But this is what defines the behavior of Unix File Systems, to this day, because the accidental behavior of V7 Unix became immortalized in the POSIX standard,
and every file system after had to conform to it.
Check &lt;a href=&#34;https://blog.koehntopp.info/2018/11/29/but-is-it-atomic.html#source-dive-why-are-writes-atomic&#34;&gt;But Is It Atomic?&lt;/a&gt;

 for an example.&lt;/p&gt;
&lt;h1 id=&#34;core-concepts&#34;&gt;
    &lt;a href=&#34;#core-concepts&#34;&gt;
	Core Concepts
    &lt;/a&gt;
&lt;/h1&gt;
&lt;p&gt;The basic concepts and structures of Unix Filesystems are from this time, and from this system.
Some of them exist even in modern systems.&lt;/p&gt;
&lt;p&gt;The disk is an array of blocks. It begins at block 0, and stretches to block n.
At the beginning of the filesystem we find the &lt;a href=&#34;https://github.com/dspinellis/unix-history-repo/blob/Research-V7-Snapshot-Development/usr/sys/h/filsys.h&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;superblock&lt;/a&gt;

.
It is located &lt;a href=&#34;https://github.com/dspinellis/unix-history-repo/blob/Research-V7-Snapshot-Development/usr/sys/h/param.h#L89&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;at block number 1&lt;/a&gt;

 of the filesystem.
The &lt;a href=&#34;https://github.com/dspinellis/unix-history-repo/blob/Research-V7-Snapshot-Development/usr/sys/sys/sys3.c#L128-L192&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;mount system call&lt;/a&gt;

 finds an empty &lt;a href=&#34;https://github.com/dspinellis/unix-history-repo/blob/Research-V7-Snapshot-Development/usr/sys/h/mount.h#L6-L11&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;mount&lt;/a&gt;

 structure, reads the superblock off disk and keeps it as part of the mount structure.&lt;/p&gt;
&lt;h2 id=&#34;inode&#34;&gt;
    &lt;a href=&#34;#inode&#34;&gt;
	Inode
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;The in-memory superblock has fields for an array of inodes (a &lt;code&gt;short&lt;/code&gt;) on disk.
An &lt;a href=&#34;https://github.com/dspinellis/unix-history-repo/blob/Research-V7-Snapshot-Development/usr/sys/h/ino.h&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;inode&lt;/a&gt;

 is a structure that describes a file as a variable length array of blocks, and some metadata.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;dinode&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;short&lt;/span&gt;	&lt;span class=&#34;n&#34;&gt;di_mode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;  &lt;span class=&#34;cm&#34;&gt;/* mode and type of file */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;kt&#34;&gt;short&lt;/span&gt;	&lt;span class=&#34;n&#34;&gt;di_nlink&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;    	      &lt;span class=&#34;cm&#34;&gt;/* number of links to file */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;kt&#34;&gt;short&lt;/span&gt;	&lt;span class=&#34;n&#34;&gt;di_uid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;      	      &lt;span class=&#34;cm&#34;&gt;/* owner&amp;#39;s user id */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;kt&#34;&gt;short&lt;/span&gt;	&lt;span class=&#34;n&#34;&gt;di_gid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;      	      &lt;span class=&#34;cm&#34;&gt;/* owner&amp;#39;s group id */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;kt&#34;&gt;off_t&lt;/span&gt;	&lt;span class=&#34;n&#34;&gt;di_size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;     	      &lt;span class=&#34;cm&#34;&gt;/* number of bytes in file */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt;  	&lt;span class=&#34;n&#34;&gt;di_addr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;40&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;	  &lt;span class=&#34;cm&#34;&gt;/* disk block addresses */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;kt&#34;&gt;time_t&lt;/span&gt;	&lt;span class=&#34;n&#34;&gt;di_atime&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;   	  &lt;span class=&#34;cm&#34;&gt;/* time last accessed */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;kt&#34;&gt;time_t&lt;/span&gt;	&lt;span class=&#34;n&#34;&gt;di_mtime&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;   	  &lt;span class=&#34;cm&#34;&gt;/* time last modified */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;kt&#34;&gt;time_t&lt;/span&gt;	&lt;span class=&#34;n&#34;&gt;di_ctime&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;   	  &lt;span class=&#34;cm&#34;&gt;/* time created */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#define	INOPB	8	&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;/* 8 inodes per block */&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;/*
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * the 40 address bytes:
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; *	39 used; 13 addresses
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; *	of 3 bytes each.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;em&gt;The inode as it appears on disk. 8 inodes fit into a 512-byte disk block, so they are aligned at 64 byte boundaries.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;The inode array on the filesystem has a &lt;code&gt;short&lt;/code&gt; count, so there can be up to 65535 inodes in a filesystem.
As each file requires an inode, there can only be that many files per filesystem.&lt;/p&gt;
&lt;p&gt;Each file has some fixed properties:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;(2 bytes) a &lt;code&gt;mode&lt;/code&gt; (the file type and access permissions combined).&lt;/li&gt;
&lt;li&gt;(2 bytes) a link count (&lt;code&gt;nlink&lt;/code&gt;), the number of names this file has.&lt;/li&gt;
&lt;li&gt;(2 bytes) a &lt;code&gt;uid&lt;/code&gt;, the owner.&lt;/li&gt;
&lt;li&gt;(2 bytes) a &lt;code&gt;gid&lt;/code&gt;, the owner&amp;rsquo;s group id.&lt;/li&gt;
&lt;li&gt;(4 bytes) a &lt;code&gt;size&lt;/code&gt;, the length of the file in bytes (defined as an &lt;code&gt;off_t&lt;/code&gt;, a &lt;code&gt;long&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;(40 bytes) an &lt;code&gt;addr&lt;/code&gt; array of disk block addresses&lt;/li&gt;
&lt;li&gt;(3x 4 bytes) three times, an &lt;code&gt;atime&lt;/code&gt; (access time), &lt;code&gt;mtime&lt;/code&gt; (modification time) and &lt;code&gt;ctime&lt;/code&gt; (supposedly create time, but really the time of the last inode change).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;for a total size of 64 bytes.&lt;/p&gt;
&lt;h2 id=&#34;bmap&#34;&gt;
    &lt;a href=&#34;#bmap&#34;&gt;
	bmap()
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;addr&lt;/code&gt; array contains 40 bytes, but it stores 13 disk block addresses, each using 3 bytes.
This is good for 24 bits, or 16 megablocks of 512 bytes, each, for a total filesystem size of 8M kilobytes, or 8 GB.&lt;/p&gt;
&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/2023/05/rl02-front.jpg&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;


&lt;em&gt;Front panel of a PDP-11 RL02 disk drive, from &lt;a href=&#34;https://www.pdp-11.nl/peripherals/disk/rl-info.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;pdp-11.nl&lt;/a&gt;

&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;For comparison, a &lt;a href=&#34;https://www.pdp-11.nl/peripherals/disk/rl-info.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;PDP-11 RL02K disk cartridge&lt;/a&gt;

 held 10.4 MB,
but the newer &lt;a href=&#34;https://lastin.dti.supsi.ch/VET/disks/RA92/EK-ORA90-UG.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;RA92&lt;/a&gt;

 could store 1.5 GB.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;addr&lt;/code&gt; array is being used in the &lt;a href=&#34;https://github.com/dspinellis/unix-history-repo/blob/Research-V7-Snapshot-Development/usr/sys/sys/subr.c#L9-L120&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;bmap() function&lt;/a&gt;

.
The function consumes an inode (&lt;code&gt;ip&lt;/code&gt;) and a logical block number &lt;code&gt;bn&lt;/code&gt; and returns a physical block number.
That is, it maps a block in a file to a block on a disk, hence the name.&lt;/p&gt;
&lt;p&gt;The first 10-block pointers are stored directly in the inode.
That is, to access for example block 0, &lt;code&gt;bmap()&lt;/code&gt; &lt;a href=&#34;https://github.com/dspinellis/unix-history-repo/blob/Research-V7-Snapshot-Development/usr/sys/sys/subr.c#L40&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;will look up&lt;/a&gt;

 &lt;code&gt;di_addr[0]&lt;/code&gt; in the inode and return this block number.&lt;/p&gt;
&lt;p&gt;Additional blocks are stored in an indirect block, and the indirect block is stored in the inode.
For even larger files, a double indirect block is allocated, and points to more indirect blocks, and finally very large files need even triple indirect blocks.&lt;/p&gt;
&lt;p&gt;The code &lt;a href=&#34;https://github.com/dspinellis/unix-history-repo/blob/Research-V7-Snapshot-Development/usr/sys/sys/subr.c#L60-L73&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;first determines the number of indirections&lt;/a&gt;

,
grab the &lt;a href=&#34;https://github.com/dspinellis/unix-history-repo/blob/Research-V7-Snapshot-Development/usr/sys/sys/subr.c#L78&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;appropriate indirect block&lt;/a&gt;

,
and then &lt;a href=&#34;https://github.com/dspinellis/unix-history-repo/blob/Research-V7-Snapshot-Development/usr/sys/sys/subr.c#L91-L112&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;resolve the indirection&lt;/a&gt;

 the appropriate number of times.&lt;/p&gt;
&lt;p&gt;This results in the following famous picture:&lt;/p&gt;
&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/1994/02/filestructure.gif&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;

&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Original Unix file structure with increasing numbers of indirect accesses for increasingly larger files.
This forms a compressed array, where short files can be accessed directly with data from the inode, whereas larger files are using increasingly indirect access.
For performance, it is crucial to keep indirect blocks in the file system buffer cache.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;How this scales is dependent on the block size (512 bytes back then, 4096 bytes these days), and the size of a block number in bytes (originally 3 bytes, later 4 or even 8 bytes).&lt;/p&gt;
&lt;h2 id=&#34;atomic-writes&#34;&gt;
    &lt;a href=&#34;#atomic-writes&#34;&gt;
	Atomic writes
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Writes to files happen under a lock, so they are always atomic.
This is true even for long writes, which span multiple block boundaries, and is discussed at length in
&lt;a href=&#34;https://blog.koehntopp.info/2018/11/29/but-is-it-atomic.html#source-dive-why-are-writes-atomic&#34;&gt;But Is It Atomic?&lt;/a&gt;

.&lt;/p&gt;
&lt;p&gt;This also means that even with multiple writer processes, on a single file there can be only ever one disk write active at any point in time.
This is very inconvenient for authors of database systems.&lt;/p&gt;
&lt;h2 id=&#34;naming-files&#34;&gt;
    &lt;a href=&#34;#naming-files&#34;&gt;
	Naming files
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;A directory is a file with a special type (directory), and a &lt;a href=&#34;https://github.com/dspinellis/unix-history-repo/blob/Research-V7-Snapshot-Development/usr/sys/h/dir.h&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;fixed record structure&lt;/a&gt;

.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-C&#34; data-lang=&#34;C&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#ifndef	DIRSIZ
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#define	DIRSIZ	14
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#endif
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt;	&lt;span class=&#34;n&#34;&gt;direct&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;kt&#34;&gt;ino_t&lt;/span&gt;	&lt;span class=&#34;n&#34;&gt;d_ino&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt;	&lt;span class=&#34;n&#34;&gt;d_name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;DIRSIZ&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;em&gt;A directory entry contains an inode number (an &lt;code&gt;unsigned int&lt;/code&gt;), and a filename which can be up to 14 bytes long. This fits 32 directory entries into a disk block, and 320 directory entries into the 10 disks blocks that can being referenced by the direct blocks of a directory file.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;The lower filesystem is a sea of files.
Files have no names, only numbers.&lt;/p&gt;
&lt;p&gt;The upper filesystem uses a special type of file, with a simple 16-byte record structure,
to assign a name of up to 14 characters to a file.
A special function, &lt;code&gt;namei()&lt;/code&gt;
&lt;a href=&#34;https://github.com/dspinellis/unix-history-repo/blob/Research-V7-Snapshot-Development/usr/sys/sys/nami.c#L9-L200&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;converts a filename into an inode number&lt;/a&gt;

.&lt;/p&gt;
&lt;p&gt;Pathnames passed to &lt;code&gt;namei()&lt;/code&gt; are hierarchical:
they can contain &lt;code&gt;/&lt;/code&gt; as a path separator, and they are being terminated by &lt;code&gt;\0 (nul)&lt;/code&gt;.
&lt;a href=&#34;https://github.com/dspinellis/unix-history-repo/blob/Research-V7-Snapshot-Development/usr/sys/sys/nami.c#L37-L41&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Pathnames&lt;/a&gt;

 either start with &lt;code&gt;/&lt;/code&gt;,
in which case the traversal begins at the filesystem root, making the filename absolute.
Or they do not, in which case traversal starts at &lt;code&gt;u.u_cdir&lt;/code&gt;, the current directory.&lt;/p&gt;
&lt;p&gt;The function then consumes pathname component after component,
using the currently active directory and searching linearly for the name of the current component in that directory.
It ends when the last pathname component is found, or if at any stage a component is not found.
It also ends,
if at any point in time, for any directory in the path,
&lt;a href=&#34;https://github.com/dspinellis/unix-history-repo/blob/Research-V7-Snapshot-Development/usr/sys/sys/nami.c#L91&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;we have no x-permission&lt;/a&gt;

.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/dspinellis/unix-history-repo/blob/Research-V7-Snapshot-Development/usr/sys/sys/nami.c#L179&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Some entries are magical&lt;/a&gt;

:
They are mountpoints.
When we encounter them, we change from the directory entry of the current node and filesystem to the root inode of the mounted filesystem.
This makes all filesystems in Unix appear as a single tree, and &amp;ldquo;drives are changed&amp;rdquo; by simply going to a different directory.&lt;/p&gt;
&lt;p&gt;The function ultimately returns a pointer to the inode for the given pathname, creating (or deleting) the inode (and directory entry) if necessary and desired.
It is a centralized point for directory traversal and access permission checks.&lt;/p&gt;
&lt;h1 id=&#34;novel-ideas-and-limits&#34;&gt;
    &lt;a href=&#34;#novel-ideas-and-limits&#34;&gt;
	Novel ideas and Limits
    &lt;/a&gt;
&lt;/h1&gt;
&lt;p&gt;This very early Unix filesystem has a number of very nice properties:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;It presents multiple filesystems as one single unified tree.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Files are structureless arrays of bytes.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;These arrays are stored internally in a variable depth dynamic array, using a system of increasingly deeply nested indirect blocks.
This allows O(1) disk seeks.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Lower filesystem (creating files) and upper filesystem (structuring files into a tree) are clearly separated.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Pathname traversal is the only way to get an inode, and along the way permissions are always checked.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;There are very few characters in filenames that are special, &lt;code&gt;/&lt;/code&gt; and &lt;code&gt;\0 (nul)&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We also have clear limitations:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Files can only have 16M blocks.&lt;/li&gt;
&lt;li&gt;Filesystems can only have 65535 inodes, which is very limited.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;And there are a number of annoying limitations:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;There can be only one writer active per file, which kills concurrency.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Directory lookups are linear scans, so they become very slow for large directories (more than 320 entries).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;There is no system for mandatory file locking.
There are several systems for advisory file locking.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;And a few quirks:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;There is no &lt;code&gt;delete()&lt;/code&gt; system call.
We have &lt;code&gt;unlink()&lt;/code&gt;, which removes a file name,
and files that have zero names and zero open file handles are being automatically collected.
This has a few unusual consequences,
for example, disk space is only freed if a completely unlinked file is also completely closed.
Generations of Unix sysadmins have asked where their disk space is,
when a deleted log file in &lt;code&gt;/var/log&lt;/code&gt; was still kept open by some forgotten process.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Initially there is no &lt;code&gt;mkdir()&lt;/code&gt; and &lt;code&gt;rmdir()&lt;/code&gt; system call, which leads to exploitable race conditions.
This is fixed in later versions of Unix.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;There are a few operations that are accidentally atomic (like the write(2) system call), or have been made atomic after they have been exploited (&lt;code&gt;mknod(2)&lt;/code&gt; and &lt;code&gt;mkdir(2)&lt;/code&gt;).&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Structurally, it is annoying that the inode table and free maps for blocks and inodes are at the beginning of the filesystem, and disk space is allocated linearly from the front of the disk, too.
This leads to a seek intense structure, and enables filesystem fragmentation (in which files are being stored in non-adjacent blocks).&lt;/p&gt;
&lt;p&gt;Traversing a directory structure means reading a directories inode at the beginning of the disk,
going to the data blocks further back,
then reading the next inode of the next pathname component from the beginning of the disk,
and going back the data blocks in the back.
This goes back and forth, once for each pathname component, and is not necessarily fast.&lt;/p&gt;
&lt;h2 id=&#34;today-and-improvements&#34;&gt;
    &lt;a href=&#34;#today-and-improvements&#34;&gt;
	Today, and Improvements
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;The PDP-11 V7 Unix filesystem got a faithful reimplementation as the  &lt;code&gt;minix&lt;/code&gt; filesystem, with all its limitations.
In modern Linux, it has been removed from the kernel source tree because it is no longer useful.&lt;/p&gt;
&lt;p&gt;We will see in a later article about the BSD fast filesystem, how the data can be better layouted on disk,
how we can implement longer filenames, more inodes, and how we can speed things up a bit by taking physical properties of the disk into account.&lt;/p&gt;
&lt;p&gt;Only even newer filesystems will be dealing with linear directory lookup times, single writers or limited file metadata.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Fertig gelesen: UNIX: A History and a Memoir</title>
      <link>https://blog.koehntopp.info/2021/09/05/fertig-gelesen-unix-a-history-and-a-memoir.html</link>
      <pubDate>Sun, 05 Sep 2021 15:47:06 +0000</pubDate><author>kris-blog@koehntopp.de (Kristian Köhntopp)</author>

      <guid>https://blog.koehntopp.info/2021/09/05/fertig-gelesen-unix-a-history-and-a-memoir.html</guid>
      <description>&lt;p&gt;The memoir of Brian Kernighan, and the story of how UNIX came to be and what working at Bell Labs was like at that time:
&lt;a href=&#34;https://www.amazon.de/UNIX-History-English-Brian-Kernighan-ebook/dp/B07ZQHX3R1&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;UNIX: A History and a Memoir&lt;/a&gt;

 is required reading for anyone who wants to know where Unix concepts came from and what ideas were behind its inception.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.amazon.de/UNIX-History-English-Brian-Kernighan-ebook/dp/B07ZQHX3R1&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/2021/09/unix.jpg&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;

&lt;/a&gt;

&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&amp;quot;&lt;a href=&#34;https://www.amazon.de/UNIX-History-English-Brian-Kernighan-ebook/dp/B07ZQHX3R1&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;UNIX: A History and a Memoir&lt;/a&gt;

&amp;quot;, Brian Kernighan&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Kernighan takes us through the history and the setting of Bell Labs, why it existed and what it did.
He explains the hardware of the time, in terms of size, power and capabilities, and why Bell did get involved into writing an Operating System, and the failure of Multics.
Unix inception and its co-evolution with the C language was a kind of response to the Multics project, at the same time pioneering novel ideas and taking tested salvageable concepts from Multics, making something new and much more useful.&lt;/p&gt;
&lt;p&gt;While he roughly follows the timeline of Unix releases, Kernighan takes short detours, including mini-biographies of his colleagues and the influence they had on the design of the system and the ideas embodied in it.
He finishes with the commercialization of Unix, Unix descendants - BSD, Minix, Linux and Plan 9, and with the closure of Bell Labs.&lt;/p&gt;
&lt;p&gt;If you work with Linux, the C language or any Unix tools, you should read this book to understand where these things came from and what formed this environment.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Why do Ops and Sec people wear black</title>
      <link>https://blog.koehntopp.info/2020/08/19/why-do-ops-and-sec-people-wear-black.html</link>
      <pubDate>Wed, 19 Aug 2020 17:05:47 +0000</pubDate><author>kris-blog@koehntopp.de (Kristian Köhntopp)</author>

      <guid>https://blog.koehntopp.info/2020/08/19/why-do-ops-and-sec-people-wear-black.html</guid>
      <description>&lt;p&gt;For &lt;a href=&#34;https://www.imdb.com/title/tt0108756&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;reasons that don&amp;rsquo;t need exploring at this juncture&lt;/a&gt;

 I &lt;a href=&#34;https://twitter.com/isotopp/status/1296073392655933444&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;tweeted&lt;/a&gt;

&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Once upon a time there were shared boxes, on which the local Unix easily had 200-300 users, Junior Developers at a University.&lt;/p&gt;
&lt;p&gt;A /tmp/ls found easily 3-4 people per day that had . (dot) in their path.&lt;/p&gt;
&lt;p&gt;No particular reason. Why?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;and followed up with&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Hope is not a strategy.&lt;/p&gt;
&lt;p&gt;Neither is &lt;code&gt;curl stackoverflow | sudo bash&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;tmpls&#34;&gt;
    &lt;a href=&#34;#tmpls&#34;&gt;
	/tmp/ls
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;I was asked to explain: &amp;ldquo;What is /tmp/ls?&amp;rdquo;.&lt;/p&gt;
&lt;p&gt;/tmp/ls is a shell script installed as executable in /tmp/ls. If you have . (dot, the current directory) early in your path, it shadows the command /bin/ls, which you use to list the current directory.&lt;/p&gt;
&lt;p&gt;So when you &lt;code&gt;cd /tmp&lt;/code&gt; and then &lt;code&gt;ls&lt;/code&gt; you are executing my script instead of the actual &lt;code&gt;/bin/ls&lt;/code&gt; command. You are now inadvertently running my code under your permissions. When I finish my script with &lt;code&gt;exec /bin/ls &amp;quot;$@&amp;quot;&lt;/code&gt; you won&amp;rsquo;t even notice, because it will run the normal &lt;code&gt;/bin/ls&lt;/code&gt; command at the end.&lt;/p&gt;
&lt;p&gt;The mistake is to have any directory in your path that can contain code controlled by another person besides you and root. That is, a world-writeable &lt;code&gt;/usr/local/bin&lt;/code&gt; in - say - an AIX install would amount to the same exposure (A lot of old Unices such as AIX, HP/UX and SGI would ship with world writeable directories of one kind or the other by default).&lt;/p&gt;
&lt;h2 id=&#34;the-777-root-cron&#34;&gt;
    &lt;a href=&#34;#the-777-root-cron&#34;&gt;
	The 777 root cron
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;The same scenario is a script globally installed on all Macs by JAMF, running through cron as root every minute. The same JAMF sets the enclosing directory to 777 (full access for everybody). Due to how permissions work in Unix, this allows anybody to remove, rename or replace the script itself, no matter what the script permissions are.&lt;/p&gt;
&lt;p&gt;It is instant root for anybody who cares: You replace the script with your own content, wait a minute for the cron to hit it, and put the original script back. Or not, depending on how you feel that day.&lt;/p&gt;
&lt;p&gt;The remarkable part of this particular incident is that none of the multitude of endpoint security products also installed by the same JAMF detected or quarantined this script. So much for that.&lt;/p&gt;
&lt;h2 id=&#34;the-world-writeable-fileshare&#34;&gt;
    &lt;a href=&#34;#the-world-writeable-fileshare&#34;&gt;
	The world writeable fileshare
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Other fun things that should not have happened: A university of applied science exported their AIX home directories by NFS, world-writeable, once. That is, for several years, their site was a well known Shell-o-matic.&lt;/p&gt;
&lt;p&gt;Why is this bad?&lt;/p&gt;
&lt;p&gt;Anybody who mounted this on their own machine could create a user account with a matching UID, go into the mounted user home and drop a .rlogin file of appropriate content (The .rlogin reference should tell you how old that is).&lt;/p&gt;
&lt;p&gt;The fun part is that the university in question eventually migrated to Solaris, and that included all the&amp;hellip; interesting configuration.&lt;/p&gt;
&lt;p&gt;Apparently SMB fileshares can serve the same purpose. Also, Windows always has . (dot) in the front of the path, implicitly.&lt;/p&gt;
&lt;h2 id=&#34;external-storage&#34;&gt;
    &lt;a href=&#34;#external-storage&#34;&gt;
	External storage
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;A lot of people have world-readable backup devices such as a 644 /dev/rmt. If the backup tape from last night is left in that drive it does not matter much what the permissions on the original files are.&lt;/p&gt;
&lt;p&gt;You can read the files from backup, and restore them with any permission you like.&lt;/p&gt;
&lt;h2 id=&#34;this-makes-me-sad&#34;&gt;
    &lt;a href=&#34;#this-makes-me-sad&#34;&gt;
	This makes me sad
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;For some reasons each of these things, all of which are from personal experience up to 25 years ago, still happen today.&lt;/p&gt;
&lt;p&gt;That is why ops people wear black. Now you know.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Everything was a file, but we got better</title>
      <link>https://blog.koehntopp.info/2019/11/14/everything-was-a-file-but-we-got-better.html</link>
      <pubDate>Thu, 14 Nov 2019 11:42:07 +0000</pubDate><author>kris-blog@koehntopp.de (Kristian Köhntopp)</author>

      <guid>https://blog.koehntopp.info/2019/11/14/everything-was-a-file-but-we-got-better.html</guid>
      <description>&lt;p&gt;I fell into the Twitters again. &lt;a href=&#34;https://twitter.com/carrickdb/status/1194842452361789441&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;@CarrickDB&lt;/a&gt;

 joked about Unix,
Files and Directories:&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://twitter.com/carrickdb/status/1194842452361789441&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/everything-is-a-file.png&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;

&lt;/a&gt;

&lt;/p&gt;
&lt;p&gt;And that is a case of &amp;ldquo;Haha, only serious&amp;rdquo;. Because directories
used to be files, and that was a bad time. Check out the V7 Unix
&lt;a href=&#34;https://github.com/v7unix/v7unix/blob/master/v7/usr/src/cmd/mkdir.c#L49&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;mkdir&lt;/a&gt;


command. At this point in history we do not have a &lt;code&gt;mkdir(2)&lt;/code&gt;
syscall, yet, so we need to construct the entire directory in
multiple steps.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/v7unix/v7unix/blob/master/v7/usr/src/cmd/mkdir.c#L49&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;mknod(2)&lt;/code&gt; an inode that has the &lt;code&gt;S_IFDIR&lt;/code&gt; flag set&lt;/a&gt;

,
even if that macro does not even exist yet.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/v7unix/v7unix/blob/master/v7/usr/src/cmd/mkdir.c#L57&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;manually link the entry for the current directory &lt;code&gt;.&lt;/code&gt; into that&lt;/a&gt;

&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/v7unix/v7unix/blob/master/v7/usr/src/cmd/mkdir.c#L64&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;manually link the entry for the parent directory &lt;code&gt;..&lt;/code&gt; into that&lt;/a&gt;

&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This fragile and broken: &lt;code&gt;mkdir&lt;/code&gt; could be interrupted while
doing that or another program could try to race &lt;code&gt;mkdir&lt;/code&gt; while it
is doing that. In both cases we get directories that are invalid
and dangerous to traverse, because they break crucial
assumptions users make about directories.&lt;/p&gt;
&lt;p&gt;This is also before &lt;code&gt;readdir(2)&lt;/code&gt; and friends, so programs like
&lt;code&gt;ls&lt;/code&gt; &lt;a href=&#34;https://github.com/v7unix/v7unix/blob/master/v7/usr/src/cmd/ls.c#L304&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;open directories like files&lt;/a&gt;


and then make assumptions about the format of dentries on disk.
Specifically, they assume a 16 bit inode number and then a
filename of 14 characters or less and a directory that is an array
of these entries. Unfortunately, time has not been kind to the
assumption of 65535 files or less per partition, and also we
require filenames that are longer than 14 bytes these days.&lt;/p&gt;
&lt;p&gt;Finally have a look at the hot mess that the
&lt;a href=&#34;https://github.com/v7unix/v7unix/blob/master/v7/usr/src/cmd/rmdir.c#L29&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;rmdir&lt;/a&gt;


command is. What could probably go wrong?&lt;/p&gt;
&lt;p&gt;Well, &lt;a href=&#34;https://twitter.com/opheleon/status/1194941703632932865&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Jan Kraetzschmar&lt;/a&gt;


reminds us that this kind of non-atomic rmdir can also produce
structures in the filesystem that are disconnected from the main
tree starting at &lt;code&gt;/&lt;/code&gt;. In that case you end up with orphaned, unreachable
inodes that still have a non-zero link count. &lt;code&gt;fsck&lt;/code&gt; should be
able to find them and free them, but of course that would be a
disruptive operation. Making &lt;code&gt;mkdir&lt;/code&gt; and &lt;code&gt;rmdir&lt;/code&gt; system call avoids
all of these problems.&lt;/p&gt;
&lt;p&gt;That&amp;rsquo;s why all of this was fixed in 1984 or so, when BSD
FFS came around and we got long filenames, wider inodes,
&lt;code&gt;mkdir&lt;/code&gt;, &lt;code&gt;rmdir&lt;/code&gt; and &lt;code&gt;readdir&lt;/code&gt; as syscalls and many other
improvements.&lt;/p&gt;
&lt;h2 id=&#34;what-if-really-everything-was-a-file&#34;&gt;
    &lt;a href=&#34;#what-if-really-everything-was-a-file&#34;&gt;
	What if really everything was a file?
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Another decade later, around 1995 or so, we got Plan 9, not from
outer space, but from Bell Labs.&lt;/p&gt;
&lt;p&gt;It not only brought us Unicode everywhere, but also an
exploration of &amp;lsquo;What if really everything was a file?&amp;rsquo;,
including other machines on the network and processes on our
machine. From that we get todays
&lt;a href=&#34;https://en.wikipedia.org/wiki/Plan_9_from_Bell_Labs#/proc&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;procfs&lt;/a&gt;


in Linux (and in many other modern Unices).&lt;/p&gt;
&lt;p&gt;Except that you can&amp;rsquo;t &lt;code&gt;rm -rf /proc/1&lt;/code&gt; to shut down the box.&lt;/p&gt;
&lt;h2 id=&#34;things-that-still-are-not-a-file-and-should-be-dead&#34;&gt;
    &lt;a href=&#34;#things-that-still-are-not-a-file-and-should-be-dead&#34;&gt;
	Things that still are not a file, and should be dead
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;I am not going to mention System V IPC here at all. Not shm, not
sem, and not msq. They are abominations that should never have
escaped the lab cages they have been conceived in.&lt;/p&gt;
&lt;p&gt;There is &lt;code&gt;mmap&lt;/code&gt;, and mmap is good. Or can be, as long as you do
not conflate in memory and on disk representations of data, and
understand the value of MVCC. But that is another story and
should be told another day.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Bashismen</title>
      <link>https://blog.koehntopp.info/2019/03/04/bashismen.html</link>
      <pubDate>Mon, 04 Mar 2019 11:36:29 +0000</pubDate><author>kris-blog@koehntopp.de (Kristian Köhntopp)</author>

      <guid>https://blog.koehntopp.info/2019/03/04/bashismen.html</guid>
      <description>&lt;p&gt;I &lt;a href=&#34;https://twitter.com/isotopp/status/1102527703033491456&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;trolled Twitter&lt;/a&gt;

 with some Ha-Ha-Only-Serious.&lt;/p&gt;
&lt;p&gt;Every now and then someone complains on Twitter about the use of Bashisms in Shellscripts or legacy systems that are not completely Linux-compatible.
I usually troll back with the claim that anything that is not Linux is broken, and that anything that is not Bash is broken.&lt;/p&gt;
&lt;p&gt;That is of course a troll, and I am of course at the same time totally serious.&lt;/p&gt;
&lt;p&gt;Yes, MacOS exists and does not have a Linux userland, and that is a problem (just try to use Docker, you get a VM that runs Linux that then starts Containers).
Yes, Debian ships systems with ash, and your Openwrt runs Busybox, and in both cases that is the first thing everybody changes.
At least if they are going to use these systems for real, and for good reasons, too.&lt;/p&gt;
&lt;p&gt;The thing is, time did not stop.
It&amp;rsquo;s 2019, and the by far dominant majority of all systems run Linux, bash and a few other things.
It is perfectly okay to demand that these things are present, because the world has moved on and is way beyond kernel, operating systems and shell questions.
In fact, the need to be able to run Docker images at scale is so huge that even Microsoft implemented a Linux kernel API on their operating system, which underneath is anything but close to what Linux requires.&lt;/p&gt;
&lt;p&gt;The other thing is, of course, if portability matters, you do not run Bash or any other kind of Shell.
Or if security matters.
Or extensibility.
Or anything at all.
Use Python.
Or, PHP or even Perl, if you are like from the last millennium.&lt;/p&gt;
&lt;p&gt;But never write Shell Scripts.
Ever.
Or if you do, do not expect them to run anywhere but on your box.
This in the history of mankind has never worked.&lt;/p&gt;
&lt;p&gt;So, get yourself a real computer.
And use a proper programming language.
Thank you.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>But is it atomic?</title>
      <link>https://blog.koehntopp.info/2018/11/29/but-is-it-atomic.html</link>
      <pubDate>Thu, 29 Nov 2018 15:38:05 +0000</pubDate><author>kris-blog@koehntopp.de (Kristian Köhntopp)</author>

      <guid>https://blog.koehntopp.info/2018/11/29/but-is-it-atomic.html</guid>
      <description>&lt;p&gt;From &lt;a href=&#34;https://pluspora.com/posts/310948&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Pluspora&lt;/a&gt;

&lt;/p&gt;
&lt;h2 id=&#34;but-is-it-atomic&#34;&gt;
    &lt;a href=&#34;#but-is-it-atomic&#34;&gt;
	But is it atomic?
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;So a few days ago, a colleague asked “Why do we love files on disk?” and in the course of that discussion, I made a comment that, among other things, used the assumption that somebody is updating some file on some Linux system atomically. I wrote:&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s assume we are using local files, and we do so in a managed, sane way:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;All these state files are always JSON,&lt;/li&gt;
&lt;li&gt;there is a JSON schema, so
&lt;ul&gt;
&lt;li&gt;it is clear which attributes can be there,&lt;/li&gt;
&lt;li&gt;must be there, and&lt;/li&gt;
&lt;li&gt;what they mean and&lt;/li&gt;
&lt;li&gt;what changes to data mean as well.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Files are updated atomically&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;And immediately the question came up: “I either misunderstand you or I have a gap in the knowledge. When writes to a file became atomic? They are not in general case.”&lt;/p&gt;
&lt;p&gt;Let’s go back in time, it’s &lt;a href=&#34;http://silvertonconsulting.com/gbos2/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Greybeards time&lt;/a&gt;

! We’re going to find out where the things you are working with are actually coming from. With sources and references.&lt;/p&gt;
&lt;h2 id=&#34;the-write2-system-call&#34;&gt;
    &lt;a href=&#34;#the-write2-system-call&#34;&gt;
	The write(2) system call
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;A write(2) system call is atomic. The size or amount of data written does not matter. How come?&lt;/p&gt;
&lt;p&gt;The system call will, before trying to write data to disk, lock the in-memory inode. That is, it will effectively lock the entire file. It then performs the file changes, and only then unlocks. That can take a long, long, long time, depending on the amount of data and the media the file is being stored on.&lt;/p&gt;
&lt;p&gt;It means that on a single physical file in Unix there can be only one write(2) or read(2) system call active at any point in time.&lt;/p&gt;
&lt;p&gt;One exception to this is XFS, but only when a file is opened with O_DIRECT. In this special case, XFS instead locks the byte range in a structure attached to the inode, performs the write and then unlocks. So, in XFS with O_DIRECT, any number of concurrent, non-overlapping write(2) system calls can be active.&lt;/p&gt;
&lt;p&gt;The Posix specification requires that write(2) is atomic, it does not require that only one write per file can happen.&lt;/p&gt;
&lt;h2 id=&#34;that-is-a-horrible-thing&#34;&gt;
    &lt;a href=&#34;#that-is-a-horrible-thing&#34;&gt;
	That is a horrible thing!
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;The locking behavior of write(2) (and read(2)) is a problem for databases that require many concurrent writes to happen.&lt;/p&gt;
&lt;p&gt;Ingres and some other early SQL databases used to solve that problem by avoiding filesystem entirely, they recommended that tablespaces use raw disks. No filesystem, no files, no locks.&lt;/p&gt;
&lt;p&gt;Oracle solved the problem by introducing the concept of tablespaces, which are data storage spaces made up by a fleet of files, e.g. one file for each GB of data storage. Tables are assigned tablespaces, not data files directly. Since there is one write lock per inode, concurrent writes to different files in the same tablespace can happen.&lt;/p&gt;
&lt;p&gt;Only in 1994, when SGI published XFS, the actual problem was tackled by splitting the lock at the kernel level for buffer cache less writes. XFS also contained many other improvements over the 1984 BSD Fast Filing System that made it superior for concurrent I/O, streaming I/O, very large file systems, and many other modern use-cases. BSD FFS was in turn an improvement over 1974’s original Unix Filesystem.&lt;/p&gt;
&lt;p&gt;In Linux terms, the 1974 Unix Filesystem is mirrored by the Minix File system, the 1984 BSD FFS is roughly equivalent to ext2, and XFS was donated and ported to Linux by SGI, bringing that up into the tech level of 1994.&lt;/p&gt;
&lt;p&gt;Sun ZFS and Linux Btrfs are from 2004, and are a complete deviation from earlier Unix ideas. They are a different, much longer writeup, which will actually end with the git and the Blockchain.&lt;/p&gt;
&lt;h2 id=&#34;source-dive-why-are-writes-atomic&#34;&gt;
    &lt;a href=&#34;#source-dive-why-are-writes-atomic&#34;&gt;
	Source Dive: Why are writes atomic?
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;“Posix requiring a file write to be atomic” comes from the behavior of the original Version 7 Unix and later systems. In there, we find the &lt;a href=&#34;https://github.com/dspinellis/unix-history-repo/blob/Research-V7-Snapshot-Development/usr/sys/sys/sys2.c#L20&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;write(2)&lt;/a&gt;

 system call, which just calls the &lt;a href=&#34;https://github.com/dspinellis/unix-history-repo/blob/Research-V7-Snapshot-Development/usr/sys/sys/sys2.c#L30&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;rdwr()&lt;/code&gt;&lt;/a&gt;

 function.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/*
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * write system call 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;write&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nf&#34;&gt;rdwr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;FWRITE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;You are looking very old K&amp;amp;R style C code here, which predates even ANSI-C and function prototypes, by the way.&lt;/p&gt;
&lt;p&gt;So &lt;code&gt;rdwr()&lt;/code&gt; a few lines down the function calls &lt;code&gt;plock()&lt;/code&gt;, for as long as we are not dealing with a device special file (Here is where the Ingres “use raw devices” idea comes into play), then does the I/O and finally calls prele().&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;((&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ip&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i_mode&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;IFCHR&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;IFBLK&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;			&lt;span class=&#34;nf&#34;&gt;plock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ip&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mode&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;FREAD&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;			&lt;span class=&#34;nf&#34;&gt;readi&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ip&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;k&#34;&gt;else&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;			&lt;span class=&#34;nf&#34;&gt;writei&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ip&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;((&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ip&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i_mode&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;IFCHR&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;IFBLK&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;			&lt;span class=&#34;nf&#34;&gt;prele&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ip&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;plock()&lt;/code&gt; is what locks the actual inode and the origin of the observed behavior. It is is a misnomer, it’s not a pipe lock, it’s an inode lock.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/*
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * Lock a pipe.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * If its already locked,
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; * set the WANT bit and sleep.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cm&#34;&gt; */&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nf&#34;&gt;plock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ip&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;register&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;inode&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ip&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;while&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ip&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i_flag&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ILOCK&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;n&#34;&gt;ip&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i_flag&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;|=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;IWANT&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;nf&#34;&gt;sleep&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;((&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;caddr_t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ip&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;PINOD&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;n&#34;&gt;ip&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i_flag&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;|=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ILOCK&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;See the locking loop here: As as we do not have the lock, indicate desire to get the lock, then sleep on a lock release. When we exit the loop (because the inode is unlocked), lock the inode.&lt;/p&gt;
&lt;p&gt;These are simple C Code lines, not special magic macros that translate into special magic TAS machine instructions. That is because the code here is so old that it comes from a world where we have single-die, single-core, single-thread CPUs. If your code is actually running (and this is kernel code!), then you are alone in the entire system. There is nobody else touching these variables as long as you have the CPU.&lt;/p&gt;
&lt;p&gt;Under the lock, &lt;code&gt;rdwr()&lt;/code&gt; above calls &lt;code&gt;writei()&lt;/code&gt;. And &lt;code&gt;writei()&lt;/code&gt; has a do loop which uses variables from the u-Area.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;do&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;n&#34;&gt;bn&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;u_offset&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;BSHIFT&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;n&#34;&gt;on&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;u_offset&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;BMASK&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;min&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;((&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;BSIZE&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;on&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;u_count&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;IFBLK&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;IFMPB&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;			&lt;span class=&#34;n&#34;&gt;bn&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;bmap&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ip&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bn&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;B_WRITE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;			&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;((&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bn&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;				&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;			&lt;span class=&#34;n&#34;&gt;dev&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ip&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i_dev&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;BSIZE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;			&lt;span class=&#34;n&#34;&gt;bp&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;getblk&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;dev&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bn&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;k&#34;&gt;else&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;			&lt;span class=&#34;n&#34;&gt;bp&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;bread&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;dev&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bn&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;nf&#34;&gt;iomove&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bp&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;b_un&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;b_addr&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;on&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;B_WRITE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;u_error&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;			&lt;span class=&#34;nf&#34;&gt;brelse&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;k&#34;&gt;else&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;			&lt;span class=&#34;nf&#34;&gt;bdwrite&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;u_offset&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ip&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i_size&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		   &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;==&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;IFDIR&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;||&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;==&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;IFREG&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;			&lt;span class=&#34;n&#34;&gt;ip&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i_size&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;u_offset&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;n&#34;&gt;ip&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i_flag&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;|=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;IUPD&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ICHG&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;u_error&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;==&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;u_count&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The u-Area of a process at that time was a common data structure that the userland and the kernel used to communicate. Here it is being used to shift syscall parameters into the kernel. The write writes the data at &lt;code&gt;u.u_base&lt;/code&gt; in userland into the current inode, at &lt;code&gt;u.u_offset&lt;/code&gt; bytes in the file. There are &lt;code&gt;u.u_count&lt;/code&gt; many bytes to write.&lt;/p&gt;
&lt;p&gt;We convert the &lt;code&gt;u.u_offset&lt;/code&gt; into a logical block number (the n-th block of a file), and an offset &lt;code&gt;on&lt;/code&gt; within the block. We need to call &lt;code&gt;bmap()&lt;/code&gt;. This function turns an inode number and block number within the file into a physical block number on a device.&lt;/p&gt;
&lt;p&gt;We can then bring the relevant physical block into the buffer cache, using &lt;code&gt;bread()&lt;/code&gt;, and then use &lt;code&gt;iomove()&lt;/code&gt; to modify and dirty the block. As we &lt;code&gt;brelse()&lt;/code&gt; it, it will eventually be written back to disk later.&lt;/p&gt;
&lt;p&gt;There is an optimization here:&lt;/p&gt;
&lt;p&gt;When the write is a full block, we do not read the block from disk. We just allocate a buffer using &lt;code&gt;getblk()&lt;/code&gt;, and fill it. It will overwrite the data on disk completely, there is no old and new data to merge. Disk accesses are slow, in the 1970ies even more so than today, so not reading data that you are going to obliterate completely pays off substantially.&lt;/p&gt;
&lt;p&gt;The loop continues as long as there are no errors and still blocks to write.&lt;/p&gt;
&lt;p&gt;As we return from &lt;code&gt;writei()&lt;/code&gt;, &lt;code&gt;rdrw()&lt;/code&gt; resumes and will eventually &lt;code&gt;prele()&lt;/code&gt; the inode lock.&lt;/p&gt;
&lt;h2 id=&#34;how-old-is-this-stuff&#34;&gt;
    &lt;a href=&#34;#how-old-is-this-stuff&#34;&gt;
	How old is this stuff?
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;This is of course extremely old code, original V7 unix, almost as old as me: git blames places its age at 41 years. I was in the third class of a German basic school when this was written.&lt;/p&gt;
&lt;p&gt;I chose this implementation, because it is very simple, and because it is also what became immortalised in the performance destroying standard which we got to know as Posix File System Semantics.&lt;/p&gt;
&lt;h2 id=&#34;homework&#34;&gt;
    &lt;a href=&#34;#homework&#34;&gt;
	Homework
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;You can have fun to find the matching functionality in a &lt;a href=&#34;https://github.com/torvalds/linux&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;modern Linux kernel&lt;/a&gt;

, threads, multicore, capabilities, namespaces, cgroups and dynamic data structures and all.&lt;/p&gt;
&lt;p&gt;Compare code readability and complexity. Discuss. Is this progress? Why do you think so?&lt;/p&gt;
&lt;p&gt;You can try to get a &lt;a href=&#34;http://160592857366.free.fr/joe/ebooks/ShareData/Design%20of%20the%20Unix%20Operating%20System%20By%20Maurice%20Bach.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;copy&lt;/a&gt;

 of “&lt;a href=&#34;https://www.amazon.de/Design-UNIX-Operating-System-Prentice/dp/0132017997&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;The Design of the Unix Operating System&lt;/a&gt;

” by Maurice J. Bach. It will take you on a guided tour through the origins of our craft and the legacy we build on. The topics discussed in this note can be found on the pages 101ff, “WRITE” and “FILE AND RECORD LOCKING”.&lt;/p&gt;
&lt;p&gt;If you are into operating systems, continue reading after Bach: “&lt;a href=&#34;https://www.amazon.de/Design-Implementation-4-3Bsd-Operating-System/dp/0201061961&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;The Design and Implementation of the 4.3 BSD Operating System&lt;/a&gt;

” builds on Bach’s work and showcases the progress and inventions that Kirk McKusick, Sam Leffler et al made after that.&lt;/p&gt;
&lt;p&gt;If you are into comparative operating system design, read “&lt;a href=&#34;https://www.amazon.com/Inside-Windows-NT-Helen-Custer/dp/155615481X&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Inside Windows NT&lt;/a&gt;

” by Helen Custer after Bach and Leffler/McKusick, and try to understand the different ideas and world view behind that.&lt;/p&gt;
&lt;h2 id=&#34;but-we-dont-use-write2-for-atomic-file-updates&#34;&gt;
    &lt;a href=&#34;#but-we-dont-use-write2-for-atomic-file-updates&#34;&gt;
	But we don’t use write(2) for atomic file updates!
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Well, some of us do, but I agree that it is hard to get right: write(2) and writev(2) are very hard to handle properly in applications, as you need to write everything in a single call.&lt;/p&gt;
&lt;p&gt;Most programs use another atomic operation in Unix, the rename(2) system call. You write file.new at your leisure, printf(), chunked writes() and all. When completed, rename file.new to file. This automatically unlinks the old version of file as well.&lt;/p&gt;
&lt;p&gt;This is also the recommended approach to atomicity, because unlike write(2) it is stable in the face of the dreaded nightmare file system.&lt;/p&gt;
&lt;p&gt;rename(2) was introduced really early in BSD Unix because of specific race problems in the V7 Unix early BSD patched and improved.&lt;/p&gt;
&lt;p&gt;Before BSD, we only had link(2) and unlink(2). You can use a combination of these syscalls to implement a rename-like operation, but you need more than one syscall to do that.&lt;/p&gt;
&lt;p&gt;In Unix, at the end of a syscall, before return to userland, the scheduler runs (Bach, Chapter 8). That is, at the end of each syscall, a process can be forced to yield the CPU. This is the cause for potential race conditions when not having a rename(2) as a single syscall, and that is why BSD came up with a single syscall for renaming files in the first place.&lt;/p&gt;
&lt;p&gt;Renaming files for atomic updates can be taken to an art form: try looking into the Maildir/ implementations as invented by qmail, and implemented in Dovecot and Cyrus&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.qmail.org/man/man5/maildir.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Maildir Man Page&lt;/a&gt;

&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cr.yp.to/proto/maildir.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;On Maildir at DJBs site&lt;/a&gt;

&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://danluu.com/file-consistency/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Dan Luu on File Consistency&lt;/a&gt;

&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;And that concludes this issue of Our Systems Legacy.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Dennis Ritchie (Sep 1941-Okt 2011)</title>
      <link>https://blog.koehntopp.info/2011/10/13/dennis-ritchie-sep-1941-okt-2011.html</link>
      <pubDate>Thu, 13 Oct 2011 03:39:44 +0000</pubDate><author>kris-blog@koehntopp.de (Kristian Köhntopp)</author>

      <guid>https://blog.koehntopp.info/2011/10/13/dennis-ritchie-sep-1941-okt-2011.html</guid>
      <description>&lt;p&gt;Das da ist
&lt;a href=&#34;http://en.wikipedia.org/wiki/Dennis_Ritchie&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Dennis Ritchie&lt;/a&gt;

,
&lt;a href=&#34;http://cm.bell-labs.com/who/dmr/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;dmr&lt;/a&gt;

.&lt;/p&gt;
&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/dennis_ritchie.jpg&#34; alt=&#34;Dennis Ritchie&#34;  /&gt;
&lt;/p&gt;

&lt;/p&gt;
&lt;p&gt;Dennis Ritchie schrieb zusammen mit Ken Thompson und vielen anderen Menschen
in den späten 60er und den 70er Jahren die ersten Versionen des
Unix-Betriebssystems, von dem viele der Systeme, die wir heute einsetzen,
direkt abstammen oder substantiell beeinflußt wurden. Zusammen mit Brian
Kernighan entwarf er die Programmiersprache C. Ritchie schrieb auch die
Dokumentation zu diesen Systemen, und jeder Informatikstudent auf diesem
Planeten hat seine Bücher &amp;lsquo;The C Programming Language&amp;rsquo; und eine Version des
&amp;lsquo;Unix Programmers Manual&amp;rsquo; lesen müssen - sie sind noch heute im Druck.&lt;/p&gt;
&lt;p&gt;1983 bekam Ritchie für seine Arbeiten den
&lt;a href=&#34;http://awards.acm.org/images/awards/140/articles/2898606.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Turing-Award&lt;/a&gt;

,
quasi den Nobelpreis für Informatiker.&lt;/p&gt;
&lt;p&gt;Es ist absolut unmöglich, mit Computern zu arbeiten und mit den Arbeiten und
den Ideen von Dennis Ritchie nicht an jedem einzelnen Tag in direkten
Kontakt zu kommen.&lt;/p&gt;
&lt;p&gt;Dennis Ritchie starb am 12. Oktober 2011. Seine Arbeit ist unsterblich.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Acht Jahre SCO-Prozeß</title>
      <link>https://blog.koehntopp.info/2011/08/31/acht-jahre-sco-proze.html</link>
      <pubDate>Wed, 31 Aug 2011 18:46:23 +0000</pubDate><author>kris-blog@koehntopp.de (Kristian Köhntopp)</author>

      <guid>https://blog.koehntopp.info/2011/08/31/acht-jahre-sco-proze.html</guid>
      <description>&lt;p&gt;Im März 2003 begann die Firma, die mal Caldera hieß und sich in SCO Group
umbenannte, IBM auf eine Fantasiesumme von Schadenersatz zu verklagen, weil
Ex-Caldera sich im Besitz des Unix-Copyrights wähnte und der Auffassung war,
daß IBM im Rahmen seiner Linux-Initiative Ex-Caldera geraubmordkopiert
hätte. Sich mit den Anwälten von IBM anzulegen ist eine unglaublich gute
Idee, die der Idee, einen Feldzug in Rußland im Winter zu führen, in nichts
nachsteht. So bekam Ex-Caldera dann auch bald bescheinigt: Linux enthält
keinen original Unix-Quellcode, SCO-Caldera hatte ihr IP unter der GPL
freigegeben und hat so keinen Grund zu klagen &lt;em&gt;und&lt;/em&gt; das Copyright am
Original-Unix System V liegt übrigens nicht bei Euch, liebes Ex-Caldera,
sondern bei Novell.&lt;/p&gt;
&lt;p&gt;Heute, &lt;a href=&#34;http://www.heise.de/open/meldung/SCO-vs-Linux-Es-ist-vorbei-1333811.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;8 Jahre später&lt;/a&gt;

,
geht die Akte endgültig zu. Endlich ist dieser Zombie tot.&lt;/p&gt;
&lt;p&gt;Bester Seiteneffekt der ganzen Aktion: &lt;a href=&#34;http://groklaw.net/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Groklaw&lt;/a&gt;

 -
Tausende von Geeks lernen (amerikanisches) Recht, und Armeen von verteilten
Beweisfindern dokumentieren diesen Prozeß im Detail, suchen Dokumente in
alten Papierstapeln, und finden Fehler und Schwachstellen in den
Argumentationen von Ex-Caldera. Die Firma muß feststellen, daß IBMs Anwälte,
bei aller Drohkraft, nicht der eigentliche Endgegner sind: Es ist das Netz
selber, die Masse der Geeks, die sich da mobilisiert und gegenhält.&lt;/p&gt;
&lt;p&gt;Nach dem Ende des SCO-Prozesses definiert sich Groklaw mit neuer Belegschaft
um: Themen sind nun Oracle vs. Google, Patenttrolle wie Lodsys und ähnliche
Themen. An Prozessen herrscht ja seit zehn Jahren im IT-Umfeld kein Mangel.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Unix-&#34;Standards&#34;</title>
      <link>https://blog.koehntopp.info/2009/07/26/unix-standards.html</link>
      <pubDate>Sun, 26 Jul 2009 17:14:50 +0000</pubDate><author>kris-blog@koehntopp.de (Kristian Köhntopp)</author>

      <guid>https://blog.koehntopp.info/2009/07/26/unix-standards.html</guid>
      <description>&lt;p&gt;Die Geschichte von Unix ist eine Geschichte der gescheiterten oder unbrauchbaren Standards - ihre Zahl ist Legion.&lt;/p&gt;
&lt;p&gt;Egal in welche Richtung man schaut: Sun zum Beispiel hatte einmal einen auf Postscript basierenden Desktop - &lt;a href=&#34;http://en.wikipedia.org/wiki/NeWS&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;NeWS&lt;/a&gt;

, der in gewissser Weise X11 um Jahrzehnte voraus war, sich aber nie hat durchsetzen können, unter anderem deswegen, weil das Ding von Sun als Waffe gegen andere Unix-Anbieter verwendet worden war und quasi tot-lizensiert wurde, gefolgt von&lt;a href=&#34;http://en.wikipedia.org/wiki/OPEN_LOOK&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Open Look&lt;/a&gt;

 und dann dem Motif-basierenden &lt;a href=&#34;http://en.wikipedia.org/wiki/Common_Desktop_Environment&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CDE&lt;/a&gt;

. Speziell letzteres war endlich ein herstellerübergreifendes Projekt, das von allen kommerziellen Unix-Anbietern unterstützt wurde (siehe auch &lt;a href=&#34;http://en.wikipedia.org/wiki/Solaris_%28operating_system%29#Desktop_environments&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;den Solaris-Artikel&lt;/a&gt;

). Da Motif als Toolkit aber bis zur Obsoleszens keine freie Software war und CDE auch keine nennenswerte Weiterentwicklung erfuhr, wurde es inzwischen großflächig durch KDE oder Gnome ersetzt - beides nativ freie Software.&lt;/p&gt;
&lt;p&gt;Auch auf Ebenen weiter unten war Standardisierung schwierig und ist vielfach gescheitert - so hat &lt;a href=&#34;http://en.wikipedia.org/wiki/POSIX&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;POSIX&lt;/a&gt;

 bis heute keine Norm für Access Control Lists von Dateisystemen und entsprechend ist etwa die Kommandozeilensyntax (und Ausdrucksstärke) von Access Control Lists auf einem Mac, einem Linux und einem Solaris unterschiedlich. Schaut man sich die Datumsangaben in dem verlinkten Wikipedia-Artikel an, kann man erkennen, daß Posix ein klassischer Nachfolgestandard ist - also kein Standard, der irgendetwas definiert oder voran bringt, sondern einer, der nur eine bereits vollzogene Entwicklung dokumentiert und festschreibt. Auch hier sind Herstellerkriege um Definitionsmacht die Ursache dafür.&lt;/p&gt;
&lt;p&gt;Auf der anderen Seite findet man eine Reihe von Innovationen in Unix, die sich universell durchgesetzt haben, aber erst nachdem ein Hersteller sie in klarer Verletzung aller formellen und informellen Standards eingeführt hat. Um bei Sun zu bleiben: Die heutige Architektur von Shared Libraries (.so&amp;rsquo;s) wie wir sie kennen ist einem Alleingang von Sun geschuldet, der so erfolgreich war, daß wir ihn heute in allen Unices finden, die überlebt haben. Genau so ist das heutige Layout von Dateisystemen, also die Einführung von /var, /home, /opt und die Aufgabe der Trennung von / und /usr ein Alleingang von Sun, der so erfolgreich war, daß er über den Umweg von SVR4 in alle nennenswerten modernen Unices Einzug gehalten hat.&lt;/p&gt;
&lt;p&gt;Sun hat das damals machen können, weil sie Workstations in großer Zahl abgesetzen konnten und so die entsprechende Definitionsmacht hatten. Außerdem sind die oben genannten Innovationen Beispiele für Innovationen, die nicht totlizensiert waren und so ohne Risiko experimentell von anderen Herstellern übernommen werden konnten.&lt;/p&gt;
&lt;p&gt;Die Rolle von Sun im heutigen Unix-Markt ist eine viel kleinere - Sun hat nicht nur nach Stückzahlen, sondern vor allen Dingen nach Developer- Mindshare eine sehr viel kleinere Rolle. Sun hat immer noch Ideen, einige von denen sind sogar kopierenswert. In die nach Stückzahlen und vor allen Dingen nach Developer-Mindshare sehr viel größere Linux-Welt werden sie jedoch nicht.&lt;/p&gt;
&lt;p&gt;Die Gründe sind immer noch dieselben wie oben:&lt;/p&gt;
&lt;p&gt;ZFS und Dtrace sind zwei Ideen, die sehr kopierenswert sind, die aber aus der Sicht der Linux-Welt totlizensiert sind. Sie sind totlizensiert in dem Sinne, daß die Lizenz dieser Stücke Software frei im Sinne von DFSG sein mag, aber die Lizenz ist mit der GPL inkompatibel. Das mag Absicht oder ein unglücklicher Zufall sein, Fakt ist, daß diese Ideen so nicht direkt als Code in Linux übernommen werden können. Also entwickeln sich in Linux alternative Projekte und es ist absehbar, daß diese in den nächsten 5 Jahren die entsprechenden Sun-Konzepte verdrängen werden - falls Oracle den Kram (&lt;strong&gt;Update wegen &lt;a href=&#34;http://blog.vodkamelone.de/archives/157-BTRFS-und-die-Lizenz....html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ixs Artikel&lt;/a&gt;

:&lt;/strong&gt; gemeint ist ZFS, das ja nun wie ganz Sun auch Oracle gehört) nicht Linux-kompatibel relizensiert. Letzteres wäre immerhin denkbar, denn die BTRFS-Entwicklung wurde zu einem guten Teil von Oracle finanziert und BTRFS ist das Linux-Gegenstück zu ZFS.&lt;/p&gt;
&lt;p&gt;Ein anderes Beispiel für eine Sun-Idee, die kopierbar wäre, aber nicht kopiert wird, ist SMF - hier ist die Sun-Lösung zu häßlich oder verkopft und es gibt zu viele konkurrierende Ideen, um &lt;a href=&#34;http://en.wikipedia.org/wiki/Init#Other_styles&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;init&lt;/a&gt;

 zu ersetzen. Wahrscheinlicher ist es, daß sich Konzepte wie &lt;a href=&#34;http://en.wikipedia.org/wiki/Upstart&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Upstart&lt;/a&gt;

 auf breiter Front durchsetzen.&lt;/p&gt;
&lt;p&gt;Unter dem Strich bleiben einige Erkenntnisse:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Standards sind öfter als nicht Festschreibungen bereits erfolgter Standardisierungsprozesse. Sie sind meist mehr Dokumentation als Innovation.&lt;/li&gt;
&lt;li&gt;Innovation wird im Unix-Bereich oft als Abweichung von einem vermeintlich oder tatsächlich bestehenden Standard wahrgenommen und daher oft schon aus Prinzip und ungeachtet ihres Nutzens mit Kritik überzogen.&lt;/li&gt;
&lt;li&gt;In 2009 haben die verschiedenen Linux-Distributionen endlich eine solche Marktmacht, daß sie de-facto Standards setzen können, die mit großer Wahrscheinlichkeit bald in Standarddokumenten dokumentiert werden. Die Tatsache, daß Sun
die GNU Tools im Pfad vor den eigenen Tools positioniert ist Testament dieser Entwicklung.&lt;/li&gt;
&lt;li&gt;Die Tatsache, daß es einen Unterschied macht ob man Sun Tools oder GNU Tools vorne im Pfad hat (oder BSD- statt SysV-Tools vorne im Pfad plaziert), ist Dokumentation der Tatsache, daß die existierenden Standardisierungen im Unix-Bereich noch lange nicht weit genug gehen, um eine Plattform zu erzeugen, die für die Anwendungsentwicklung groß genug wäre. Kommandozeilenwerkzeuge sind aber nur ein Aspekt der Sache - das Spiel setzt sich in rpm, deb, pkg und anderen Paketformaten, tar-Versionen, Desktop-Umgebungen und so weiter fort.&lt;/li&gt;
&lt;li&gt;Andererseits dokumentiert der bisherige Erfolg von Linux, daß das gar nicht so schlimm ist - von allen Unix-Versionen außer Linux sind überhaupt nur noch Solaris und AIX übrig geblieben und beide werden immer Linux-ähnlicher. Das ist eine gute Sache, und wenn man das erst einmal akzeptiert hat, kann man sich an den Tisch setzen und konstruktiv dokumentatorische Standards verabschieden.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(geschrieben nach der Lektüre von
&lt;a href=&#34;http://www.c0t0d0s0.org/archives/5785-Thoughts-of-an-admin-starting-to-get-old-....html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Jörgs Rant&lt;/a&gt;

)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Historische Kernelsourcen</title>
      <link>https://blog.koehntopp.info/2008/05/27/historische-kernelsourcen.html</link>
      <pubDate>Tue, 27 May 2008 08:08:46 +0000</pubDate><author>kris-blog@koehntopp.de (Kristian Köhntopp)</author>

      <guid>https://blog.koehntopp.info/2008/05/27/historische-kernelsourcen.html</guid>
      <description>&lt;p&gt;In anderen Artikeln habe ich ja schon an Hand von &lt;a href=&#34;http://lxr.linux.no/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://lxr.linux.no/&lt;/a&gt;

 Strukturen im Linux-Kernel referenziert und in Erklärungen verwendet.&lt;/p&gt;
&lt;p&gt;Auf &lt;a href=&#34;http://www.tamacom.com/tour.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Tamacom&lt;/a&gt;

 gibt es zum Vergleich die Quellen von Linux 2.6, FreeBSD 7, NetBSD 4.x, OpenBSD 4.x, GNU Hurd 0.3 und OpenSolaris zum verlinken. Auch liegen dort ein UNIX V7 Kernel und ein 4.3BSD rum.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://minnie.tuhs.org/UnixTree/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Minnie&lt;/a&gt;

 hat eine schöne Sequenz wirklich alter Unix-Trees, der die Entwicklung der 70er Jahre und einige BSD-Trees miteinander vergleicht. Das älteste nützliche Zeugs von dort ist &lt;a href=&#34;http://minnie.tuhs.org/UnixTree/Nsys/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;von 1973&lt;/a&gt;

.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The nsys files are timestamped August 31, 1973. This is consistent with other known dates. The files use structs, but in December 1972 the C compiler didn&amp;rsquo;t support structs. In September 1973, the C version of the kernel finally supplanted the assembly version, and the kernel here certainly works fine.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Mit anderen Worten, wir schauen hier der gleichzeitigen Entstehung der Sprache C und des Unix-Kernels zu. So kennt der V3 Kernel &lt;a href=&#34;http://minnie.tuhs.org/UnixTree/V3/usr/man/man2/stat.2.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;noch keine GID&lt;/a&gt;

 im stat(2) Systemaufruf, und der Compiler kann noch keine &amp;ldquo;struct&amp;rdquo; - im nsys-Kernel 6 Monate später existieren beide - und andere wichtige Erfindungen werden gemacht.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://minnie.tuhs.org/UnixTree/Nsys/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Goldenes Zitat&lt;/a&gt;

:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The number of UNIX installations is now above 20&amp;hellip;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>fork und exec vs. CreateProcess</title>
      <link>https://blog.koehntopp.info/2007/01/07/fork-und-exec-vs-createprocess.html</link>
      <pubDate>Sun, 07 Jan 2007 09:06:13 +0000</pubDate><author>kris-blog@koehntopp.de (Kristian Köhntopp)</author>

      <guid>https://blog.koehntopp.info/2007/01/07/fork-und-exec-vs-createprocess.html</guid>
      <description>&lt;p&gt;&lt;strong&gt;Disclaimer:&lt;/strong&gt; Meine Windows-Kenntnisse sind beschränkt, veraltet und ausschließlich theoretischer Natur. Im Zweifel erzählt dieser Artikel Unsinn nach Hörensagen.&lt;/p&gt;
&lt;p&gt;Nach dem Artikel &lt;a href=&#34;https://blog.koehntopp.info/2007/01/07/fork-exec-wait-und-exit.html&#34;&gt;form, exec, wait und exit&lt;/a&gt;

 habe ich mir aber einmal meine Kopie von Jeffrey Richters &lt;a href=&#34;http://www.amazon.de/Microsoft-Windows-Programmierung-fuer-Experten/dp/3860633899/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Windows - Programmierung für Experten (Advanced Windows)&lt;/a&gt;

 (1997) gegriffen und dort nachgeschlagen, wie man sich das mit den Prozessen und Programmen unter Windows vorstellt (oder jedenfalls vor 10 Jahren vorgestellt hat).&lt;/p&gt;
&lt;p&gt;Windows hat zu diesem Zweck die Systemfunktion &lt;a href=&#34;http://msdn.microsoft.com/library/default.asp?url=https://blog.koehntopp.info/library/en-us/dllproc/base/createprocess.asp&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CreateProcess&lt;/a&gt;

(10 Parameters). Die liest sich so:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;BOOL WINAPI CreateProcess(  LPCTSTR lpApplicationName,  LPTSTR lpCommandLine,  LPSECURITY_ATTRIBUTES lpProcessAttributes,  LPSECURITY_ATTRIBUTES lpThreadAttributes,  BOOL bInheritHandles,  DWORD dwCreationFlags,  LPVOID lpEnvironment,  LPCTSTR lpCurrentDirectory,  LPSTARTUPINFO lpStartupInfo,  LPPROCESS_INFORMATION lpProcessInformation);&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Die Funktion erzeugt einen neuen Prozeß und lädt in diesen ein neues Programm. Dieses wird dann gestartet. lpApplicationName ist der Pfadname des auszuführenden Programmes.&lt;/p&gt;
&lt;p&gt;lpCommandLine ist die Kommandozeile (der argv) des neuen Programmes. Sie wird als String und nicht als Vektor von Strings übergeben. Das Parsen der Kommandozeile in Wort wird also durch das Betriebssystem übernommen und kann nicht durch den Aufrufer kontrolliert werden. In Unix muß man bei execve() einen Vektor von Strings übergeben, das Zerlegen der Kommandozeile in Worte muß also durch den Aufrufer, z.B. die Shell übernommen werden. Die anderen Funktionen der exec-Familie sind Bibliotheksfunktionen, die einem hier einen Teil der Arbeit abnehmen.&lt;/p&gt;
&lt;p&gt;lpApplicationName und lpCommandLine interagieren: lpApplicationName darf NULL sein, dann wird das erste Wort von lpCommandLine nach der Zerlegung in Worte als lpApplicationName interpretiert. lpApplicationName darf ohne Endung angegeben werden, dann rät Windows die Extension bzw. probiert eine Liste von ausführbaren System-Extensions aus.&lt;/p&gt;
&lt;p&gt;lpApplicationName darf auch ein unqualifizierter Pfadname sein. In diesem Fall wird das Absuchen eines System-Suchpfades wird durch diese Funktion von Windows übernommen. In Unix führt execve() genau das Binary aus, dessen Pfadnamen man angegeben hat. Will man einen Suchpfad absuchen, muß man execve() in einer Schleife so lange ausführen, bis es nicht mehr zurück kommt.&lt;/p&gt;
&lt;p&gt;lpProcessAttributes ist kein einzelner Parameter, sondern ein Zeiger auf eine &lt;a href=&#34;http://msdn2.microsoft.com/en-us/library/aa379560.aspx&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SECURITY_ATTRIBUTES&lt;/a&gt;

-Struktur, die man ausfüllen kann und die viele Parameter enthalten kann. Die Struktur enthält eine ACL für die Discretionary Access Control, bestimmt also im wesentlichen, wer diesen Prozeß anfassen und was mit ihm machen darf. In Unix gibt es kein vergleichbares Konzept für Prozesse: Ein Prozeß hat entweder die entsprechende Capability (etwa CAP_KILL oder CAP_SYS_PTRACE) oder nicht.&lt;/p&gt;
&lt;p&gt;lpThreadAttributes erzeugt ist der passende Parameter für den in dem Prozeß zwingend enthaltenen Thread. bInheritHandles definiert, ob vererbbare Handles auf Objekte von dem neu erzeugten Prozeß geerbt werden.&lt;/p&gt;
&lt;p&gt;dwCreationFlags legt die Priorität des Prozesses und &lt;a href=&#34;http://msdn2.microsoft.com/en-us/library/ms684863.aspx&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;weitere Flags&lt;/a&gt;

 für den neuen Prozeß fest. In Unix würde man all dies zwischen dem fork() und dem exec() mit einzelnen Calls machen, etwa mit Calls aus der setpriority()-Familie oder mit Aufrufen nach setpgrp().&lt;/p&gt;
&lt;p&gt;lpEnvironment entspricht konzeptuell, aber nicht im Format dem envp von execve.&lt;/p&gt;
&lt;p&gt;lpCurrentDirectory ist das aktuelle Verzeichnis des neuen Prozesses. In Unix würde man den identischen Effekt erreichen, indem man zwischen dem fork() und dem exec()-Systemaufruf ein chdir() (oder chroot()) aufruft.&lt;/p&gt;
&lt;p&gt;lpStartupInfo ist ein Zeiger auf eine eine Struktur &lt;a href=&#34;http://msdn2.microsoft.com/en-us/library/ms686331.aspx&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;STARTUPINFO&lt;/a&gt;

, die keine Entsprechung in Unix hat, weil hier Dinge angegeben werden, die mit den Fenstern einer Anwendung zu tun haben. Unix handhabt diese Dinge komplett vom Betriebssystemkern getrennt und daher finden wir in den Betriebssystem-Primitiven zu Prozessen keine Fensterinformationen. Genaugenommen ist lpStartupInfo entweder ein Zeiger auf eine STARTUPINFO oder STARTUPINFOEX-Struktur. Was es genau ist wird mit einem Flag in dwCreationFlags angegeben. Das ist nicht typsicher, und das ist bemerkenswert, weil Windows an anderer Stelle sehr viel Wert auf solche Dinge legt.&lt;/p&gt;
&lt;p&gt;Der letzte Parameter von CreateProcess, lpProcessInformation, ist ein Referenzparameter auf eine &lt;a href=&#34;http://msdn2.microsoft.com/en-us/library/ms684873.aspx&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;PROCESS_INFORMATION&lt;/a&gt;

-Struktur, die von Windows überschrieben und ausgefüllt wird. Wir finden dort die Handles zu unserem Prozeß und dem darin enthaltenen Thread sowie eine ProcessId und eine ThreadId.&lt;/p&gt;
&lt;p&gt;Will man das Äquivalent zu einem setuid()-Eignerwechsel in Unix in Windows durchführen, kommt dieses Konzept an seine Grenzen - so etwas ist trotz der Vielzahl der Parameter von CreateProcess() in Windows nicht vorgesehen. Man braucht eine neue Funktion, &lt;a href=&#34;http://msdn2.microsoft.com/en-us/library/ms682429.aspx&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CreateProcessAsUser&lt;/a&gt;

(11 Parameter).&lt;/p&gt;
&lt;h2 id=&#34;analyse&#34;&gt;
    &lt;a href=&#34;#analyse&#34;&gt;
	Analyse
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Hier wird der grundlegende Unterschied zwischen den Konzepten von Windows und Unix deutlich: Die Unix-API stammt von Mitte der 70er Jahre und hat sich in den vergangenen mehr als 30 Jahren nicht wesentlich verändert.&lt;/p&gt;
&lt;p&gt;Sie genügt heutigen Ansprüchen, weil sie alle Ansprüche nicht erfüllt - sie liefert stattdessen relativ atomare primitive Funktionen und trennt sogar auf den ersten, flüchtigen Blick zusammengehörende Dinge wie Erzeugen von Prozessen und Laden von Programmen. Dadurch muß ein Programmierer einer Anwendung entweder eine Bibliotheksfunktion verwenden, die fork() und exec() in etwas bequemeres einpackt (etwa system() oder popen()) oder all die Dinge selber machen, die Windows im Kernel für den Programmierer erledigt. fork() hat keine Parameter und execve() hat deren drei.&lt;/p&gt;
&lt;p&gt;Will man mehr, hat man die Gelegenheit, das Environment des neuen Prozesses nach dem fork() vor dem Start des neuen Programmes mit execve() von innen zu verändern.&lt;/p&gt;
&lt;p&gt;Windows dagegen erzeugt eine alles-in-einem Funktion, die für den häufigen Anwendungsfall und alle denkbaren Varianten Extraparameter hat. Windows hat dabei die Sicht von außen auf den Kindprozeß. Dies führt zu nützlichen Dingen wie einer Thread- und Prozeß DACL, ist aber konzeptuell nicht gut erweiterbar. Dinge wie ein setuid()-Aufruf zwischen fork() und exec() sind mit CreateProcess() nicht abbildbar und machen weitere Funktionen erforderlich, die noch mehr Parameter haben.&lt;/p&gt;
&lt;p&gt;Das Konzept von Unix ist auf den ersten Blick umständlich und wenig intuitiv. Es genügt von der Aufteilung her jedoch den Ansprüchen, die man als Datenbanker an eine Normalform hätte und ist daher flexibel und ohne Änderungen am Kern erweiterbar - unabhängige Konzepte sind als unabhängige Funktionen implementiert und Erweiterung erfolgt durch Einschieben weiterer Aufrufe zwischen fork() und exec(). Neben dem Vorteil der Erweiterbarkeit hat dies den Nachteil, daß mehr Systemaufrufe notwendig sind als bei Windows (Unix-Systemaufrufe müssen schnell sein, damit dieses Konzept aufgeht) und daß man unter Umständen ein Problem mit der Atomizität bekommen kann.&lt;/p&gt;
&lt;p&gt;Beispiel ist hier die Aufgabe: &amp;ldquo;Starte aus einem Debugger einen Programm in einem Kindprozeß und zwar so, daß der Kindprozeß ohne Racecondition auf der ersten Anweisung des Kindes stoppt und debugbar ist.&amp;rdquo;. Das Problem war lange Zeit nicht lösbar, und wurde von Linux durch das PTRACE_TRACEME-Flag zu ptrace() gelöst, das neben einigen anderen Dingen bewirkt, daß ein Kindprozeß nach einem execve() erst mal mit einem SIGTRAP stehen, bleibt bevor er irgendwas selber macht. Bemerkenswert ist, daß die Erweiterung möglich war, ohne das bestehende 30 Jahre alte Konzept von fork, exec und wait verändern zu müssen.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Filesysteme für theclaw (30 Jahre Unix Source)</title>
      <link>https://blog.koehntopp.info/2006/12/26/filesysteme-fuer-theclaw-30-jahre-unix-source.html</link>
      <pubDate>Tue, 26 Dec 2006 19:09:59 +0000</pubDate><author>kris-blog@koehntopp.de (Kristian Köhntopp)</author>

      <guid>https://blog.koehntopp.info/2006/12/26/filesysteme-fuer-theclaw-30-jahre-unix-source.html</guid>
      <description>&lt;p&gt;&amp;mdash; Log opened Di Dez 26 15:52:09 2006&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Hey :] &lt;a href=&#34;https://blog.koehntopp.info/2006/05/08/fragmentierung-fuer-jannik.html&#34;&gt;Spitze erklaerung zu ext2.&lt;/a&gt;

&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Danke&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Bist du Kerneldeveloper?&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Nein. Mysql Consultant.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Hmm. Hab da was nicht verstanden bei der Erklärung. Und zwar: Was sind Datenblockzeiger?&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Die Blockadressen von Datenblöcken einer Datei.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Ich paste mal was&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;(0-11):9711-9722, (IND):9723, (12-267):9724-9979, (DIND):9980, (IND):9981, (268-523):9982-10237, (IND):10238, (524-779):10239-10494, (IND):10495, (780-1035):10496-10751, (IND):10752, (1036-1291):10753-11008, (IND):11009, (1292-1547):11010-11265, (IND):11266, (1548-1795):11267-11514
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Isotopp&amp;gt; Habs im
&lt;a href=&#34;%28/2006/05/08/fragmentierung-fuer-jannik.html%29&#34;&gt;Originalartikel&lt;/a&gt;

.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; &lt;code&gt;__le32 i_block[EXT2_N_BLOCKS];&lt;/code&gt; Das ist das, was unter BLOCKS bei debugfs steht?&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt;
&lt;a href=&#34;http://lxr.linux.no/source/include/linux/ext2_fs.h#L211&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://lxr.linux.no/source/include/linux/ext2_fs.h#L211&lt;/a&gt;

: Das ist was auf der Platte steht.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Okay mal durchdenken.&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Die Definition steht in
&lt;a href=&#34;http://lxr.linux.no/source/include/linux/ext2_fs.h#L165&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://lxr.linux.no/source/include/linux/ext2_fs.h#L165&lt;/a&gt;

. Es kommen also &lt;code&gt;EXT2_NDIR_BLOCKS&lt;/code&gt; direkt, also in der Inode selbst. Das sind (0-11):9711-9722.&lt;/p&gt;
&lt;p&gt;Dann kommt ein &lt;code&gt;EXT2_IND_BLOCK&lt;/code&gt;, (IND):9723. Der steht auch in der Inode, aber der zeigt nicht auf Daten, sondern auf einen Indirect Block. Der enthält die Blocknummern der Datenblöcke, (12-267):9724-9979.&lt;/p&gt;
&lt;p&gt;Dann kommt &lt;code&gt;EXT2_DIND_BLOCK&lt;/code&gt;. Der wiederum enthält keine Blocknummern von Datenblöcken, sondern die Blocknummern von Indirect Blocks, die wiederum Blocknummern von Datenblöcken enthalten. Daher
&lt;a href=&#34;http://kris.koehntopp.de/artikel/dateisysteme/filestructure.gif&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://kris.koehntopp.de/artikel/dateisysteme/filestructure.gif&lt;/a&gt;

.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; &lt;em&gt;anseh&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; In der inode steht nur (DIND):9980. In DIND steht dann (IND):9981 und (IND):10238 und so weiter. Und in (IND):9981 stehen dann 9982-10237, in (IND):10238 dann 10239-10494.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; DIR steht für &amp;ldquo;direct&amp;rdquo;?&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; ja&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Muss das jetzt mal kurz mit debugfs ausprobieren.&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Sieh mal
&lt;a href=&#34;http://lxr.linux.no/source/fs/ext2/inode.c#L665&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://lxr.linux.no/source/fs/ext2/inode.c#L665&lt;/a&gt;

. Das &lt;code&gt;ext2_bmap&lt;/code&gt; geht über &lt;code&gt;generic_block_bmap&lt;/code&gt; nach
&lt;a href=&#34;http://lxr.linux.no/source/fs/ext2/inode.c#L547&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://lxr.linux.no/source/fs/ext2/inode.c#L547&lt;/a&gt;

. Und das wiederum benutzt
&lt;a href=&#34;http://lxr.linux.no/source/fs/ext2/inode.c#L196&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://lxr.linux.no/source/fs/ext2/inode.c#L196&lt;/a&gt;

. Und da siehst du den lookup.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; okay langsam kommts&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Wenn &lt;code&gt;i_block&lt;/code&gt;&amp;lt;0 -&amp;gt; error. Wenn &lt;code&gt;i_block&lt;/code&gt;&amp;lt;&lt;code&gt;direct_blocks&lt;/code&gt;, dann direkt. Sonst IND, sonst DIND, sonst TIND. Sonst bumm.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Wart mal, nicht so schnell. Ich kann das nicht alles gleichzeitig aufnehmen. Also, die ersten zwölf Blöcke sind -direkt- in der Inode?&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Ja. Blocknummern. Nicht Blöcke.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; &lt;code&gt;i_block&lt;/code&gt; ist schon ein element aus &lt;code&gt;i_block[]&lt;/code&gt; oder? ;)&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Wo bist du gerade? Also in welcher zeile?&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; &lt;code&gt;static int ext2_block_to_path&lt;/code&gt;. Bei der Definition da.&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Kannst du eine lxr url geben bitte? Sonst wird das schwer hier. Ah, hier:
&lt;a href=&#34;http://lxr.linux.no/source/fs/ext2/inode.c#L196&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://lxr.linux.no/source/fs/ext2/inode.c#L196&lt;/a&gt;

.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; ja&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; &lt;code&gt;i_block&lt;/code&gt; ist der 2. Parameter der Funktion, der Aufruf steht in
&lt;a href=&#34;http://lxr.linux.no/source/fs/ext2/inode.c#L547&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://lxr.linux.no/source/fs/ext2/inode.c#L547&lt;/a&gt;

. Da ist es &lt;code&gt;iblock&lt;/code&gt;,
das wird durchgereicht vom 2. Parameter von &lt;code&gt;ext2_get_block&lt;/code&gt; &lt;code&gt;iblock&lt;/code&gt;. Das wiederum ist
&lt;a href=&#34;http://lxr.linux.no/source/fs/ext2/inode.c#L665&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://lxr.linux.no/source/fs/ext2/inode.c#L665&lt;/a&gt;

, der das über den Umweg von
&lt;a href=&#34;http://lxr.linux.no/source/fs/buffer.c#L2759&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://lxr.linux.no/source/fs/buffer.c#L2759&lt;/a&gt;

 aufruft.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Nicht gerade trivial.&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Für den Kernel schon. Das geht da überall so, inzwischen. Man gewöhnt sich dran, das Lesen zu können. Die
Alternative ist Code Duplication, und das nervt noch mehr. Anyway, &lt;code&gt;sector_t&lt;/code&gt; ist ein unsigned 64 bit
(long long, 8 byte) in i386. Eine Blocknummer.&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; In
&lt;a href=&#34;http://lxr.linux.no/source/fs/ext2/inode.c#L556&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://lxr.linux.no/source/fs/ext2/inode.c#L556&lt;/a&gt;

, das ist die wichtige Stelle, hast du die &lt;code&gt;inode&lt;/code&gt; und den &lt;code&gt;iblock&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Die &lt;code&gt;inode&lt;/code&gt; hat das 12-Elemente direct block array usw im Speicher und &lt;code&gt;iblock&lt;/code&gt; ist der Offset. Die Frage,
die in
&lt;a href=&#34;http://lxr.linux.no/source/fs/ext2/inode.c#L556&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://lxr.linux.no/source/fs/ext2/inode.c#L556&lt;/a&gt;

 geklärt werden muss
ist: wie tief müssen wir runter steigen - für die Blöcke 0-11 gar nicht, für die Blöcke 12- einen Level und so weiter.
Das klärt &lt;code&gt;ext2_block_to_path&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Den Abstieg sehen wir dann in
&lt;a href=&#34;http://lxr.linux.no/source/fs/ext2/inode.c#L562&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://lxr.linux.no/source/fs/ext2/inode.c#L562&lt;/a&gt;

.
Und der Abstieg klappt entweder, weil das File schon einen Block hat an der Stelle &lt;code&gt;iblock&lt;/code&gt;
(&lt;a href=&#34;http://lxr.linux.no/source/fs/ext2/inode.c#L564&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://lxr.linux.no/source/fs/ext2/inode.c#L564&lt;/a&gt;

),
oder es klappt nicht und wir müssen Blöcke beschaffen
(nach &lt;a href=&#34;http://lxr.linux.no/source/fs/ext2/inode.c#L575&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://lxr.linux.no/source/fs/ext2/inode.c#L575&lt;/a&gt;

).&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Sekunde. Bin kein Kernelmensch ;)&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Aber das ist doch nur gewöhnliches C.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Na ja, trotzdem komplex (für mich). Erstmal eine Frage. Man hat ein FS, und will die Inode nummer 23, wie wird die gefunden?&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Über die Verzeichnisse. Wir wissen, / hat die inode 2. Das ist definiert in
&lt;a href=&#34;http://lxr.linux.no/source/include/linux/ext2_fs.h#L60&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://lxr.linux.no/source/include/linux/ext2_fs.h#L60&lt;/a&gt;

,
also lesen wir das File mit der inode 2 durch, und parsen es als
&lt;a href=&#34;http://lxr.linux.no/source/include/linux/ext2_fs.h#L510&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://lxr.linux.no/source/include/linux/ext2_fs.h#L510&lt;/a&gt;

 Strukturen.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Sind die indodes nicht nacheinander abgepeichert in den BGs?
Also die erste BG enthält die ersten X Inodes, die zweite BG die zweiten X usw&amp;hellip;&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Aeh, ah. Ich verstehe. Userland kann nichts mit Inodes machen, nur mit Filenamen. Es gibt kein &lt;code&gt;openi()&lt;/code&gt;.
Also müssen alle Funktionen im Userland immer Namen angeben, und du kommst dann vom Namen zur Inode über das kernel-interne &lt;code&gt;namei()&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Ja, klar. Aber der Kernel will ja Inode X irgendwie kriegen können.&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Ja, intern. Das weiß er, weil im Superblock ja steht, wie viele Inodes pro bg vorhanden sind, und er dann aus
der Inodenummer / inodes_per_bg sofort die bg nummer ausrechnen kann, und dann sofort weiß, wo die inode
stehen muss auf der Platte. Eine Inodenummer ist also implizit auch die Blockadresse der Inode auf der Platte.&lt;/p&gt;
&lt;p&gt;Hier ist der Superblock:
&lt;a href=&#34;http://lxr.linux.no/source/include/linux/ext2_fs.h#L341&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://lxr.linux.no/source/include/linux/ext2_fs.h#L341&lt;/a&gt;

,
und &lt;a href=&#34;http://lxr.linux.no/source/include/linux/ext2_fs.h#L352&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://lxr.linux.no/source/include/linux/ext2_fs.h#L352&lt;/a&gt;

 ist
die &lt;code&gt;s_inodes_per_group&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Und die Inode wird dann in
&lt;a href=&#34;http://lxr.linux.no/source/fs/ext2/inode.c#L998&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://lxr.linux.no/source/fs/ext2/inode.c#L998&lt;/a&gt;

 gelesen.&lt;/p&gt;
&lt;p&gt;Meine Rechnung von eben ist hier
&lt;a href=&#34;http://lxr.linux.no/source/fs/ext2/inode.c#L1012&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://lxr.linux.no/source/fs/ext2/inode.c#L1012&lt;/a&gt;

.  &lt;code&gt;(ino - 1) / EXT2_INODES_PER_GROUP(sb);&lt;/code&gt;
und &lt;code&gt;((ino - 1) % EXT2_INODES_PER_GROUP(sb)) * EXT2_INODE_SIZE(sb);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Nix für ungut aber für mich ist der Code grad ned so hilfreich.&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Was ist das Problem?&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Bin grad bisschen überfordert.&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Du hast eine Inode Nr 23. Du weisst, pro bg hast Du sagen wir 8192 Inodes. Und (23-1) / ext2_indes_per_group(sb) = 0.
Also ist inode 23 in bg 0.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; &lt;em&gt;wartmal&lt;/em&gt; 8192?!&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; 8192 bei 1 kb blockgroesse, 32768 bei 4kb&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Wie gross ist eine Inode nochmal?&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; 128 bytes.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;linux/ext2_fs.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ext2_inode&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nf&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;%d&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;sizeof&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;und&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;kris@linux:~&amp;gt; make probe
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;make: &amp;#34;probe&amp;#34; ist bereits aktualisiert.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;kris@linux:~&amp;gt; ./probe
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;128
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;theclaw&amp;gt; Also pro BG ist allein 1 MB bzw 4 MB an Inodes reserviert?&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Ja. Eine bg ist 8 MB oder 128 MB gross. Schau, hast du ein ext2 da?&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; ja&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Dann mach mal ein &lt;code&gt;debugfs /dev/...&lt;/code&gt; da drauf. Ist read only, macht also nix kaputt. Dann mach mal &lt;code&gt;show_super_stats&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;Inodes per group:         2008
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;Inode count:              26104
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;für ein &lt;code&gt;/dev/sda5     ext2     99M  6.7M   87M   8% /boot&lt;/code&gt;
und &lt;code&gt;26104*128/1024 = 3263&lt;/code&gt;, also 3263 KB oder 3.2M für alle Inodes.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Aber meine Frage ist eine Andere.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; 21:40 Isotopp&amp;gt; und das wichtigste in &lt;code&gt;struct: __le32 i_block[EXT2_N_BLOCKS];&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; &lt;code&gt;i_block[12]&lt;/code&gt; ist ein indirekter Block? &lt;em&gt;aaargh&lt;/em&gt; Die Adresse eines indirekten Blockes?&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Ja.
&lt;a href=&#34;http://lxr.linux.no/source/include/linux/ext2_fs.h#L165&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://lxr.linux.no/source/include/linux/ext2_fs.h#L165&lt;/a&gt;

. Dort ist
&lt;code&gt;#define EXT2_IND_BLOCK EXT2_NDIR_BLOCKS&lt;/code&gt; und weiter ist
&lt;code&gt;#define EXT2_NDIR_BLOCKS 12&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Also 15 &lt;code&gt;EXT2_N_BLOCKS&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Also ist &lt;code&gt;i_block[0]&lt;/code&gt; bis &lt;code&gt;i_block[11]&lt;/code&gt; direct, &lt;code&gt;i_block[12]&lt;/code&gt; indirect, und &lt;code&gt;i_block[13]&lt;/code&gt; DIND und &lt;code&gt;i_block[14]&lt;/code&gt; TIND. Alles in allem also 15.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Sind das die Faktoren die die max. Dateigröße in ext2 bestimmen?&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Das sind die Faktoren, die die maximale Blocknummer bestimmen. Dateigröße ist Blockgröße mal maximale Blocknummer.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Also ja ;) Indirekt halt.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; 9711-9722: Sind das die &amp;ldquo;Adressen&amp;rdquo;?&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Blocknummern, ja, Adressen auf der Platte. In
&lt;a href=&#34;http://lxr.linux.no/source/include/linux/ext2_fs.h#L234&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://lxr.linux.no/source/include/linux/ext2_fs.h#L234&lt;/a&gt;

 siehst du als Typ uebrigens &lt;code&gt;__le32&lt;/code&gt;. Das ist definiert in
&lt;a href=&#34;http://lxr.linux.no/source/include/linux/types.h#L172&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://lxr.linux.no/source/include/linux/types.h#L172&lt;/a&gt;

 und endet als &lt;code&gt;__u32&lt;/code&gt;, also unsigned 32 bit. Also 2^32 Blöcke. Bei 4 KB Blöcken sind das 17592186044416 Bytes, oder 16 TB, bei 1 KB Blöcken nur 4 TB.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Diese Blöcke haben aber nix mit den Blöcken bei ext2 zu tun? Oder doch?&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; &lt;code&gt;show_super_stats&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; &lt;code&gt;Block size:               1024&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; In meinem Fall also auch maximale Dateigröße 4 TB. 4 Gigablocks.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Okay, dann noch eine Frage:&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; TOTAL: 1804 und Blockcount: 3608, huh? Warum *2?&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Hmm, da rechnet jemand mit 512 Byte Hardwaresektoren, warum auch immer.&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;linux:~ # ls -lsi /boot/vmlinuz-2.6.13-15-default
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt; 28 1513 -rw-r--r--  1 root root 1541719 Sep 13  2005 /boot/vmlinuz-2.6.13-15-default
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Isotopp&amp;gt; Inode 28, 1513 Blöcke auf der Platte, Dateilaenge 15411719 Bytes. Rechnerisch ist  &lt;code&gt;1541719/1024 = 1505.5849&lt;/code&gt;. 7 Blöcke Verwaltungsoverhead. Und zwar&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;(0-11):11515-11526, 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;(IND):11527, (12-267):11528-11783, 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;(DIND):11784, (IND):11785, (268-523):11786-12041, 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;              (IND):12042, (524-779):12043-12298, 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;              (IND):12299, (780-1035):12300-12555, 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;              (IND):12556, (1036-1291):12557-12812, 
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;              (IND):12813, (1292-1505):12814-13027
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;TOTAL: 1513
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Isotopp&amp;gt; (IND):11527, (DIND):11784, (IND):11785, (IND):12299, (IND):12556, (IND):12813 &amp;lt;- das sind 6.&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; 1541719/1024 = 1505.5849 sind 1506. Plus 6 sind 1512.&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Er meint total sei 1513. Wieso?&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Ich versteh das sowieso nicht, warum da 1513 angezeigt wird. 1292-1505 ist das letzte und dann total 1513. Evtl noch die Metainfos dazu?&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Nein, aber die DIND und IND Blocks. Für die Blöcke 12-267 wird ja ein IND gebraucht, für die Blöcke 268-1505 wird ein DIND und vier IND gebraucht. 6 blocks Extra. Siehe noch einmal
&lt;a href=&#34;http://kris.koehntopp.de/artikel/dateisysteme/filestructure.gif&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://kris.koehntopp.de/artikel/dateisysteme/filestructure.gif&lt;/a&gt;

. Das rechts sind die Daten. In der Inode stehen die ersten paar Datenblocknummern direkt, in der zeichnung 10, in ext2 sind es 12. Dann steht in der Inode die Nummer vom IND, und im IND die Blocknummern der Datenblöcke, hier 12-267. Das ist also 1 block overhead, wenn das file mehr als 12 blocks lang wird. Dann ein DIND, wenn der 268&amp;rsquo;te block gebraucht wird und für jeweils 256 Blocks ein IND dazu.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Du erklaerst so schnell.&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;linux:/boot # dd if=/dev/zero of=kris bs=1k count=12
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;linux:/boot # ls -ls kris
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;12 -rw-r--r--  1 root root 12288 Dec 26 16:58 kris
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;12 Blöcke, 12288 Bytes Länge. Und nun:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;linux:/boot # dd if=/dev/zero of=kris bs=1k count=13
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;linux:/boot # ls -ls kris
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;14 -rw-r--r--  1 root root 13312 Dec 26 16:58 kris
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Ein 1k länger, 14 Blocks statt 12.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Wie findet man die Größen der BGs eines dateisystems heraus?&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Lies &lt;code&gt;show_super_stats&lt;/code&gt; von &lt;code&gt;debugfs&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;linux:/boot # export DEBUGFS_PAGER=cat
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;linux:/boot # debugfs /dev/sda5
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;debugfs 1.38 (30-Jun-2005)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;debugfs:  show_super_stats
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;Inode count:              26104
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;Block count:              104388
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;Block size:               1024
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;Blocks per group:         8192
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;Inodes per group:         2008
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;Inode blocks per group:   251
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Isotopp&amp;gt; Wird einiges klarer?&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Ein bisschen. Also wenn ich z.B. block nummer X habe, dann ist (nummer X)/(blocks per group) die BG nummer gell?&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Ja, aber das interessiert nicht. Du redest ja von Blöcken.&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Der n-te Block der Datei x kann irgendwo liegen. Wo, das sagt dir die Inode.  Normal hast du ja ein File, und eine Position in einem File.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Ich kann doch einfach von der Adresse auf der Platte X * bytes_per_block lesen?&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Na ja, als root schon. Sonst nicht. debugfs macht das ja, die Disk als raw device auf und dann direkt auf die Blöcke klettern. Niemand sonst tut so etwas ausser debugfs und fsck. Alle anderen machen FILES auf und lesen dann am OFFSET in dem File. Punkt ist, dass du normal mit Files arbeitest und nicht mit Blöcken. Der Kernel arbeitet mit Blöcken. Und er muss irgendwie vom File + Offset auf den Block kommen.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Ja Klar&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Unser ext2 hier hat 1 KB Blocksize. Wir lesen das File &lt;code&gt;/boot/vmlinuz-2.6.13-15-default&lt;/code&gt; (inode 36). Und zwar am Offset 1000000 (1 mio). Der wievielte Block im File ist das?&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; &lt;em&gt;denk&lt;/em&gt;. Erstmal hat man ja nur den Dateinamen.&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Ja, das kümmert uns gerade noch nicht. Offset 1 mio &amp;ndash; welcher block? 1000000/1024 = 976.5625. Also Bytes 0-1023 sind Block 0, Bytes 1024-2047 sind Block 1 und so weiter.  In unserem fall also block 976. 976*1024=999424, 1000000-999424=576. Byte 1 000 000 steht also in Block 976, an Position 576 in diesem Block.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Okay. Stop mal. Hab da gleich ne Frage dazu:&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; 21:40 Isotopp&amp;gt; und das Wichtigste in &lt;code&gt;struct: __le32 i_block[EXT2_N_BLOCKS];&lt;/code&gt;
theclaw&amp;gt; dieser kontext: &lt;code&gt;i_block[976]&lt;/code&gt; brauchen wir da also. Ack? Und dazu noch das offset dazu?&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Ja, aber den kriegen wir nicht so.
&lt;a href=&#34;http://kris.koehntopp.de/artikel/dateisysteme/filestructure.gif&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://kris.koehntopp.de/artikel/dateisysteme/filestructure.gif&lt;/a&gt;

.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Ja, das wollte ich grad sagen. :-P Blocks 0-11 kriegen wir so. Muss man sich halt den Weg durchhangeln.&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; blocks 12-267 kriegen wir über den IND (single indirect block). Und blocks 268- kriegen wir über den DIND und den passenden IND.&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; 976-12=964, 964-256=708. 708/256=2.7656. Also müssen wir über den 2. IND des DIND gehen.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Ich weiss nicht ganz was du da rechnest.&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Naja, 1 KB blockgroesse, 4 byte pro blocknummer, also 256 blockadressen pro Block. 976ter Block ist gefragt.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; ay&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; 12 direct blocks, also 964 blocks dahinter.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Also mit einem &amp;ldquo;indirekten block&amp;rdquo; kann man 256 andere Blöcke adressieren, wie pointer in C&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Ich hab noch ganz grundlegende Fragen. Was wir wirklich wollen, ist doch das mapping logische Ext2block-Adresse der Datei → physische Blockadresse. Richtig?&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; In diesem speziellen Fall: ja. Die allgemeine Formulierung lautet so: Wir haben ein Quadrupel (major number, minor number, inode number, offset in bytes), das ist ein Device, eine Partition (maj, min), und in dem Device ein File (inode), und in dem File eine Byteposition. Und wir wollen ein Tripel (maj, min, blockno), also in der partition (maj, min) den zu dieser Datei gehörenden physikalischen Block.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; jo&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Weil (maj, min) bei dieser Abbildung konstant sind (wir arbeiten immer innerhalb derselben partition), vergessen wir maj und min und reden von einer Funktion die (ino, offset) auf (phy block) abbildet. Das nennt man ein Mapping. Und zwar ein Mapping für Datenblöcke. Daher heisst die funktion &lt;code&gt;bmap&lt;/code&gt;. Jedes Dateisystem hat so eine Funktion, daher reden wir hier über die bmap funktion von ext2, die heisst also sinnigerweise &lt;code&gt;ext2_bmap&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Schonmal sauhilfreich. ext2_bmap: Jetzt kann ich mir was darunter vorstellen. Danke. &lt;em&gt;codesuch&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Es ist eine diskrete Funktion.&lt;/p&gt;
&lt;p&gt;y = mx+k. Das sind kontinuierliche Funktionen von R-&amp;gt;R.&lt;/p&gt;
&lt;p&gt;Wir arbeiten hier mit diskreten, endlichen Funktionen. Die werden in der Regel als Lookuptable realisiert.&lt;/p&gt;
&lt;p&gt;Es gibt also eine Wertetabelle, die jedem (ino, offset) ein (phy block) zuordnet.&lt;/p&gt;
&lt;p&gt;Die Wertetabelle &lt;em&gt;ist&lt;/em&gt; die Inode. Eine Inode ist also ein Array von Blocknummern.&lt;/p&gt;
&lt;p&gt;Wenn es ein naives Array waere, dann waere die Inode variabel groß und für große Dateien sehr, sehr gross. Das ist wenig effizient.&lt;/p&gt;
&lt;p&gt;Daher hat man die Inode komprimiert, für kleine dateien (bis 12 blocks) speichert man die Wertetabelle tatsächlich &lt;em&gt;in&lt;/em&gt; der Inode (i_blocks[0-11]),
aber stell Dir dieses Verfahren mal für 1000 Blocks vor. Das wäre doof.&lt;/p&gt;
&lt;p&gt;Also speichert man die Wertetabelle für die Blöcke 12-267 nicht in der Inode, sondern in einem für diesen Zweck bestellten block, indem indirect block und in der Inode nur den einen Eintrag für diesen Block.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Ich habs soweit gecheckt.&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Das kann man beweisen.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;linux:/boot # dd if=/dev/zero of=kris bs=1k count=12
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;12 blocks a 1 KB (ich hab ja ein ext2 mit 1 KB blocks).&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;linux:/boot # ls -ls kris
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;12** -rw-r--r--  1 root root 12288 Dec 26 17:30 kris
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;12288 bytes lang 12 blocks belegt. Nun mal 13 KB.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;linux:/boot # dd if=/dev/zero of=kris bs=1k count=13
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;linux:/boot # ls -ls kris
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;14 -rw-r--r--  1 root root 13312 Dec 26 17:30 kris
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;13312 bytes, aber 14 blocks! Da ist er, der IND.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; &lt;em&gt;selbstausprobier&lt;/em&gt; Ist das die Anzahl der Blöcke für das Inode inklusive den Daten?&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Das ist die Anzahl der Blöcke OHNE die inode selber (Die belegt 128 byte in der Inodetable), also Daten + IND + DIND + TIND. Kann man auch beweisen.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;linux:/boot # dd if=/dev/zero of=kris bs=1k count=0
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;linux:/boot # ls -ls kris
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;0 -rw-r--r--  1 root root 0 Dec 26 17:33 kris
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Isotopp&amp;gt; File mit 0 Byte belegt 0 Blocks, Inode wird also nicht gezählt.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; okay. Das war hilfreich die Erklaerung, danke.&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Also wir haben in der Inode das Lookup Array für eine diskrete Funktion, eine Wertetabelle,
und die Speicherung des Array ist ulkig. Und wir haben deswegen overhead, weil wir die
mit 1, 2 und 3 markierten Blöcke in
&lt;a href=&#34;http://kris.koehntopp.de/artikel/dateisysteme/filestructure.gif&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://kris.koehntopp.de/artikel/dateisysteme/filestructure.gif&lt;/a&gt;


irgendwann belegen müssen. Und deswegen siehst du die Sprünge - kein File hat jemals 13 Blocks.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Moment, aber das ist ja sau umständlich eine ganze Datei zu lesen dann? :)&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Ah! Jetzt dämmert es langsam. Ist ja nicht so, dass ext2 GUT wäre.&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; So, jetzt gehen wir noch mal in den Code&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Das ist
&lt;a href=&#34;http://lxr.linux.no/source/fs/ext2/inode.c#L665&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ext2_bmap&lt;/a&gt;

, sehr kurz. Du erinnerst dich: JEDES Dateisystem hat ein bmap.
Darum ist &lt;code&gt;ext2_bmap&lt;/code&gt; sehr kurz, es ruft &lt;code&gt;generic_block_bmap&lt;/code&gt; auf. Das wiederum ruft dann allerdings
&lt;code&gt;ext2_get_block&lt;/code&gt; auf, das die Arbeit für &lt;code&gt;generic_block_bmap&lt;/code&gt; macht. &lt;code&gt;generic_block_bmap&lt;/code&gt; kriegt also
einen Callback nach &lt;code&gt;ext2_get_block&lt;/code&gt; mitgegeben. Wir landen also in
&lt;a href=&#34;http://lxr.linux.no/source/fs/ext2/inode.c#L547&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ext2_get_block&lt;/a&gt;

. So weit so klar?&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Ja warte. Ich schau mir den Code gerade an.&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Tut nicht not. Noch nicht. Erst mal ist nur wichtig, wie wir zu &lt;code&gt;ext2_get_block&lt;/code&gt;
kommen und wieso da ein Umweg über das &lt;code&gt;generic_block_bmap&lt;/code&gt; gemacht wird.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Nicht klar. Warte. Wo bei &lt;code&gt;ext2_get_block()&lt;/code&gt; ist das Offset?&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; in &lt;code&gt;iblock&lt;/code&gt; (2. parameter), ist schon umgerechnet in eine blocknummer.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Ah klar, der n. block eines inodes.&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Wir sind also in
&lt;a href=&#34;http://lxr.linux.no/source/fs/ext2/inode.c#L547&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://lxr.linux.no/source/fs/ext2/inode.c#L547&lt;/a&gt;

 und sollen &lt;code&gt;iblock&lt;/code&gt;
aus &lt;code&gt;inode&lt;/code&gt; (1. parameter) fischen. Also block 976 aus file 36. Wir müssen ja nun je nach
Blockoffset unterschiedlich kompliziert die Lookuptable runterklettern. Bei blocks 0-11 wäre
alles ganz einfach, bei 12-267 kommt der IND dazu und bei den folgenden Blöcken der DIND.
Soweit das Verfahren grundsätzlich klar?&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Ich schau mir das .gif nochmal an.&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Es wird leichter, wenn du
&lt;a href=&#34;http://lxr.linux.no/source/fs/ext2/inode.c#L196&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://lxr.linux.no/source/fs/ext2/inode.c#L196&lt;/a&gt;

 liest.
&lt;code&gt;i_block&lt;/code&gt; ist also 976. Dann schau mal in die Zeile 196. Zeile 201: &lt;code&gt;direct_blocks&lt;/code&gt; ist 12. &lt;code&gt;indirect_blocks&lt;/code&gt; ist ptrs, also 256.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; &lt;code&gt;ext2_block_to_path&lt;/code&gt;. Das &lt;code&gt;path&lt;/code&gt; hat nix mit dem Dateisystempfad zu tun, sondern mit dem Pfad, wie man zum Block kommt. Ahh.&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Es geht um den Path in
&lt;a href=&#34;http://kris.koehntopp.de/artikel/dateisysteme/filestructure.gif&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://kris.koehntopp.de/artikel/dateisysteme/filestructure.gif&lt;/a&gt;

, ja.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Warte, ich hab eine Frage zu dem GIF. Da z.b. &amp;ldquo;1&amp;rdquo;, also der erste indirekte Block. Der koennte auf 256 weitere zeigen?&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Ja. In unserem Beispiel ist das so, 4 byte pro blocknummer und 1 kb pro block. Bei anderen
Größen (8 byte pro blocknr, und 4 kb pro block) ist das anders. 4096/8 = 512 pro IND z.B.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; hm. Sorry, ich dachte ne Blocknummer ist 32bit?&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Ja, in unserem Beispiel ist das so. Aber es waere ja möglich, das alles mit anderen Sizes zu compilen.
Und dann soll es auch noch funktionieren. Also coden wir das alles nicht hart rein, sondern speichern die
Rahmendaten im Superblock des Filesystems und schreiben den Code ordentlich. Soweit so klar?&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; jo&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Drum auch der Code in
&lt;a href=&#34;http://lxr.linux.no/source/fs/ext2/inode.c#L196&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://lxr.linux.no/source/fs/ext2/inode.c#L196&lt;/a&gt;

, Zeilen 199 bis 203.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Den ich mir grad anschaue. ;)&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Der fragt den Superblock sb nach den Anzahl der Adressen pro Block, und bestimmt dann die &lt;code&gt;direct_blocks&lt;/code&gt;,
die Anzahl der Blockadressen pro indirect Block in &lt;code&gt;indirect_block&lt;/code&gt; und die Anzahl der Blockadressen pro Double Indirect Block.&lt;/p&gt;
&lt;p&gt;Der macht das ein wenig komisch. Erst mal &lt;code&gt;direct_blocks&lt;/code&gt;. Das ist leicht, da nimmt er nur den #define.
&lt;code&gt;indirect_blocks&lt;/code&gt; ist auch leicht, das ist ptrs, also &lt;code&gt;EXT2_ADDR_PER_BLOCK(...sb)&lt;/code&gt;, also mal im Superblock nachschlagen.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;[#define EXT2_ADDR_PER_BLOCK(s)          (EXT2_BLOCK_SIZE(s) / sizeof (__u32))](http://lxr.linux.no/source/include/linux/ext2_fs.h#L100)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Block size bei uns 1024 und &lt;code&gt;sizeof __u32&lt;/code&gt; ist immer 4. Also ist mein beispiel mit 8 derzeit hypothetisch.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; ;)&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Ein double block kann ebenfalls ptrs viele Blockadressen enthalten, also 256 Stück. Jede von denen ist ein indirect block, der 256 Datenblöcke enthält.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; also 256^2 und ein TIND für 256^3.&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Nun will er das aus irgendeinem Grund nicht so rechnen, sondern mit bit shifts, also macht er 1 &amp;laquo; (ptrs_bits * 2).&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Also warte, kann man 256+256^2+256^3 Blöcke adressieren, d.h. kann ne Datei so groß sein?&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Ja, das ist auch noch ein Limit. Aber da wir nur 2^32 viele Blocknummern haben, ist bei 4 Gigablocks Schluss, also bei 4 TB (1 kb Blöcke) oder 16 TB (4 kb Blöcke).&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Okay, irgendwie so ;)&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Du müßtest schon die Blocknummern länger machen als ein &lt;code&gt;__u32&lt;/code&gt;, damit mehr geht, dann passen aber weniger direct_blocks in eine Inode, oder die Inode wird größer.&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Aber wir wollen mal weiter im Code. Schau in zeile 207. Was machen die da?&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; &lt;code&gt; if (i_block &amp;lt; 0) {&lt;/code&gt;
Isotopp&amp;gt; geht das überhaupt?&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Warte&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Nah, nur durch nen Programmierfehler evtl.&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Welchen typ hat &lt;code&gt;i_block&lt;/code&gt;?&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; unsigned? :) Ja, okay. Das geht überhaupt nicht.&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Steht oben in der Funktion - da ist es ein LONG!&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; ah, doch ein signed :)&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Aber eine Blocknummer, das haben wir vorher gesehen, ist ein &lt;code&gt;__u32&lt;/code&gt;!&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Macht das sinn?&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Nein, das ist FAHALSCH!&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Sag das doch!&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Du hast gerade deinen ersten Kernelfehler gefunden.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Geil! ;)&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Der Fehler sieht Blocknummern als signed, daher ist also nun schon bei 2 Gigablocks zu, also 2 TB und 8 TB Filesize (für 1 und 4 kb Blocksize). Aber weiter im Text, Zeile 209.&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Weiter zu 212. &lt;code&gt;((i_block -= direct_blocks) &amp;lt; indirect_blocks)&lt;/code&gt; ist dir auch klar? Wir zermatschen &lt;code&gt;i_blocks&lt;/code&gt; hier als Seiteneffekt.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; ja bin ein C-ler. Daran scheitert die Erklaerung nicht ;)&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Also sind wir in 216. Nun ist &lt;code&gt;i_block&lt;/code&gt; also 964 und wir ziehen 256 (&lt;code&gt;indirect_blocks&lt;/code&gt;) ab. Das sind 708. Und &lt;code&gt;double_blocks&lt;/code&gt; ist 256^2. Also true. Also speichern wir in 217: lese &lt;code&gt;EXT2_DIND_BLOCK&lt;/code&gt;, dann in 218: lese &lt;code&gt;i_block/256&lt;/code&gt; (&lt;code&gt;i_block &amp;gt;&amp;gt; ptrs_bits&lt;/code&gt;), und in 219: lese &lt;code&gt;i_block % 256&lt;/code&gt; (&lt;code&gt;i_block &amp;amp; ( ptrs - 1)&lt;/code&gt;). Dann sind wir fertig.&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Wir sind wieder in &lt;a href=&#34;http://lxr.linux.no/source/fs/ext2/inode.c#L547&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://lxr.linux.no/source/fs/ext2/inode.c#L547&lt;/a&gt;

, line 557 nun, soweit klar?&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Kleinen Moment, das Bitshifting finde ich verwirrend.&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; ja&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; ich weiss jetzt, was &lt;code&gt;ext2_block_to_path&lt;/code&gt; macht.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Also warte mal. Lass mich mal zusammenfassen.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Naja, nicht mal so einfach zu beschreiben.&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Doch schon. Dir fehlen nur die Worte.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; :] jo&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Wir haben nun offset[0], offset[1] und offset[2]. In offset[0] steht welches Feld aus der Inode wir nehmen (das DIND feld),  Wir haben dann einen Block mit 256 Feldern, und nehmen das Feld offset[1] da draus, lesen den Block und nehmen das Feld offset[2] da draus.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Naja, das sind ja Details. Mich interessiert aber eher das Design als die Implementation ;), Das geht mir schon zu sehr in die Tiefe ehrlich gesagt.&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Allgemeiner: wir haben ein Array, das nicht linear ist, sondern quadratisch steigend durch Indirektion komprimiert wird, und bei unseren Randparametern ist die schrittweite 8 bit (256 entries) pro Block, also 256, 256^2, 256^3, &amp;hellip; und das ist genau die Zeichnung
&lt;a href=&#34;http://kris.koehntopp.de/artikel/dateisysteme/filestructure.gif&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://kris.koehntopp.de/artikel/dateisysteme/filestructure.gif&lt;/a&gt;

.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Okay. Jetzt sind meine Fragen geklärt oder? Dieses ganze Detailwissen erschlägt mich ;)&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Der Rest sind tatsaechlich Kerneldetails. Das hier war die Logik. Der Punkt ist, dass du in &lt;code&gt;block_to_path&lt;/code&gt; durch die Faltlogik geklettert bist. Also die, die das mit DIR, IND, DIND und TIND analysiert und entscheidet.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Naja, Faltlogik?&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Ja, erst 12 direkt, dann 256 einmal gefaltet, dann 256*256 zweimal gefaltet, dann 256*256*256 dreimal gefaltet statt eines einzigen linearen Arrays das zum groessten Teil leer waere.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Hm, ich versteh zwar das System, aber nicht was das mit Falten zu tun hat ;)&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Naja, statt eines Array mit 2 Gigaentries (Kernelbug!) hast du ein Array mit 15 Eintraegen, bei dem die ersten 12 Eintraege für sich selber stehen, der Eintrag 13 für 256 Eintraege, der Eintrag 14 für 256 Eintraege, die für 256 Eintraege stehen, steht, und der Eintrag 15 für 256 Eintraege die für 256 Eintraege, die für 256 Eintraege stehen steht. Also einmal falten, zweimal falten, dreimal falten.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Aber &amp;ldquo;falten&amp;rdquo;?&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; So in etwa:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;   ___
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;___\ /___
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;theclaw&amp;gt; Was stellt das dar?&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Ein Eintrag, der für viele steht. Ein Blatt Papier mit zwei Knicks, ein Eintrag (der zwischen \ /) steht für Drei (___)&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Und zum Schluß
&lt;a href=&#34;http://www.tamacom.com/tour.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://www.tamacom.com/tour.html&lt;/a&gt;

,
&lt;a href=&#34;http://www.tamacom.com/tour/kernel/unix/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://www.tamacom.com/tour/kernel/unix/&lt;/a&gt;

,
&lt;a href=&#34;http://www.tamacom.com/tour/kernel/unix/S/97.html#L18&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://www.tamacom.com/tour/kernel/unix/S/97.html#L18&lt;/a&gt;

.&lt;/p&gt;
&lt;p&gt;Das, mein Freund, ist der Urvater aller bmaps, bmap in V7 Unix.&lt;/p&gt;
&lt;p&gt;Rein gehen eine &lt;code&gt;struct inode&lt;/code&gt;, die inode,  eine &lt;code&gt;daddr_t bn&lt;/code&gt;, eine blocknummer und ein &lt;code&gt;rwflag&lt;/code&gt;, das ist aber Wurst. Raus geht eine &lt;code&gt;daddr_t&lt;/code&gt; blocknummer.&lt;/p&gt;
&lt;p&gt;Also (ino, block_in_file) -&amp;gt; (phys blocknr). NADDR ist die Anzahl der Eintraege in der Inode. Also sind 0-&amp;gt; NADDR-4 die direct blocks, NADDR-3 der IND,  NADDR-2 der DIND  und NADDR-1 der TIND.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Aber den Code will ich mir jetzt nicht genauer ansehen, sorry ;)&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Das ist derselbe Code, nur noch verquaster. Der ist ja auch 30 Jahre alt.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Den Link bookmarke ich mal, das könnte noch interessant werden.&lt;/p&gt;
&lt;p&gt;Isotopp&amp;gt; Und weil es so schön ist, sind da auch die FreeBSD, NetBSD, OpenBSD und Hurd Versionen von demselben Zeug. Und da kannst du dann sehen wie fundamental das ist, was Du da gerade anfasst. Und wie sich C-Style im Kernel in den letzten 30 Jahren so entwickelt hat. Weil das V7 Zeugs da sind etwa 30 Jahre von hier, das 4.3BSD sind ca. 20 Jahre von hier und das Linux-Zeugs ist von jetzt.&lt;/p&gt;
&lt;p&gt;theclaw&amp;gt; Wenn ich das so seh fällt mir grad auf wie sinnvoll man seine Zeit nützen könnte ;)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>User und Gruppen, Prozesse und Dateien</title>
      <link>https://blog.koehntopp.info/2005/11/01/user-und-gruppen-prozesse-und-dateien.html</link>
      <pubDate>Tue, 01 Nov 2005 18:41:28 +0000</pubDate><author>kris-blog@koehntopp.de (Kristian Köhntopp)</author>

      <guid>https://blog.koehntopp.info/2005/11/01/user-und-gruppen-prozesse-und-dateien.html</guid>
      <description>&lt;p&gt;Heute im Irc stellte eine Teilnehmerin den folgenden Fragenschwall:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Wie finde ich eigentlich heraus, was für Gruppen es auf einem
Linuxsystem gibt? Wie füge ich da jemanden hinzu? Lege ich den
zuerst als User an, ganz normal? Und: Wenn ich einen Ordner
anlege, der nur für eine bestimmte Gruppe zugänglich sein
soll, mache ich das doch über File Permissions, oder habe ich
falsch gedacht?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Die offensichtliche Antwort, das Nachsehen in &lt;code&gt;/etc/group&lt;/code&gt;,
funktioniert bei modernen Unixen nicht mehr zwingend, denn
Gruppendefinitionen können nicht nur in lokalen Dateien stehen,
sondern auch aus dem NIS, dem NIS+, einem LDAP oder einem Active
Directory kommen.&lt;/p&gt;
&lt;p&gt;Die folgenden Dinge wurden mit Suse Linux 10.0 getestet, sollten
so aber auch auf Solaris funktionieren.&lt;/p&gt;
&lt;h2 id=&#34;name-service-switch&#34;&gt;
    &lt;a href=&#34;#name-service-switch&#34;&gt;
	Name Service Switch
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Genauer gesagt haben moderne Unixe ein Subsystem namens Name
Service Switch. Der Name Service Switch erlaubt es dem System,
für Benutzer, Gruppen, Hostnamen, Protokolle, Service und noch
ein paar Dinge beliebige Datenquellen zu verwenden, für die
vorgefertige Module existieren.&lt;/p&gt;
&lt;p&gt;Der Name Service Switch wird durch die Datei
&lt;code&gt;/etc/nsswitch.conf&lt;/code&gt; gesteuert. Dort findet man für jede
Datenbasis (passwd, group, hosts, &amp;hellip;) einen einzeiligen
Eintrag. Nach dem Namen der Datenbasis werden durch Leerzeichen
getrennt die Namen der Datenquellen aufgelistet, und zwar in der
Reihenfolge, in der sie durchsucht werden sollen.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;passwd: files nis
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;shadow: files nis
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;group: files nis
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;hosts: files dns
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Diese Beispielkonfiguration holt ihre Benutzerdaten für Passwd-
und Shadow-Datei sowie die Gruppen aus den lokalen Dateien und
danach aus dem NIS, und sie ermittelt Hostnamen aus der lokalen
&lt;code&gt;/etc/hosts&lt;/code&gt; und danach aus dem DNS.&lt;/p&gt;
&lt;p&gt;Die Syntax für die &lt;code&gt;/etc/nsswitch.conf&lt;/code&gt; ist noch ein wenig
komplizierter. Zwischen den Einträgen für Datenquellen können in
eckigen Klammern nämlich noch Anweisungen für das Verhalten in
Fehlerfällen stehen. Auf diese Weise sind Setups möglich, die
ihre Daten normalerweise NUR aus dem NIS ziehen, aber aus den
lokalen Dateien, falls das NIS einmal nicht erreichbar sein
sollte.&lt;/p&gt;
&lt;p&gt;Die Datenbasen des Name Service Switch lassen sich mit dem
Kommando &lt;code&gt;getent&lt;/code&gt; testen. &lt;code&gt;getent group&lt;/code&gt; listet zum Beispiel die
gesamte &lt;code&gt;group&lt;/code&gt;-Datenbasis auf, &lt;code&gt;getent group disk&lt;/code&gt; listet nur
den Eintrag für die Gruppe &lt;code&gt;disk&lt;/code&gt; auf.&lt;/p&gt;
&lt;p&gt;Wir merken uns:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In einem modernen Unix mit Name Service Switch ist es also
falsch, eine Liste der Gruppen des Systems durch Auslesen von
&lt;code&gt;/etc/group&lt;/code&gt; zu erzeugen. Stattdessen muß die Liste mit
&lt;code&gt;getent group&lt;/code&gt; erzeugt werden.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Das Interface des Name Service Switch ist read-only. Es erlaubt
nicht die virtualisierte Erzeugung von Gruppen. Schreibzugriffe
müssen also weiterhin manuell in die richtige Datenbank geroutet
werden, also in eine lokale Datei oder in ein LDAP geschrieben
werden.&lt;/p&gt;
&lt;h2 id=&#34;prozesse-und-dateien&#34;&gt;
    &lt;a href=&#34;#prozesse-und-dateien&#34;&gt;
	Prozesse und Dateien
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;User und Gruppen sind nur dann von Bedeutung, wenn sie auch vom
Systemteilen verwendet werden. Systemteile sind Subjekte, also
Prozesse, und Objekte, also Dateien.&lt;/p&gt;
&lt;p&gt;Ein Prozeß in Unix hat eine effektive User-ID und eine effektive
primäre Gruppen-ID. Er kann außerdem eine Reihe von weiteren
sekundären Gruppen-IDs enthalten.&lt;/p&gt;
&lt;p&gt;Das Kommando &amp;ldquo;id&amp;rdquo; listet die User- und Gruppen-IDs eines Benutzers:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;kris@dhcp-179:~&amp;gt; id -a
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;uid=1000(kris) gid=100(users) Gruppen=16(dialout),33(video),100(users)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Der Benutzer kris hat also die User-ID 1000 und die primäre
Gruppen-ID 100. Er gehört außerdem den Gruppen 16 (dialout) und
33 (video) an.&lt;/p&gt;
&lt;p&gt;Wenn dieser Prozeß eine Datei erzeugt, dann gehört diese Datei
ebenfalls dem Benutzer 1000 (kris) und sie wird standardmäßig
(&amp;ldquo;System V Semantik&amp;rdquo;) der Gruppe 100 (users) angehören, denn
dies sind die primäre User- und Gruppen-ID dieses Prozesses.&lt;/p&gt;
&lt;p&gt;Es gibt eine andere Betriebsart für Dateisysteme (&amp;ldquo;BSD Semantik&amp;rdquo;), bei der neu angelegte Dateien nicht die primäre Gruppe des anlegenden Prozesses erben, sondern die Gruppe des unmittelbar übergeordneten Verzeichnisses. Man kann das ext2-Dateisystem komplett auf BSD-Semantik umstellen, indem man es mit der Option &amp;ldquo;grpid&amp;rdquo; (alternativ &amp;ldquo;bsdgroups&amp;rdquo;) mounted - der Default ist &amp;ldquo;nogrpid&amp;rdquo; (alternativ &amp;ldquo;sysvgroups&amp;rdquo;). In der Betriebsart &amp;ldquo;nogrpid&amp;rdquo; kann man für ein einzelnes Verzeichnis BSD Semantik wählen, indem man das SGID-Bit an dem Verzeichnis setzt. Hier ein Beispiel:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;dhcp-179:~ # lvcreate -l 10 -n test system
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;Logical volume &amp;#34;test&amp;#34; created
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;dhcp-179:~ # mke2fs -q /dev/system/test
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;dhcp-179:~ # mount -o nogrpid /dev/mapper/system-test /export/test
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;dhcp-179:~ # mkdir /export/test/bla /export/test/fasel
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;dhcp-179:~ # chown kris:video /export/test/bla /export/test/fasel
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;dhcp-179:~ # chmod g+s /export/test/fasel
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;dhcp-179:~ # su - kris
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;kris@dhcp-179:~&amp;gt; cd /export/test
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;kris@dhcp-179:/export/test&amp;gt; touch bla/eins fasel/zwei
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;kris@dhcp-179:/export/test&amp;gt; ls -l bla/eins fasel/zwei
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;-rw-r--r-- 1 kris users 0 2005-11-01 18:59 bla/eins
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;-rw-r--r-- 1 kris video 0 2005-11-01 18:59 fasel/zwei
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;kris@dhcp-179:/export/test&amp;gt; ls -ld bla fasel
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;drwxr-xr-x 2 kris video 1024 2005-11-01 18:59 bla
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;drwxr-sr-x 2 kris video 1024 2005-11-01 18:59 fasel
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;In diesem Beispiel wird das logical Volume &lt;code&gt;test&lt;/code&gt; in der Volume
Group &lt;code&gt;system&lt;/code&gt; angelegt und mit dem ext2-Dateisystem formatiert.
Das Dateisystem wird mit der Option &lt;code&gt;nogrpid&lt;/code&gt; als /export/test
gemountet, was der Default für ext2 ist (und bei reiserfs
unveränderlich immer der Fall ist).&lt;/p&gt;
&lt;p&gt;In &lt;code&gt;/export/test&lt;/code&gt; werden die Verzeichnisse &lt;code&gt;bla&lt;/code&gt; und &lt;code&gt;fasel&lt;/code&gt; anlegt
und beide auf &lt;code&gt;kris:video&lt;/code&gt; gesetzt. An &lt;code&gt;fasel&lt;/code&gt; wird zusätzlich noch
das SGID-Bit gesetzt.&lt;/p&gt;
&lt;p&gt;Legt der User &lt;code&gt;kris:users&lt;/code&gt; nun in &lt;code&gt;bla&lt;/code&gt; und &lt;code&gt;fasel&lt;/code&gt; jeweils eine Datei
an, wird die Datei in &lt;code&gt;bla&lt;/code&gt; (System V Semantik, bzw. nogrpid) der
Gruppe users angehören. Die Datei in &lt;code&gt;fasel&lt;/code&gt; (BSD Semantik, durch
+s umgeschaltet) erbt ihre Gruppenzugehörigkeit jedoch vom
übergeordneten Verzeichnis, gehört also &lt;code&gt;kris:video&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Dasselbe Beispiel wie oben für ein Dateisystem, das mit &lt;code&gt;grpid&lt;/code&gt;
gemountet wurde, ergibt dann das folgende Bild:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;kris@dhcp-179:/export/test&amp;gt; touch bla/eins fasel/zwei
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;kris@dhcp-179:/export/test&amp;gt; ls -ld bla fasel
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;drwxr-xr-x 2 kris video 1024 2005-11-01 19:04 bla
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;drwxr-sr-x 2 kris video 1024 2005-11-01 19:04 fasel
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;kris@dhcp-179:/export/test&amp;gt; ls -l bla/eins fasel/zwei
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;-rw-r--r-- 1 kris video 0 2005-11-01 19:04 bla/eins
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;-rw-r--r-- 1 kris video 0 2005-11-01 19:04 fasel/zwei
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Das SGID-Bit am Verzeichnis hat dann also keine Wirkung mehr,
weil das Dateisystem an sich hier schon BSD-Semantik hat.&lt;/p&gt;
&lt;p&gt;Reiserfs kennt die Optionen &lt;code&gt;grpid&lt;/code&gt; und &lt;code&gt;nogrpid&lt;/code&gt; nicht und
verhält sich immer wie ein ext2-Dateissystem mit &lt;code&gt;nogrpid&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Wie kann man nun ein Verzeichnis einer Gruppe schenken? Nun, das
geht einfach mit chgrp:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;kris@dhcp-179:~&amp;gt; mkdir keks
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;kris@dhcp-179:~&amp;gt; chgrp video keks
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;kris@dhcp-179:~&amp;gt; chgrp disk keks
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;chgrp: Ändern der Gruppe für „keks“: Die Operation ist nicht erlaubt
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;kris@dhcp-179:~&amp;gt; chgrp users keks
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Offenbar kann man ein Verzeichnis nur Gruppen schenken, denen
man selbst angehört. Das ist deswegen so, weil Unix die
Zuordnung von Quotas zu Benutzern und zu Gruppen erlaubt. Indem
man eine Datei einer Gruppe schenkt, belastet die Datei die
Quota der Gruppe und natürlich darf man nur die Quota einer
Gruppe belasten, der man auch angehört.&lt;/p&gt;
&lt;p&gt;Wenn man eine Datei in einem Verzeichnis mit BSD-Semantik
anlegt, dann erbt diese Datei jedoch immer die Gruppe des
Verzeichnisses, selbst dann, wenn der Benutzer, der die Datei
anlegt, nicht dieser Gruppe angehört - hier kann dann ein
fremder Benutzer die Quota einer Gruppe belasten, der er nicht
angehört. Es ist also Aufgabe einer Gruppe, die Zugriffsrechte
an ihren Verzeichnissen so zu setzen, daß dort nicht fremde
Leute Daten ablegen können und so die Quota der Gruppe belasten.&lt;/p&gt;
&lt;p&gt;Es ist außerdem möglich (wenn auch unwahrscheinlich), daß ein
Benutzer so eine Datei anlegen kann, die er später nicht mehr
lesen darf.&lt;/p&gt;
&lt;p&gt;Das Szenario ist konstruiert, aber technisch möglich:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;gp&#34;&gt;#&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;# Kris legt ein Verzeichnis an&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;kris@dhcp-179:~&amp;gt; mkdir keks
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;kris@dhcp-179:~&amp;gt; chmod a+rwx,g+s keks
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;kris@dhcp-179:~&amp;gt; chgrp video keks
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;kris@dhcp-179:~&amp;gt; ls -ld keks
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;drwxrwsrwx 2 kris video 48 2005-11-01 19:17 keks
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;gp&#34;&gt;#&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;# kdebuild legt dort eine Datei an&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;kdebuild@dhcp-179:/home/kris/keks&amp;gt; umask 0727
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;kdebuild@dhcp-179:/home/kris/keks&amp;gt; touch bla
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;kdebuild@dhcp-179:/home/kris/keks&amp;gt; ls -l bla
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;----r----- 1 kdebuild video 0 2005-11-01 19:18 bla
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;kdebuild@dhcp-179:/home/kris/keks&amp;gt; cat bla
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;cat: bla: Keine Berechtigung
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Das ist für ein Rechtesystem eine unschöne Situation. Fällt
jemandem ein sinnvoller Anwendungszweck für diese Eigenschaft
des Unix-Rechtesystems ein?&lt;/p&gt;
&lt;p&gt;Wir merken uns:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Um ein Verzeichnis zu erzeugen, auf das nur eine bestimmte
Gruppe Zugriff hat, legen wir das Verzeichnis an und schenken
es der Gruppe mit &lt;code&gt;chgrp&lt;/code&gt;, dann setzen wir die Zugriffsrechte
auf &lt;code&gt;rwxrwx---&lt;/code&gt; oder ähnlich.&lt;/p&gt;
&lt;p&gt;Wenn wir außerdem das SGID-Bit am Verzeichnis mit &lt;code&gt;chmod g+s …&lt;/code&gt; setzen, werden auch alle Dateien im Verzeichnis der
Gruppe gehören. Um ein Verzeichnis einer Gruppe schenken zu
können, muß man selbst Mitglied der Gruppe sein.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;zugriffsrechte-an-dateien&#34;&gt;
    &lt;a href=&#34;#zugriffsrechte-an-dateien&#34;&gt;
	Zugriffsrechte an Dateien
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;In den letzten 30 Jahren war es in Unix immer so, daß eine Datei
einen Eigentümer und eine Eigentümer-Gruppe hatte. Rechte wurden
für den Eigentümer und die Eigentümer-Gruppe vergeben. Prozesse
hatten ebenfalls einen Eigentümer und eine Gruppe, und Unix hat
stur den folgenden simplen Test durchgeführt, um zu bestimmen,
welche Rechte für eine Datei gelten:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Stimmen der Datei-Eigentümer und der Prozeß-Eigentümer
überein? Wenn ja, dann gelten die User-Rechte, also das erste
rwx-Tripel. Das ist selbst dann der Fall, wenn in einem anderen
Tripel bessere Rechte definiert sind.&lt;/li&gt;
&lt;li&gt;Stimmen die Datei-Eigentümergruppe und eine der primären oder
sekundären Gruppen eines Prozesses überein? Wenn ja, dann gelten
die Gruppen-Rechte, also das zweite rwx-Tripel. Das ist selbst
dann der Fall, wenn im 3. Tripel bessere Rechte definiert
sind.&lt;/li&gt;
&lt;li&gt;In allen anderen Fällen gelten die Rechte aus dem 3. Tripel.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;access-control-lists-acls&#34;&gt;
    &lt;a href=&#34;#access-control-lists-acls&#34;&gt;
	Access Control Lists (ACLs)
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Mit modernen Unixen ist es jedoch alles viel komplizierter
geworden, denn nun können im Prinzip an einer Datei selber auch
viele Benutzer- und Gruppenrechte kleben.&lt;/p&gt;
&lt;p&gt;Zum Glück nicht per Default.&lt;/p&gt;
&lt;p&gt;Damit die Lage kompliziert wird, muß man das betreffende
Dateisystem mit der Option &lt;code&gt;acl&lt;/code&gt; mounten. Im Beispiel erzeugen
wir zur Abwechslung mal ein reiserfs und mounten dies mit der
passenden Option. Mit den Kommandos &lt;code&gt;getfacl&lt;/code&gt; und &lt;code&gt;setfacl&lt;/code&gt; (&amp;ldquo;get
and set a file access control list&amp;rdquo;) können wir dann lustig
individuelle Zugriffsrechte vergeben.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;dhcp-179:~ # lvcreate -l 10 -n test system
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;Logical volume &amp;#34;test&amp;#34; created
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;dhcp-179:~ # mkreiserfs -q /dev/system/test
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;mkreiserfs 3.6.18 (2003 www.namesys.com)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;dhcp-179:~ # mount -o acl /dev/mapper/system-test /export/test
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;dhcp-179:~ # cd /export/test
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;dhcp-179:/export/test # touch keks
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;dhcp-179:/export/test # chmod 000 keks
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;dhcp-179:/export/test # setfacl -m u:kris:rwx,mask::rwx,g:video:rwx,u:kdebuild:rx keks
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;dhcp-179:/export/test # ls -l keks
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;----rwx---+ 1 root root 0 Nov 1 19:26 keks
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;dhcp-179:/export/test # getfacl keks
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;&lt;/span&gt;&lt;span class=&#34;gp&#34;&gt;#&lt;/span&gt; file: keks
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;gp&#34;&gt;#&lt;/span&gt; owner: root
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;gp&#34;&gt;#&lt;/span&gt; group: root
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;user::---
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;user:kris:rwx
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;user:kdebuild:r-x
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;group::---
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;group:video:rwx
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;mask::rwx
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;other::---
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Eine Datei mit einer ACL wird von ls mit einem &amp;ldquo;+&amp;quot;-Zeichen
markiert. Statt den Rechten der Gruppe werden dann im  zweiten
Tripel die Rechte der Mask angezeigt.&lt;/p&gt;
&lt;p&gt;Die Mask limitiert alle anderen Zugriffsrechte an der Datei
ausgenommen den Eigentümer und Others. Sie legt also quasi die
maximalen Rechte fest, die irgendjemand außer dem Eigentümer an
der Datei haben kann, wenn er nicht die Defaultrechte bekommt.&lt;/p&gt;
&lt;p&gt;Dies ist ein Kompatibilitätsmechanismus, der meistens das
korrekte Verhalten von Programmen bewirken soll, die nichts von
Zugriffsrechten wissen - sie bekommen durch Auslesen des zweiten
Rechtetripels einen etwas optimistischen View auf die Rechte,
die sie wahrscheinlich haben werden. :)&lt;/p&gt;
&lt;p&gt;Das Kommando &lt;code&gt;setfacl&lt;/code&gt; kann jetzt die Rechte an einer Datei
modifizieren. Die Option &lt;code&gt;-m&lt;/code&gt; (modify) bewirkt das.&lt;/p&gt;
&lt;p&gt;Im Beispiel werden Rechte für Benutzer (&amp;ldquo;u:&amp;rdquo;) und Gruppen (&amp;ldquo;g:&amp;rdquo;)
sowie eine Mask (&amp;ldquo;m:&amp;rdquo;) definiert.&lt;/p&gt;
&lt;p&gt;Liest man die ACL mit getfacl aus, wird recht schnell deutlich,
was hier geschieht:&lt;/p&gt;
&lt;p&gt;Der Eigentümer der Datei hat an ihr keine Rechte, der User kris
hat die Rechte rwx, der User kdebuild hat die Rechte rx, die
Defaultgruppe hat keine Rechte, die Gruppe video hat die Rechte
rwx, und die Maske schränkt die Rechte von kris, kdebuild, video
und der Defaultgruppe nicht ein.&lt;/p&gt;
&lt;p&gt;Der Rest der Welt hat keine Rechte an dieser Datei.&lt;/p&gt;
&lt;p&gt;Wir merken uns:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Dateisysteme, die mit der Option &amp;ldquo;acl&amp;rdquo; gemounted wurden,
können beliebig komplizierte Rechteregeln pro Datei haben. Es
ist mit einem &amp;ldquo;+&amp;rdquo; an der Datei zu erkennen, ob dies der Fall
ist. Diese ACLs können mit setfacl editiert und mit getfacl
gelesen werden.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;acls-an-verzeichnissen&#34;&gt;
    &lt;a href=&#34;#acls-an-verzeichnissen&#34;&gt;
	ACLs an Verzeichnissen
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Um die Sache noch komplizierter zu machen, haben Verzeichnisse
&lt;em&gt;zwei&lt;/em&gt; ACLs:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Eine normale wie wir sie schon kennen, die für das Verzeichnis
selber gilt,&lt;/li&gt;
&lt;li&gt;eine &lt;em&gt;default&lt;/em&gt; ACL, die für alle Verzeichnisse
und Dateien gilt, die in dem Verzeichnis erzeugt werden.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Werte für die Default-ACL werden festgelegt, indem man sie beim
&amp;ldquo;setfacl&amp;rdquo; mit &amp;ldquo;d:&amp;rdquo; prefixed, also &amp;ldquo;d:u:kris:rwx&amp;rdquo;,
&amp;ldquo;d:g:video:rwx&amp;rdquo; und &amp;ldquo;d:m::rwx&amp;rdquo;.&lt;/p&gt;
&lt;h2 id=&#34;tldr&#34;&gt;
    &lt;a href=&#34;#tldr&#34;&gt;
	TL;DR
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Wir merken uns:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In den allermeisten Fällen tut das Unix-Rechtesystem mit den
drei Tripeln &amp;ldquo;ugo&amp;rdquo; und den drei Rechten &amp;ldquo;rwx&amp;rdquo; genau das, was
man von ihm will.&lt;/p&gt;
&lt;p&gt;Sehr selten braucht man was komplizierteres, und dann steht es
zur Verfügung.&lt;/p&gt;
&lt;p&gt;Selbst dann ist das Rechtesystem von Unix noch einfacher und
übersichtlicher zu warten als das von Windows, getreu dem
Motto &amp;ldquo;Simple things should be simple, and complex things
should be possible.&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>#!/bin/bash -- Brace Expansion</title>
      <link>https://blog.koehntopp.info/2005/10/08/bin-bash-brace-expansion.html</link>
      <pubDate>Sat, 08 Oct 2005 08:43:57 +0000</pubDate><author>kris-blog@koehntopp.de (Kristian Köhntopp)</author>

      <guid>https://blog.koehntopp.info/2005/10/08/bin-bash-brace-expansion.html</guid>
      <description>&lt;p&gt;Eine Unix-Kommandoshell nimmt die Benutzereingabe und unterteilt sie in Worte.
Das erste Wort einer Zeile ist ein Kommando, der Rest sind die Parameter des Kommandos.
So weit so langweilig.&lt;/p&gt;
&lt;p&gt;Interessant wird die Sache, weil eine Unix Shell gut mit Worten umgehen kann.
So kann sie Worte ersetzen und dabei auch neue Worte generieren.
Dies nennt man Expansion, und die Bash hat sehr viele Expansion-Mechanismen:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;brace expansion,&lt;/li&gt;
&lt;li&gt;tilde expansion,&lt;/li&gt;
&lt;li&gt;parameter expansion,&lt;/li&gt;
&lt;li&gt;variable expansion,&lt;/li&gt;
&lt;li&gt;arithmetic expansion,&lt;/li&gt;
&lt;li&gt;command substitution,&lt;/li&gt;
&lt;li&gt;word splitting und&lt;/li&gt;
&lt;li&gt;pathname expansion, sowie&lt;/li&gt;
&lt;li&gt;process substitution&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;werden in dieser Reihenfolge auf den Worten einer Zeile durchgeführt.
Nicht alle diese Mechanismen sind in einer klassischen &lt;code&gt;#!/bin/sh&lt;/code&gt; enthalten.&lt;/p&gt;
&lt;p&gt;Wenn man schnell mal ein paar Pfadnamen braucht, ist
&lt;a href=&#34;http://ebergen.net/wordpress/?p=80&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Bash Brace Expansion&lt;/a&gt;


echt nützlich.
Die Grundidee ist diese:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;kris@valiant:~&amp;gt; echo a{b,c,d}e
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;abe ace ade
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Das kann man benutzen, um ähnliche Dinge aufzuzählen, ohne mehr schreiben zu müssen:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;kris@valiant:~/Source/tidy/src&amp;gt;ls parser.{c,h,o,lo}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;parser.c  parser.h  parser.lo  parser.o
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Dabei ist es durchaus erlaubt, einen Teilausdruck leer zu lassen:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;kris@h3118:/etc/httpd&amp;gt; ls -1 httpd.conf{,.old}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;httpd.conf
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;httpd.conf.old
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Aber Brace Expansion kann noch mehr: Bestandteil des Konzeptes sind auch Ranges.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;kris@valiant:~&amp;gt; mkdir x; for i in {0..10}; do mkdir x/$i; done; ls x
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;0  1  10  2  3  4  5  6  7  8  9
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;kris@valiant:~&amp;gt; mkdir y; for i in {a..z}; do mkdir y/$i; done; ls y
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Da die Erweiterung reihenfolgetreu ist, ist es sehr leicht, zum Beispiel alte Logfiles zu rotieren. Das geht dann so:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;kris@valiant:~/x&amp;gt; touch a.log
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;kris@valiant:~/x&amp;gt; for i in {9..0}; do olog=a.log.$i; nlog=a.log.$(( $i+1 )); [ -f $olog ] &amp;amp;&amp;amp; mv $olog $nlog; done; mv a.log a.log.0; touch a.log; ls
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;a.log  a.log.0
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;kris@valiant:~/x&amp;gt; for i in {9..0}; do olog=a.log.$i; nlog=a.log.$(( $i+1 )); [ -f $olog ] &amp;amp;&amp;amp; mv $olog $nlog; done; mv a.log a.log.0; touch a.log; ls
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;go&#34;&gt;a.log  a.log.0  a.log.1
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Das letzte Beispiel verwendet eine weitere Bash-Expansion, Arithmethic Expansion.
Hier wird ein Ausdruck, der in &lt;code&gt;$(( ... ))&lt;/code&gt; steht, ausgerechnet und durch das Rechenergebnis ersetzt.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
