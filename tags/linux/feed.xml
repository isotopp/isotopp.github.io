<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>linux on Die wunderbare Welt von Isotopp</title>
    <link>https://blog.koehntopp.info/tags/linux.html</link>
    <description>Recent content in linux on Die wunderbare Welt von Isotopp</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 23 Nov 2021 12:43:52 +0000</lastBuildDate><atom:link href="https://blog.koehntopp.info/tags/linux/feed.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>fork, exec, wait and exit</title>
      <link>https://blog.koehntopp.info/2020/12/28/fork-exec-wait-and-exit.html</link>
      <pubDate>Mon, 28 Dec 2020 18:25:00 +0000</pubDate>
      
      <guid>https://blog.koehntopp.info/2020/12/28/fork-exec-wait-and-exit.html</guid>
      <description>&lt;p&gt;This is the &lt;a href=&#34;https://blog.koehntopp.info/2007/01/07/fork-exec-wait-und-exit.html&#34;&gt;english version of a 2007 article&lt;/a&gt;

.&lt;/p&gt;
&lt;p&gt;In &lt;a href=&#34;news:de.comp.os.unix.linux.misc&#34;&gt;de.comp.os.unix.linux.misc&lt;/a&gt;

 somebody asked:&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Are commands in a script executed strictly sequentially, that is,
will the next command only be executed when the previous command has
completed, or will the shell &lt;strong&gt;automatically&lt;/strong&gt; start the next command
if the system has spare capacity?&lt;/li&gt;
&lt;li&gt;Can I change the default behavior - whatever it may be - in any way?&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;If you are looking into the fine manual, it may explain at some point that the shell starts each command in a separate process. Then you may continue your thought process and ask what that actually means. As soon as you get to this stage, you may want to have a look at the Unix process lifecycle.&lt;/p&gt;
&lt;h2 id=&#34;processes-and-programs&#34;&gt;
    &lt;a href=&#34;#processes-and-programs&#34;&gt;
	Processes and programs
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;A program in Unix is a sequence of executable instructions on a disk. You can use the command &lt;em&gt;size&lt;/em&gt; to get a very cursory check of the structure and memory demands of the program, or use the various invocations of &lt;em&gt;objdump&lt;/em&gt; for a much more detailed view. The only aspect that is of interest to us is the fact that a program is a sequence of instructions and data (on disk) that may potentially be executed at some point in time, maybe even multiple times, maybe even concurrently.&lt;/p&gt;
&lt;p&gt;Such a program in execution is called a process. The process contains the code and initial data of the program itself, and the actual state at the current point in time for the current execution. That is the memory map and the associated memory (check /proc/&lt;em&gt;pid&lt;/em&gt;/maps), but also the program counter, the processor registers, the stack, and finally the current root directory, the current directory, environment variables and the open files, plus a few other things (in modern Linux for example, we find the processes cgroups and namespace relationships, and so on - things became a lot more complicated since 1979).&lt;/p&gt;
&lt;p&gt;In Unix processes and programs are two different and independent things. You can run a program more than once, concurrently. For example, you can run two instances of the &lt;em&gt;vi&lt;/em&gt; editor, which edit two different texts. Program and initial data are the same: it is the same editor. But the state inside the processes is different: the text, the insert mode, cursor position and so on differ. From a programmers point of view, &amp;ldquo;the code is the same, but the variable values are differing&amp;rdquo;.&lt;/p&gt;
&lt;p&gt;A process can run more than one program: The currently running program is throwing itself away, but asks that the operating system loads a different program into the same process. The new program will inherit some reused process state, such as current directories, file handles, privileges and so on.&lt;/p&gt;
&lt;p&gt;All of that is done in original Unix, at the system level, with only four syscalls:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;fork()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;exec()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;wait()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;exit()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;usermode-and-kernel&#34;&gt;
    &lt;a href=&#34;#usermode-and-kernel&#34;&gt;
	Usermode and Kernel
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/prozesswechsel.png&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;

&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Context switching: Process 1 is running for a bit, but at (1) the kernel interrupts the execution and switches to process 2. Some time later, process 2 is frozen, and we context switch back to where we left off with (1), and so on. For each process, this seems to be seamless, but it happens in intervals that are not continous.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Whenever a Unix process does a system call (and at some other opportunities) the current process leaves the user context and the operating system code is being activated. This is privileged kernel code, and the activation is not quite a subroutine call, because not only is privileged mode activated, but also a kernel stack is being used and the CPU registers of the user process are saved.&lt;/p&gt;
&lt;p&gt;From the point of view of the kernel function, the user process that has called us is inert data and can be manipulated at will.&lt;/p&gt;
&lt;p&gt;The kernel will then execute the system call on behalf of the user program, and then will try to exit the kernel. The typical way to leave the kernel is through the scheduler.&lt;/p&gt;
&lt;p&gt;The scheduler will review the process list and current situation. It will then decide into which of all the different userland processes to exit. It will restore the chosen processes registers, then return into this processes context, using this processes stack. The chosen process may or may not be the one that made the system call.&lt;/p&gt;
&lt;p&gt;In short: Whenever you make a system call, you may (or may not) lose the CPU to another process.&lt;/p&gt;
&lt;p&gt;That&amp;rsquo;s not too bad, because this other process at some point has to give up the CPU and the kernel will then return into our process as if nothing happened.&lt;/p&gt;
&lt;p&gt;Our program is not being executed linearly, but in a sequence of subjectively linear segments, with breaks inbetween. During these breaks the CPU is working on segments of other processes that are also runnable.&lt;/p&gt;
&lt;h2 id=&#34;fork-and-exit&#34;&gt;
    &lt;a href=&#34;#fork-and-exit&#34;&gt;
	fork() and exit()
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;In traditional Unix the only way to create a process is using the &lt;code&gt;fork()&lt;/code&gt; system call. The new process gets a copy of the current program, but new process id (pid). The process id of the parent process (the process that called &lt;code&gt;fork()&lt;/code&gt;) is registered as the new processes parent pid (ppid) to build a process tree.&lt;/p&gt;
&lt;p&gt;In the parent process, &lt;code&gt;fork()&lt;/code&gt; returns and delivers the new processes pid as a result.&lt;/p&gt;
&lt;p&gt;The new process also returns from the &lt;code&gt;fork()&lt;/code&gt; system call (because that is when the copy was made), but the result of the &lt;code&gt;fork()&lt;/code&gt; is 0.&lt;/p&gt;
&lt;p&gt;So &lt;code&gt;fork()&lt;/code&gt; is a special system call. You call it once, but the function returns twice: Once in the parent, and once in the child process. &lt;code&gt;fork()&lt;/code&gt; increases the number of processes in the system by one.&lt;/p&gt;
&lt;p&gt;Every Unix process always starts their existence by returning from a &lt;code&gt;fork()&lt;/code&gt; system call with a 0 result, running the same program as the parent process. They can have different fates because the result of the &lt;code&gt;fork()&lt;/code&gt; system call is different in the parent and child incarnation, and that can drive execution down different &lt;code&gt;if()&lt;/code&gt; branches.&lt;/p&gt;
&lt;p&gt;In Code:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;pid_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

        &lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fork&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
                &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;I am the child.&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
                &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;I am the parent, the child is %d.&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
                &lt;span class=&#34;n&#34;&gt;perror&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;In fork():&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

        &lt;span class=&#34;n&#34;&gt;exit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Running this, we get:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;go&#34;&gt;kris@linux:/tmp/kris&amp;gt; make probe1
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;cc     probe1.c   -o probe1
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;kris@linux:/tmp/kris&amp;gt; ./probe1
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;I am the child.
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;I am the parent, the child is 16959.
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;We are defining a variable &lt;code&gt;pid&lt;/code&gt; of the type &lt;code&gt;pid_t&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This variable saves the &lt;code&gt;fork()&lt;/code&gt; result, and using it we activate one (&amp;ldquo;I am the child.&amp;quot;) or the other (&amp;ldquo;I am the parent&amp;rdquo;) branch of an if().&lt;/p&gt;
&lt;p&gt;Running the program we get two result lines. Since we have only one variable, and this variable can have only one state, an instance of the program can only be in either one or the other branch of the code. Since we see two lines of output, two instances of the program with different values for &lt;code&gt;pid&lt;/code&gt; must have been running.&lt;/p&gt;
&lt;p&gt;If we called &lt;code&gt;getpid()&lt;/code&gt; and printed the result we could prove this by showing two different pids (change the program to do this as an exercise!).&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;fork()&lt;/code&gt; system call is entered once, but left twice, and increments the number of processes in the system by one. After finishing our program the number of processes in the system is as large as before. That means there must be another system call which decrements the number of system calls.&lt;/p&gt;
&lt;p&gt;This system call is &lt;code&gt;exit()&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;exit()&lt;/code&gt; is a system call you enter once and never leave. It decrements the number of processes in the system by one.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;exit()&lt;/code&gt; also accepts an exit status as a parameter, which the parent process can receive (or even has to receive), and which communicates the fate of the child to the parent.&lt;/p&gt;
&lt;p&gt;In our example, all variants of the program call &lt;code&gt;exit()&lt;/code&gt; - we are calling &lt;code&gt;exit()&lt;/code&gt; in the child process, but also in the parent process. That means we terminate two processes. We can only do this, because even the parent process is a child, and in fact, a child of our shell.&lt;/p&gt;
&lt;p&gt;The shell does exactly the same thing we are doing:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;go&#34;&gt;bash (16957) --- calls fork() ---&amp;gt; bash (16958) --- becomes ---&amp;gt; probe1 (16958)
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;probe1 (16958) --- calls fork() ---&amp;gt; probe1 (16959) --&amp;gt; exit()
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;   |
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;   +---&amp;gt; exit()
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;exit()&lt;/code&gt; closes all files and sockets, frees all memory and then terminates the process. The parameter of &lt;code&gt;exit()&lt;/code&gt; is the only thing that survives and is handed over to the parent process.&lt;/p&gt;
&lt;h2 id=&#34;wait&#34;&gt;
    &lt;a href=&#34;#wait&#34;&gt;
	wait()
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Our child process ends with an &lt;code&gt;exit(0)&lt;/code&gt;. The 0 is the exit status of our program and can be shipped. We need to make the parent process pick up this value and we need a new system call for this.&lt;/p&gt;
&lt;p&gt;This system call is &lt;code&gt;wait()&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;In Code:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;
&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;sys/types.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;sys/wait.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;pid_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
        &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;   &lt;span class=&#34;n&#34;&gt;status&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

        &lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fork&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
                &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;I am the child.&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
                &lt;span class=&#34;n&#34;&gt;sleep&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
                &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;I am the child, 10 seconds later.&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
                &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;I am the parent, the child is %d.&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
                &lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;wait&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;status&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
                &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;End of process %d: &amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
                &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;WIFEXITED&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;status&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
                        &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;The process ended with exit(%d).&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;WEXITSTATUS&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;status&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
                &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
                &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;WIFSIGNALED&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;status&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
                        &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;The process ended with kill -%d.&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;WTERMSIG&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;status&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
                &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
                &lt;span class=&#34;n&#34;&gt;perror&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;In fork():&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

        &lt;span class=&#34;n&#34;&gt;exit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;And the runtime protocol:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;go&#34;&gt;kris@linux:/tmp/kris&amp;gt; make probe2
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;cc     probe2.c   -o probe2
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;kris@linux:/tmp/kris&amp;gt; ./probe2
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;I am the child.
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;I am the parent, the child is 17399.
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;I am the child, 10 seconds later.
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;End of process 17399: The process ended with exit(0).
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The variable &lt;code&gt;status&lt;/code&gt; is passed to the system call &lt;code&gt;wait()&lt;/code&gt; as a reference parameter, and will be overwritten by it. The value is a bitfield, containing the exit status and additional reasons explaining how the program ended. To decode this, C offers a number of macros with predicates such as &lt;code&gt;WIFEXITED()&lt;/code&gt; or &lt;code&gt;WIFSIGNALED()&lt;/code&gt;. We also get extractors, such as &lt;code&gt;WEXITSTATUS()&lt;/code&gt; and &lt;code&gt;WTERMSIG()&lt;/code&gt;. &lt;code&gt;wait()&lt;/code&gt; also returns the pid of the process that terminated, as a function result.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;wait()&lt;/code&gt; stops execution of the parent process until either a signal arrives or a child process terminates. You can arrange for a SIGALARM to be sent to you in order to time bound the &lt;code&gt;wait()&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&#34;the-init-program-and-zombies&#34;&gt;
    &lt;a href=&#34;#the-init-program-and-zombies&#34;&gt;
	The &lt;code&gt;init&lt;/code&gt; program, and Zombies
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;The program &lt;code&gt;init&lt;/code&gt; with the pid 1 will do basically nothing but calling &lt;code&gt;wait()&lt;/code&gt;: It waits for terminating processes and polls their exit status, only to throw it away. It also reads &lt;code&gt;/etc/inittab&lt;/code&gt; and starts the programs configured there. When something from &lt;code&gt;inittab&lt;/code&gt; terminates and is set to &lt;code&gt;respawn&lt;/code&gt;, it will be restarted by &lt;code&gt;init&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;When a child process terminates while the parent process is not (yet) waiting for the exit status, &lt;code&gt;exit()&lt;/code&gt; will still free all memory, file handles and so on, but the &lt;code&gt;struct task&lt;/code&gt; (basically the &lt;code&gt;ps&lt;/code&gt; entry) cannot be thrown away. It may be that the parent process at some point in time arrives at a &lt;code&gt;wait()&lt;/code&gt; and then we have to have the exit status, which is stored in a field in the &lt;code&gt;struct task&lt;/code&gt;, so we need to retain it.&lt;/p&gt;
&lt;p&gt;And while the child process is dead already, the process list entry cannot die because the exit status has not yet been polled by the parent. Unix calls such processes without memory or other resouces associated &lt;em&gt;Zombies&lt;/em&gt;. Zombies are visible in the process list when a process generator (a forking process) is faulty and does not &lt;code&gt;wait()&lt;/code&gt; properly. They do not take up memory or any other resouces but the bytes that make up their &lt;code&gt;struct task&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The other case can happen, too: The parent process exits while the child moves on. The kernel will set the ppid of such children with dead parents to the constant value 1, or in other words: &lt;code&gt;init&lt;/code&gt; inherits orphaned processes.&lt;/p&gt;
&lt;p&gt;When the child terminates, &lt;code&gt;init&lt;/code&gt; will &lt;code&gt;wait()&lt;/code&gt; for the exit status of the child, because that&amp;rsquo;s what &lt;code&gt;init&lt;/code&gt; does. No Zombies in this case.&lt;/p&gt;
&lt;p&gt;When we observe the number of processes in the system to be largely constant over time, then the number of calls to &lt;code&gt;fork()&lt;/code&gt;, &lt;code&gt;exit()&lt;/code&gt; and &lt;code&gt;wait()&lt;/code&gt; have to balanced. This is, because for each &lt;code&gt;fork()&lt;/code&gt; there will be an &lt;code&gt;exit()&lt;/code&gt; to match and for each &lt;code&gt;exit()&lt;/code&gt; there must be a &lt;code&gt;wait()&lt;/code&gt; somewhere.&lt;/p&gt;
&lt;p&gt;In reality, and in modern systems, the situation is a bit more complicated, but the original idea is as simple as this. We have a clean fork-exit-wait triangle that describes all processes.&lt;/p&gt;
&lt;h2 id=&#34;exec&#34;&gt;
    &lt;a href=&#34;#exec&#34;&gt;
	exec()
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;So while &lt;code&gt;fork()&lt;/code&gt; makes processes, &lt;code&gt;exec()&lt;/code&gt; loads programs into processes that already exist.&lt;/p&gt;
&lt;p&gt;In Code:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;
&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;sys/types.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;sys/wait.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;pid_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
        &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;   &lt;span class=&#34;n&#34;&gt;status&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

        &lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fork&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
                &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;I am the child.&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
                &lt;span class=&#34;n&#34;&gt;execl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;/bin/ls&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;ls&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;-l&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;/tmp/kris&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
                &lt;span class=&#34;n&#34;&gt;perror&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;In exec(): &amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
                &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;I am the parent, and the child is %d.&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
                &lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;wait&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;status&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
                &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;End of process %d: &amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
                &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;WIFEXITED&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;status&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
                        &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;The process ended with exit(%d).&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;WEXITSTATUS&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;status&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
                &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
                &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;WIFSIGNALED&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;status&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
                        &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;The process ended with kill -%d.&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;WTERMSIG&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;status&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
                &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
                &lt;span class=&#34;n&#34;&gt;perror&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;In fork():&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

        &lt;span class=&#34;n&#34;&gt;exit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The runtime protocol:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;go&#34;&gt;kris@linux:/tmp/kris&amp;gt; make probe3
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;cc     probe3.c   -o probe3
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;kris@linux:/tmp/kris&amp;gt; ./probe3
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;I am the child.
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;I am the parent, the child is 17690.
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;total 36
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;-rwxr-xr-x 1 kris users 6984 2007-01-05 13:29 probe1
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;-rw-r--r-- 1 kris users  303 2007-01-05 13:36 probe1.c
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;-rwxr-xr-x 1 kris users 7489 2007-01-05 13:37 probe2
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;-rw-r--r-- 1 kris users  719 2007-01-05 13:40 probe2.c
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;-rwxr-xr-x 1 kris users 7513 2007-01-05 13:42 probe3
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;-rw-r--r-- 1 kris users  728 2007-01-05 13:42 probe3.c
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;End of process 17690: The process ended with exit(0).
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Here the code of &lt;code&gt;probe3&lt;/code&gt; is thrown away in the child process (the &lt;code&gt;perror(&amp;quot;In exec():&amp;quot;)&lt;/code&gt; is not reached). Instead the running program is being replaced by the given call to &lt;code&gt;ls&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;From the protocol we can see the parent instance of &lt;code&gt;probe3&lt;/code&gt; waits for the &lt;code&gt;exit()&lt;/code&gt;. Since the &lt;code&gt;perror()&lt;/code&gt; after the &lt;code&gt;execl()&lt;/code&gt;is never executed, it cannot be an &lt;code&gt;exit()&lt;/code&gt; in our code. In fact, &lt;code&gt;ls&lt;/code&gt; ends the process we made with an &lt;code&gt;exit()&lt;/code&gt; and that is what we receive our exit status from in our parent processes &lt;code&gt;wait()&lt;/code&gt; call.&lt;/p&gt;
&lt;h2 id=&#34;the-same-as-a-shellscript&#34;&gt;
    &lt;a href=&#34;#the-same-as-a-shellscript&#34;&gt;
	The same, as a Shellscript
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;The examples above have been written in C. We can do the same, in &lt;code&gt;bash&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;go&#34;&gt;kris@linux:/tmp/kris&amp;gt; cat probe1.sh
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;&lt;/span&gt;&lt;span class=&#34;gp&#34;&gt;#&lt;/span&gt;! /bin/bash --
&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;echo &amp;#34;Starting child:&amp;#34;
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;sleep 10 &amp;amp;
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;echo &amp;#34;The child is $!&amp;#34;
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;echo &amp;#34;The parent is $$&amp;#34;
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;echo &amp;#34;$(date): Parent waits.&amp;#34;
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;wait
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;echo &amp;#34;The child $! has the exit status $?&amp;#34;
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;echo &amp;#34;$(date): Parent woke up.&amp;#34;
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;kris@linux:/tmp/kris&amp;gt; ./probe1.sh
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;Starting child:
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;The child is 18071
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;The parent is 18070
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;Fri Jan  5 13:49:56 CET 2007: Parent waits.
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;The child 18071 has the exit status 0
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;Fri Jan  5 13:50:06 CET 2007: Parent woke up.
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;the-actual-bash&#34;&gt;
    &lt;a href=&#34;#the-actual-bash&#34;&gt;
	The actual bash
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;We can also trace the shell while it executes a single command. The information from above should allow us to understand what goes on, and see how the shell actually works.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;go&#34;&gt;kris@linux:~&amp;gt; strace -f -e execve,clone,fork,waitpid bash
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;kris@linux:~&amp;gt; ls
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;clone(Process 30048 attached
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD,
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;child_tidptr=0xb7dab6f8) = 30048
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;[pid 30025] waitpid(-1, Process 30025 suspended
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt; &amp;lt;unfinished ...&amp;gt;
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;[pid 30048] execve(&amp;#34;/bin/ls&amp;#34;, [&amp;#34;/bin/ls&amp;#34;, &amp;#34;-N&amp;#34;, &amp;#34;--color=tty&amp;#34;, &amp;#34;-T&amp;#34;, &amp;#34;0&amp;#34;],
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;[/* 107 vars */]) = 0
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;...
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;Process 30025 resumed
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;Process 30048 detached
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;&amp;lt;... waitpid resumed&amp;gt; [{WIFEXITED(s) &amp;amp;&amp;amp; WEXITSTATUS(s) == 0}], WSTOPPED
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;WCONTINUED) = 30048
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;--- SIGCHLD (Child exited) @ 0 (0) ---
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;...
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Linux uses a generalization of the original Unix &lt;code&gt;fork()&lt;/code&gt;, named &lt;code&gt;clone()&lt;/code&gt;, to create child processes. That is why we do not see &lt;code&gt;fork()&lt;/code&gt; in a Linux system to create a child process, but a &lt;code&gt;clone()&lt;/code&gt; call with some parameters.&lt;/p&gt;
&lt;p&gt;Linux also uses a specialized variant of &lt;code&gt;wait()&lt;/code&gt;, called &lt;code&gt;waitpid()&lt;/code&gt;, to wait for a specific pid.&lt;/p&gt;
&lt;p&gt;Linux finally uses the &lt;code&gt;exec()&lt;/code&gt; variant &lt;code&gt;execve()&lt;/code&gt; to load programs, but that is just shuffling the paramters around. At the end of &lt;code&gt;ls&lt;/code&gt; (PID 30048) the process 30025 will wake up from the &lt;code&gt;wait()&lt;/code&gt; and continue.&lt;/p&gt;
&lt;h2 id=&#34;original-code-what-windows-does-and-what-microsoft-thinks-about-linux&#34;&gt;
    &lt;a href=&#34;#original-code-what-windows-does-and-what-microsoft-thinks-about-linux&#34;&gt;
	Original Code, what Windows does, and what Microsoft thinks about Linux
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;This text is based on &lt;a href=&#34;http://groups.google.com/group/de.comp.os.unix.linux.misc/msg/4035c67415f9bc09&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;a USENET article&lt;/a&gt;

 I wrote a long time ago.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://minnie.tuhs.org/cgi-bin/utree.pl?file=V7/usr/src/cmd/sh/xec.c&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Here&lt;/a&gt;

 is the original C-code of the original &lt;code&gt;sh&lt;/code&gt; from 1979, with the &lt;code&gt;fork()&lt;/code&gt; system call. Search for &lt;code&gt;case TFORK:&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Also, check out the programming style of Mr. Bourne - this is C, even if it does not look like it.&lt;/p&gt;
&lt;p&gt;The &lt;a href=&#34;https://blog.koehntopp.info/2007/01/07/fork-exec-wait-und-exit.html&#34;&gt;original 2007 blog article&lt;/a&gt;

, has a followup article &lt;a href=&#34;https://blog.koehntopp.info/2007/01/07/fork-und-exec-vs-createprocess.html&#34;&gt;on Windows CreateProcess()&lt;/a&gt;

, which has not been translated.&lt;/p&gt;
&lt;p&gt;When implementing &lt;code&gt;fork()&lt;/code&gt; in Windows as part of the WSL 1, Microsoft ran into a lot of problems with the syscall, and wrote an article about how they hate it, and why they think their &lt;code&gt;CreateProcessEx()&lt;/code&gt; (in Unix: &lt;code&gt;spawn()&lt;/code&gt;) would be better. The &lt;a href=&#34;https://www.microsoft.com/en-us/research/uploads/prod/2019/04/fork-hotos19.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;PDF&lt;/a&gt;

 makes a number of good points, but is still wrong. :-)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>But is it atomic?</title>
      <link>https://blog.koehntopp.info/2018/11/29/but-is-it-atomic.html</link>
      <pubDate>Thu, 29 Nov 2018 15:38:05 +0000</pubDate>
      
      <guid>https://blog.koehntopp.info/2018/11/29/but-is-it-atomic.html</guid>
      <description>&lt;p&gt;From &lt;a href=&#34;https://pluspora.com/posts/310948&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Pluspora&lt;/a&gt;

&lt;/p&gt;
&lt;h2 id=&#34;but-is-it-atomic&#34;&gt;
    &lt;a href=&#34;#but-is-it-atomic&#34;&gt;
	But is it atomic?
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;So a few days ago, a colleague asked “Why do we love files on disk?” and in the course of that discussion, I made a comment that, among other things, used the assumption that somebody is updating some file on some Linux system atomically. I wrote:&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s assume we are using local files, and we do so in a managed, sane way:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;All these state files are always JSON,&lt;/li&gt;
&lt;li&gt;there is a JSON schema, so
&lt;ul&gt;
&lt;li&gt;it is clear which attributes can be there,&lt;/li&gt;
&lt;li&gt;must be there, and&lt;/li&gt;
&lt;li&gt;what they mean and&lt;/li&gt;
&lt;li&gt;what changes to data mean as well.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Files are updated atomically&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;And immediately the question came up: “I either misunderstand you or I have a gap in the knowledge. When writes to a file became atomic? They are not in general case.”&lt;/p&gt;
&lt;p&gt;There is &lt;a href=&#34;https://dilbert.com/strip/1995-06-24&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;a Dilbert for that&lt;/a&gt;

.&lt;/p&gt;
&lt;p&gt;So let’s go back in time, it’s &lt;a href=&#34;http://silvertonconsulting.com/gbos2/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Greybeards time&lt;/a&gt;

! We’re going to find out where the things you are working with are actually coming from. With sources and references.&lt;/p&gt;
&lt;h2 id=&#34;the-write2-system-call&#34;&gt;
    &lt;a href=&#34;#the-write2-system-call&#34;&gt;
	The write(2) system call
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;A write(2) system call is atomic. The size or amount of data written does not matter. How come?&lt;/p&gt;
&lt;p&gt;The system call will, before trying to write data to disk, lock the in-memory inode. That is, it will effectively lock the entire file. It then performs the file changes, and only then unlocks. That can take a long, long, long time, depending on the amount of data and the media the file is being stored on.&lt;/p&gt;
&lt;p&gt;It means that on a single physical file in Unix there can be only one write(2) or read(2) system call active at any point in time.&lt;/p&gt;
&lt;p&gt;One exception to this is XFS, but only when a file is opened with O_DIRECT. In this special case, XFS instead locks the byte range in a structure attached to the inode, performs the write and then unlocks. So, in XFS with O_DIRECT, any number of concurrent, non-overlapping write(2) system calls can be active.&lt;/p&gt;
&lt;p&gt;The Posix specification requires that write(2) is atomic, it does not require that only one write per file can happen.&lt;/p&gt;
&lt;h2 id=&#34;that-is-a-horrible-thing&#34;&gt;
    &lt;a href=&#34;#that-is-a-horrible-thing&#34;&gt;
	That is a horrible thing!
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;The locking behavior of write(2) (and read(2)) is a problem for databases that require many concurrent writes to happen.&lt;/p&gt;
&lt;p&gt;Ingres and some other early SQL databases used to solve that problem by avoiding filesystem entirely, they recommended that tablespaces use raw disks. No filesystem, no files, no locks.&lt;/p&gt;
&lt;p&gt;Oracle solved the problem by introducing the concept of tablespaces, which are data storage spaces made up by a fleet of files, e.g. one file for each GB of data storage. Tables are assigned tablespaces, not data files directly. Since there is one write lock per inode, concurrent writes to different files in the same tablespace can happen.&lt;/p&gt;
&lt;p&gt;Only in 1994, when SGI published XFS, the actual problem was tackled by splitting the lock at the kernel level for buffer cache less writes. XFS also contained many other improvements over the 1984 BSD Fast Filing System that made it superior for concurrent I/O, streaming I/O, very large file systems, and many other modern use-cases. BSD FFS was in turn an improvement over 1974’s original Unix Filesystem.&lt;/p&gt;
&lt;p&gt;In Linux terms, the 1974 Unix Filesystem is mirrored by the Minix File system, the 1984 BSD FFS is roughly equivalent to ext2, and XFS was donated and ported to Linux by SGI, bringing that up into the tech level of 1994.&lt;/p&gt;
&lt;p&gt;Sun ZFS and Linux Btrfs are from 2004, and are a complete deviation from earlier Unix ideas. They are a different, much longer writeup, which will actually end with the git and the Blockchain.&lt;/p&gt;
&lt;h2 id=&#34;source-dive-why-are-writes-atomic&#34;&gt;
    &lt;a href=&#34;#source-dive-why-are-writes-atomic&#34;&gt;
	Source Dive: Why are writes atomic?
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;“Posix requiring a file write to be atomic” comes from the behavior of the original Version 7 Unix and later systems. In there, we find the &lt;a href=&#34;https://github.com/dspinellis/unix-history-repo/blob/Research-V7-Snapshot-Development/usr/sys/sys/sys2.c#L20&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;write(2)&lt;/a&gt;

 system call, which just calls the &lt;a href=&#34;https://github.com/dspinellis/unix-history-repo/blob/Research-V7-Snapshot-Development/usr/sys/sys/sys2.c#L30&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;rdwr()&lt;/code&gt;&lt;/a&gt;

 function.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/*
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * write system call 
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; */&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;write&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; 
  &lt;span class=&#34;n&#34;&gt;rdwr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;FWRITE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;You are looking very old K&amp;amp;R style C code here, which predates even ANSI-C and function prototypes, by the way.&lt;/p&gt;
&lt;p&gt;So &lt;code&gt;rdwr()&lt;/code&gt; a few lines down the function calls &lt;code&gt;plock()&lt;/code&gt;, for as long as we are not dealing with a device special file (Here is where the Ingres “use raw devices” idea comes into play), then does the I/O and finally calls prele().&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;((&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ip&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i_mode&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;IFCHR&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;IFBLK&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
			&lt;span class=&#34;n&#34;&gt;plock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ip&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mode&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;FREAD&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
			&lt;span class=&#34;n&#34;&gt;readi&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ip&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;else&lt;/span&gt;
			&lt;span class=&#34;nf&#34;&gt;writei&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ip&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;((&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ip&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i_mode&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;IFCHR&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;IFBLK&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
			&lt;span class=&#34;n&#34;&gt;prele&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ip&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;plock()&lt;/code&gt; is what locks the actual inode and the origin of the observed behavior. It is is a misnomer, it’s not a pipe lock, it’s an inode lock.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/*
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * Lock a pipe.
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * If its already locked,
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * set the WANT bit and sleep.
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; */&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;plock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ip&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;register&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;inode&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ip&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;while&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ip&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i_flag&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ILOCK&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;ip&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i_flag&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;|=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;IWANT&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;sleep&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;((&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;caddr_t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ip&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;PINOD&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;n&#34;&gt;ip&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i_flag&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;|=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ILOCK&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;See the locking loop here: As as we do not have the lock, indicate desire to get the lock, then sleep on a lock release. When we exit the loop (because the inode is unlocked), lock the inode.&lt;/p&gt;
&lt;p&gt;These are simple C Code lines, not special magic macros that translate into special magic TAS machine instructions. That is because the code here is so old that it comes from a world where we have single-die, single-core, single-thread CPUs. If your code is actually running (and this is kernel code!), then you are alone in the entire system. There is nobody else touching these variables as long as you have the CPU.&lt;/p&gt;
&lt;p&gt;Under the lock, &lt;code&gt;rdwr()&lt;/code&gt; above calls &lt;code&gt;writei()&lt;/code&gt;. And &lt;code&gt;writei()&lt;/code&gt; has a do loop which uses variables from the u-Area.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;	&lt;span class=&#34;k&#34;&gt;do&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;bn&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;u_offset&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;BSHIFT&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;on&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;u_offset&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;BMASK&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;min&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;((&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;BSIZE&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;on&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;u_count&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;IFBLK&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;IFMPB&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
			&lt;span class=&#34;n&#34;&gt;bn&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bmap&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ip&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bn&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;B_WRITE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
			&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;((&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bn&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
				&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
			&lt;span class=&#34;n&#34;&gt;dev&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ip&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i_dev&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;BSIZE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; 
			&lt;span class=&#34;n&#34;&gt;bp&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;getblk&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;dev&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bn&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;else&lt;/span&gt;
			&lt;span class=&#34;n&#34;&gt;bp&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bread&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;dev&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bn&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;iomove&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bp&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;b_un&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;b_addr&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;on&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;B_WRITE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;u_error&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
			&lt;span class=&#34;n&#34;&gt;brelse&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;else&lt;/span&gt;
			&lt;span class=&#34;nf&#34;&gt;bdwrite&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;u_offset&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ip&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i_size&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt;
		   &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;==&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;IFDIR&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;||&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;==&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;IFREG&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
			&lt;span class=&#34;n&#34;&gt;ip&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i_size&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;u_offset&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;ip&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i_flag&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;|=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;IUPD&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ICHG&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;u_error&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;==&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;u&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;u_count&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The u-Area of a process at that time was a common data structure that the userland and the kernel used to communicate. Here it is being used to shift syscall parameters into the kernel. The write writes the data at &lt;code&gt;u.u_base&lt;/code&gt; in userland into the current inode, at &lt;code&gt;u.u_offset&lt;/code&gt; bytes in the file. There are &lt;code&gt;u.u_count&lt;/code&gt; many bytes to write.&lt;/p&gt;
&lt;p&gt;We convert the &lt;code&gt;u.u_offset&lt;/code&gt; into a logical block number (the n-th block of a file), and an offset &lt;code&gt;on&lt;/code&gt; within the block. We need to call &lt;code&gt;bmap()&lt;/code&gt;. This function turns an inode number and block number within the file into a physical block number on a device.&lt;/p&gt;
&lt;p&gt;We can then bring the relevant physical block into the buffer cache, using &lt;code&gt;bread()&lt;/code&gt;, and then use &lt;code&gt;iomove()&lt;/code&gt; to modify and dirty the block. As we &lt;code&gt;brelse()&lt;/code&gt; it, it will eventually be written back to disk later.&lt;/p&gt;
&lt;p&gt;There is an optimization here:&lt;/p&gt;
&lt;p&gt;When the write is a full block, we do not read the block from disk. We just allocate a buffer using &lt;code&gt;getblk()&lt;/code&gt;, and fill it. It will overwrite the data on disk completely, there is no old and new data to merge. Disk accesses are slow, in the 1970ies even more so than today, so not reading data that you are going to obliterate completely pays off substantially.&lt;/p&gt;
&lt;p&gt;The loop continues as long as there are no errors and still blocks to write.&lt;/p&gt;
&lt;p&gt;As we return from &lt;code&gt;writei()&lt;/code&gt;, &lt;code&gt;rdrw()&lt;/code&gt; resumes and will eventually &lt;code&gt;prele()&lt;/code&gt; the inode lock.&lt;/p&gt;
&lt;h2 id=&#34;how-old-is-this-stuff&#34;&gt;
    &lt;a href=&#34;#how-old-is-this-stuff&#34;&gt;
	How old is this stuff?
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;This is of course extremely old code, original V7 unix, almost as old as me: git blames places its age at 41 years. I was in the third class of a German basic school when this was written.&lt;/p&gt;
&lt;p&gt;I chose this implementation, because it is very simple, and because it is also what became immortalised in the performance destroying standard which we got to know as Posix File System Semantics.&lt;/p&gt;
&lt;h2 id=&#34;homework&#34;&gt;
    &lt;a href=&#34;#homework&#34;&gt;
	Homework
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;You can have fun to find the matching functionality in a &lt;a href=&#34;https://github.com/torvalds/linux&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;modern Linux kernel&lt;/a&gt;

, threads, multicore, capabilities, namespaces, cgroups and dynamic data structures and all.&lt;/p&gt;
&lt;p&gt;Compare code readability and complexity. Discuss. Is this progress? Why do you think so?&lt;/p&gt;
&lt;p&gt;You can try to get a &lt;a href=&#34;http://160592857366.free.fr/joe/ebooks/ShareData/Design%20of%20the%20Unix%20Operating%20System%20By%20Maurice%20Bach.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;copy&lt;/a&gt;

 of “&lt;a href=&#34;https://www.amazon.de/Design-UNIX-Operating-System-Prentice/dp/0132017997&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;The Design of the Unix Operating System&lt;/a&gt;

” by Maurice J. Bach. It will take you on a guided tour through the origins of our craft and the legacy we build on. The topics discussed in this note can be found on the pages 101ff, “WRITE” and “FILE AND RECORD LOCKING”.&lt;/p&gt;
&lt;p&gt;If you are into operating systems, continue reading after Bach: “&lt;a href=&#34;https://www.amazon.de/Design-Implementation-4-3Bsd-Operating-System/dp/0201061961&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;The Design and Implementation of the 4.3 BSD Operating System&lt;/a&gt;

” builds on Bach’s work and showcases the progress and inventions that Kirk McKusick, Sam Leffler et al made after that.&lt;/p&gt;
&lt;p&gt;If you are into comparative operating system design, read “&lt;a href=&#34;https://www.amazon.com/Inside-Windows-NT-Helen-Custer/dp/155615481X&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Inside Windows NT&lt;/a&gt;

” by Helen Custer after Bach and Leffler/McKusick, and try to understand the different ideas and world view behind that.&lt;/p&gt;
&lt;h2 id=&#34;but-we-dont-use-write2-for-atomic-file-updates&#34;&gt;
    &lt;a href=&#34;#but-we-dont-use-write2-for-atomic-file-updates&#34;&gt;
	But we don’t use write(2) for atomic file updates!
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Well, some of us do, but I agree that it is hard to get right: write(2) and writev(2) are very hard to handle properly in applications, as you need to write everything in a single call.&lt;/p&gt;
&lt;p&gt;Most programs use another atomic operation in Unix, the rename(2) system call. You write file.new at your leisure, printf(), chunked writes() and all. When completed, rename file.new to file. This automatically unlinks the old version of file as well.&lt;/p&gt;
&lt;p&gt;This is also the recommended approach to atomicity, because unlike write(2) it is stable in the face of the dreaded nightmare file system.&lt;/p&gt;
&lt;p&gt;rename(2) was introduced really early in BSD Unix because of specific race problems in the V7 Unix early BSD patched and improved.&lt;/p&gt;
&lt;p&gt;Before BSD, we only had link(2) and unlink(2). You can use a combination of these syscalls to implement a rename-like operation, but you need more than one syscall to do that.&lt;/p&gt;
&lt;p&gt;In Unix, at the end of a syscall, before return to userland, the scheduler runs (Bach, Chapter 8). That is, at the end of each syscall, a process can be forced to yield the CPU. This is the cause for potential race conditions when not having a rename(2) as a single syscall, and that is why BSD came up with a single syscall for renaming files in the first place.&lt;/p&gt;
&lt;p&gt;Renaming files for atomic updates can be taken to an art form: try looking into the Maildir/ implementations as invented by qmail, and implemented in Dovecot and Cyrus&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.qmail.org/man/man5/maildir.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Maildir Man Page&lt;/a&gt;

&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cr.yp.to/proto/maildir.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;On Maildir at DJBs site&lt;/a&gt;

&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://danluu.com/file-consistency/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Dan Luu on File Consistency&lt;/a&gt;

&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;And that concludes this issue of Our Systems Legacy.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>15 Jahre zuvor...</title>
      <link>https://blog.koehntopp.info/2011/12/05/15-jahre-zuvor.html</link>
      <pubDate>Mon, 05 Dec 2011 21:40:23 +0000</pubDate>
      
      <guid>https://blog.koehntopp.info/2011/12/05/15-jahre-zuvor.html</guid>
      <description>&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/kris_19961231.jpg&#34; alt=&#34;Kris, 31-Dec-1996&#34;  /&gt;
&lt;/p&gt;

&lt;/p&gt;
&lt;ol start=&#34;31&#34;&gt;
&lt;li&gt;Dezember 1996&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Silvesterfeier mit dem &amp;ldquo;Hohen Rath der 13. Weisen vom Feed&amp;rdquo; und der &amp;ldquo;Allianz
wieder den Hohen Rath der 13 Weisen vom Feed&amp;rdquo; in der Wassilystraße in Kiel.
Ich verfasse gerade den RfD rmgroup de.talk.bizarre.&lt;/p&gt;
&lt;p&gt;Linker Bildschirm: Linux-System, Mitte: NeXTstation (Graustufen-Display, 25
MHz 68040, 20 MB RAM, 1 GB HDD), Rechts: Storage, Tape und CD-ROM für
NeXTstation.&lt;/p&gt;
&lt;p&gt;Auf dem Schild am Regal über mir steht: &amp;ldquo;Das Kopieren von Programmen ist aus
urheberrechtlichen Gründen nicht gestattet.&amp;rdquo; Es stammt aus einem Kaufhaus,
aus meiner C64-Zeit.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>X11 auf dem Weg nach draußen</title>
      <link>https://blog.koehntopp.info/2011/05/10/x11-auf-dem-weg-nach-drau-en.html</link>
      <pubDate>Tue, 10 May 2011 13:15:38 +0000</pubDate>
      
      <guid>https://blog.koehntopp.info/2011/05/10/x11-auf-dem-weg-nach-drau-en.html</guid>
      <description>&lt;p&gt;Im September 1987 wurde die Version 11 des X-Protokolls erfunden. Damals war
alles schlimm: Wir hatten keinen Speicher, keine leistungsfähigen CPUs,
keine Fonts, schon gar keine Vektorfonts, keine Farbe, schon gar keine
Echtfarbe ohne Paletten, keine Transparency und vor allen Dingen keine
Ahnung.&lt;/p&gt;
&lt;p&gt;X11 war für Unix das Displaysystem der Wahl. Es macht eine ganze Menge Dinge
falsch: Zum Beispiel lebt es unter der Annahme, daß das Grafiksubsystem des
Rechners keine Rechenpower und wenig Speicher hat. So definiert es dann auch
einen Haufen Zeichenprimitive, die kilometerweit unter den Bedürfnissen
eines Fenstersystems liegen und läßt den Windowmanager auf der anderen Seite
des Netzwerkes als X11-Anwendung laufen. Es hat per Default Double Buffering
abgeschaltet und zeichnet per Default auch auf dem sichtbaren Screen statt
auf einem Offscreen-Puffer, der dann eingeblittet oder besser noch
eingeblendet wird. Von 3D und OpenGL hat es so gar keine Ahnung. Was heute,
in 2011, auf dem Bildschirm herum malt ist nur der Form halber noch X11, in
Wirklichkeit sind es aber meistenteils in X11-Extension verpackte
Spezialcalls, die mit X11 fast nichts mehr zu tun haben.&lt;/p&gt;
&lt;p&gt;Und es ist langsam. Wenn wir einen modernen Bildschirm mit X11 über das
Netzwerk raus sharen, dann stirbt X11 den Latenztod - formal ist X11
netzwerktransparent, aber in Wirklichkeit ist nichts an dem Protokoll
besonders geeignet oder schlau, wenn es darum geht, Daten über das Netzwerk
zu schaufeln. Andere Protokolle sind inzwischen weitaus besser geeignet,
Bildschirme über Netz zu exportieren: Selbst das halbtote VNC ist in der
Regel schneller und besser als X11, RDP und NX sind sogar richtig gut da
drin.&lt;/p&gt;
&lt;p&gt;In diesem Sinne:
&lt;a href=&#34;http://www.pro-linux.de/news/1/17018/xfree86-der-lebende-tote.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;XFree86&lt;/a&gt;


hat keine Comitter mehr. Der X.org Fork hat das Projekt vor Jahren abgelöst
und so die Firmen, die versucht haben, das X-Consortium zu Tode zu
kontrollieren, entmachtet. Aber auch X.org verliert an Bedeutung:
&lt;a href=&#34;http://www.golem.de/1105/83334.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Wayland&lt;/a&gt;

 ersetzt es gerade. Was gut
ist, weil dann ein Haufen alter Scheiß rausfliegt und man dann auch für den
häufigen Fall - lokales Display mit Hardware Acceleration - optimieren kann.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Nachtrag:&lt;/strong&gt; Um den Kommentatoren unter diesem Artikel einmal ein wenig
weiter zu helfen, hier ein paar Dinge zum Nachlesen.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;http://wayland.freedesktop.org/architecture.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Wayland Architecture Overview&lt;/a&gt;

 -
das erklärt die Anordnung der Dinge, wie sie vor Wayland gelaufen sind und
wie sie Wayland realisiert.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Moderne Desktops in Linux verwenden einen Compositor wie
&lt;a href=&#34;http://en.wikipedia.org/wiki/Compiz&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Compiz&lt;/a&gt;

.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Moderne Grafikhardware hat 3D Beschleuniger. Ein 3D-Beschleuniger
verwendet eine Tile (Kachel), um damit die Kanten von dreidimensionalen
Objekten zu bemalen. Die Hardware projeziert, skaliert und verformt dabei
die Tile so, daß sie auf die Seite des 3D-Objektes abgebildet wird. Wenn
das dreidimensionale Objekt eine rechteckige Leinwand ist, die nicht
skaliert und verformt ist, dann wird die Kachel per Hardware 1:1 auf der
Leinwand abgebildet und man hat einen Bildschirm, dessen Fenster-Rechtecke
per Hardware mit den Inhalten verschiedener unabhängiger Grafikpuffer
gefüllt wird. Diese Puffer zu verwalten und mit Effekten zu dekorieren ist
die Aufgabe eines Compositors. X11 weiß nichts von Compositors, die
X11-Erweiterung für Compositors schleust bloß Bitmaps sinnlos durch den
X11-Server. &lt;em&gt;Da&lt;/em&gt; kommt Latenz her.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Der erste Ansatz um Compositors unter X11 zum Laufen zu bringen war
&lt;a href=&#34;http://en.wikipedia.org/wiki/Xgl&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Xgl&lt;/a&gt;

. Xgl ist die Scheißidee, einen
X-Server unter einem X-Server laufen zu lassen. Dabei steuert der äußere
X-Server die Grafikhardware, der innere dann das Zeichnen mit X (das
sowieso niemand mehr verwendet).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Moderne X-Server verwenden &lt;a href=&#34;http://en.wikipedia.org/wiki/AIGLX&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;AIGLX&lt;/a&gt;

.
Das ist eine Methode, bei der man essentiell dem X-Server sagt: &amp;ldquo;Okay, Du
kannst da jetzt rumstehen und nix tun, aber dieses Rechteck da zeichnet
jetzt jemand anders als Du, nämlich OpenGL.&amp;rdquo;. Wayland komplettiert diesen
Schritt nur, indem es den Default richtig rum setzt: Es räumt den
X-Server, der sowieso nicht mehr verwendet wird, aus dem Weg.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Qt und GTK haben Wayland-Support. Beide Toolkits malen schon seit längeren
fertige Tiles - X-Primitives verwendet schon lange niemand mehr, weil sie
zu scheiße aussehen und auch nicht portabel auf Windows-, Mac- oder
Handy-Hardware sind. Die Tiles werden dann entweder mit X11 oder eben
direkt in Wayland zum Compositor geshipped, der daraus einen Bildschirm
mit Fenstern macht. Qt kann sogar zur Laufzeit den Shipping Mechanismus
zwischen X11 und Wayland umschalten.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Die Executive Summary ist: X11 ist schon länger tot. Es ist durch Extensions
zu einem recht ineffizienten Durchreich-Mechanismus für Tiles (Pixmaps)
geworden. Es kontrolliert auch nicht mehr die Hardware - einer
Usermode-Anwendung root-Rechte zu geben, damit sie in Grafikkarten-Register
poken kann ist sowieso galoppierender Unsinn gewesen und
&lt;a href=&#34;http://en.wikipedia.org/wiki/Mode-setting#Linux&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kernel Mode Setting&lt;/a&gt;

 hat das zum Glück
überflüssig gemacht.&lt;/p&gt;
&lt;p&gt;Wayland streut nun die Blumen auf das Grab und schaufelt endlich die Erde
drauf. Es ruhe in Frieden.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Wieviel Speicher brauchst Du denn?</title>
      <link>https://blog.koehntopp.info/2009/10/09/wieviel-speicher-brauchst-du-denn.html</link>
      <pubDate>Fri, 09 Oct 2009 17:05:00 +0000</pubDate>
      
      <guid>https://blog.koehntopp.info/2009/10/09/wieviel-speicher-brauchst-du-denn.html</guid>
      <description>&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/mappedprocess3.png&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;

&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Linux mapped die Speicherseiten zweiter Prozesse. Dabei wird speicher geteilt, oder Seiten sind noch ungeladen. Manche Seiten werden beim ersten Schreibzugriff kopiert (Copy-on-Write).&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Manchmal muß man viel erklären, um eine einfache Frage beantworten zu können: Wieviel Speicher belegt ein Programm in Linux? Diese Frage war bisher überraschend schwer zu beantworten. Da ist einmal die Ausgabe von &lt;code&gt;ps axuwww&lt;/code&gt; oder &lt;code&gt;top&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;go&#34;&gt;[root@mc01bpmdb-02 ~]# ps axu | egrep &amp;#39;(mysql[d]|USER)&amp;#39;
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;USER       PID %CPU %MEM   VSZ  RSS TTY      STAT START   TIME COMMAND
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;...
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;mysql    24861 71.2 77.3 26284608 25444724 ? Sl    2008 385405:36 /usr/sbin/mysqld
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;...
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Hier bekommt man zwei Größenangaben in den Spalten VSZ und RSS, beide sind in Kilobytes.&lt;/p&gt;
&lt;p&gt;Die Angabe VSZ wird als die gesamte Virtuelle Prozeßgröße des Progresses bezeichnet. Die Manpage zu &lt;code&gt;ps&lt;/code&gt; listet dies als &amp;ldquo;vm_lib + vm_exe + vm_data + vm_stack&amp;rdquo;, also als Summe der Mappings für das Executeable, die reservierten Datenbereiche, alle Bibliotheken und den Stack, und ich bin sicher, daß das nicht ganz korrekt ist, weil es mit &lt;code&gt;mmap(2)&lt;/code&gt; gemappte Speicherbereiche nicht mit aufzählt, aber diese auch angezeigt werden.&lt;/p&gt;
&lt;p&gt;Die Angabe RSS steht für Resident Set Size, die Menge des nicht rausgepagten physikalischen Speicher die dieser Prozeß hält.&lt;/p&gt;
&lt;p&gt;Man kann die VSZ also als die &amp;lsquo;gemappte&amp;rsquo; Größe des Prozesses bezeichnen und die RSS als die &amp;lsquo;belegte&amp;rsquo; Größe des Prozesses.&lt;/p&gt;
&lt;p&gt;Wenn man ein MySQL neu startet sieht man, daß die VSZ schon fast die endgültige Größe des Prozesses erreicht hat (MySQL hat schon einmal alle großen Puffer beim Betriebssystem bestellt und treibt so die Prozeßgröße nach oben). Die RSS ist jedoch noch sehr klein, weil diese bestellten Puffer noch nicht beschrieben wurden und das Betriebssystem daher die entsprechenden Speicherseiten auch noch nicht physikalisch realisiert hat - die Puffer der Datenbank sind noch kalt und die Daten werden nach Bedarf bei den ersten Zugriffen erst einmal von Disk geladen.&lt;/p&gt;
&lt;p&gt;Über die Zeit wird die VSZ ein wenig steigen (Verbindungen werden aufgebaut und MySQL bestellt noch ein wenig zusätzlichen Speicher) und die RSS nähert sich der VSZ immer mehr an. Die Datenbank im Beispiel da oben hat eine VSZ von etwas über 25G und eine RSS von immerhin 24.2G. Sie läuft schon sehr lange.&lt;/p&gt;
&lt;p&gt;Auch von einem &lt;code&gt;top&lt;/code&gt; bekommt man diese Zahlen, sogar gleich in hübsch:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;go&#34;&gt;PID USER      PR  NI %CPU    TIME+  %MEM  VIRT  RES  SHR S COMMAND            
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;24861 mysql     16   0  222 385424:47 77.4 25.1g  24g 5804 S mysqld
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Aber für Prozesse, die viel fork()&amp;lsquo;en bekommt man so keine sehr aussagekräftigen Zahlen. Von einem Apache-Webserver würde man ja sehr gerne wissen, wie viele parallele Server-Instanzen man so ausführen kann, wenn man ihn startet.&lt;/p&gt;
&lt;p&gt;Hier ist mein Apache, in einem Moment geringer Last:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;go&#34;&gt;h743107:~ # ps auxwww | grep http
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;root     18345  0.0  0.9 124880 10100 ?        Ss   Oct08   0:00 /usr/sbin/httpd2 
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;wwwrun   28179  2.3  3.1 127172 32324 ?        S    17:28   0:09 /usr/sbin/httpd2 
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;wwwrun   28591  1.8  2.8 127796 29192 ?        S    17:33   0:02 /usr/sbin/httpd2 
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;wwwrun   28677  1.7  2.2 127480 23808 ?        S    17:34   0:00 /usr/sbin/httpd2 
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;wwwrun   28678  1.2  2.6 127448 27408 ?        S    17:34   0:00 /usr/sbin/httpd2
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;wwwrun   28779  1.9  2.3 127116 24780 ?        S    17:35   0:00 /usr/sbin/httpd2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Wir erkennen zwei Sorten Apache-Prozesse: PID 18345 läuft unter der UID root - es ist der Apache Master, der auf eingehende Verbindungen lauscht und Aufträge dann an Worker-Prozesse weiter gibt, die die eigentliche Seite erzeugen. Der Master steuert auch die Größe des Worker-Pools über die Zeit je nach Bedarf. Dazu hat er eine Reihe von Parametern, von denen einer den Namen MaxClients hat. Dieser Parameter legt fest, wie viele Worker Apache maximal startet und man sollte diesen Wert so hoch wie möglich ansetzen ohne daß der Server in den Swap gerät.&lt;/p&gt;
&lt;p&gt;Wie man sieht hat ein Apache Master bei mir eine Größe von etwas über 120M, aber eine RSS von etwas unter 10M. Die Worker haben ebenfalls eine VSZ von mehr als 120M, aber ihre RSS ist mit um die 24-32M etwas größer.&lt;/p&gt;
&lt;p&gt;Der tatsächliche Speicherverbrauch ist jedoch weitaus geringer. Wir können ihn uns im Detail in der Datei /proc/&lt;em&gt;PID&lt;/em&gt;/maps ansehen:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;go&#34;&gt;h743107:~ # cd /proc/18345/
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;h743107:/proc/18345 # wc -l maps
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;264 maps
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;h743107:/proc/18345 # head -6 maps
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;80000000-8004f000 r-xp 00000000 08:03 9732852    /usr/sbin/httpd2-prefork
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;8004f000-80052000 rw-p 0004f000 08:03 9732852    /usr/sbin/httpd2-prefork
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;80052000-80349000 rw-p 80052000 00:00 0          [heap]
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;b090f000-b490f000 rw-s 00000000 00:08 17650846   /dev/zero (deleted)
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;b490f000-b690f000 rw-s 00000000 00:08 688128     /SYSV00000000 (deleted)
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;b690f000-b695d000 r-xp 00000000 08:03 9701605    /usr/lib/libgcrypt.so.11.2.2
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;h743107:/proc/18345 # tail -6 maps
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;b7f9d000-b7f9e000 rw-p b7f9d000 00:00 0 
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;b7f9e000-b7f9f000 r-xp b7f9e000 00:00 0          [vdso]
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;b7f9f000-b7fba000 r-xp 00000000 08:03 6160422    /lib/ld-2.5.so
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;b7fba000-b7fbc000 rw-p 0001a000 08:03 6160422    /lib/ld-2.5.so
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;bf866000-bf87a000 rwxp bf866000 00:00 0          [stack]
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;bf87a000-bf87b000 rw-p bf87a000 00:00 0
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Die Angaben in /proc/&amp;hellip;/maps lassen sich &lt;a href=&#34;http://linuxwiki.de/proc/pid#A.2BAC8-proc.2BAC8.3CPID.3E.2BAC8-maps&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;wie folgt&lt;/a&gt;

 lesen:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Die erste Angabe ist ein Bereich von Speicheradressen, der im Adreßraum des Prozesses belegt wird. Da der Speicher in einer Intel-CPU in Speicherseiten von 12 Bit = 4K verwaltet wird, sind die Angaben immer vielfache von 4K (0x1000), d.h. die letzten 3 Stellen sind immer 0.&lt;/li&gt;
&lt;li&gt;Die Flags geben dann an, welche Operationen auf diesem Speicherbereich möglich sind: rwx für read, write und execute. p ist ein Private Mapping, s ist ein Shared Mapping.&lt;/li&gt;
&lt;li&gt;Viele Mappings sind Abbildungen von Dateien in den Adreßraum eines Prozesses. In Unix wird eine Datei aber durch ihre Gerätenummer (maj, min) und ihre Inode-Nummer auf dem Gerät bezeichnet, etwa 08:03 9732852.&lt;/li&gt;
&lt;li&gt;In der Map wird auch noch der Pfadname dieser Datei angezeigt, soweit bekannt (/usr/sbin/httpd2-prefork).&lt;/li&gt;
&lt;li&gt;Nun kann es sein, daß verschiedene Abschnitte dieser Datei mit unterschiedlichen Rechten eingeblendet werden sollen: So soll /usr/sbin/httpd2-prefork ab Offset 00000000 mit den Rechten r-x an der Adresse 80000000 eingeblendet werden, der Abschnitt derselben Datei ab 0004f000 jedoch mit rw- ab Speicheradresse 8004f000.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Das wird klarer, wenn man sich die Datei einmal anschaut:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;go&#34;&gt;h743107:/proc/18345 # size -x /usr/sbin/httpd2-prefork
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;   text    data     bss     dec     hex filename
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;0x4ebe3  0x2378  0x2e10  343403   53d6b /usr/sbin/httpd2-prefork
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Die Datei besteht also aus Code (Text) in der Länge von 0x4ebe3 Byte, das entspricht aufgerundet 0x4f000 Bytes oder 0x4f Seiten zu 4K. Danach kommen 0x2378 Byte (0x3000 Byte aufgerundet zur Seitengrenze) ab Offset 0x4f000 an Daten.&lt;/p&gt;
&lt;p&gt;Das heißt, die erste Zeile der maps-Datei zeigt uns wie der Code des Webservers ab Offset 0 der Datei in Adresse 0x80000000 in den Speicher eingeblendet wird. Die Einblendung ist schreibegeschützt. Danach kommt ab 0x8004f000 im Speicher (und ab 0x4f000 in der Datei) der Datenteil, der wiederum beschreibbar ist.&lt;/p&gt;
&lt;p&gt;Die Summe aller dieser Einblendungen ist die VSZ des Prozesses, also der Anteil seines 64-Bit oder 32-Bit Adreßraumes, auf den der Prozeß zugreifen kann ohne daß ihm das Betriebssystem an die Ohren haut.&lt;/p&gt;
&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/unmappedprocess.png&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;

&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Bei einem Programmstart existieren zwar Mappings für die virtuellen Speicherseiten eines Prozesses (hier mit 1-7 bezeichnet), aber ihnen sind keine physikalischen Speicherseiten zugeordnet. Jeder Zugriff auf eine dieser Seiten wird vom Betriebssystem erkannt und abgefangen.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Aber die Tatsache, daß ein Mapping für eine virtuelle Adresse existiert heißt noch lange nicht, daß das Betriebssystem auch physikalischen Speicher dafür belegt hat. Genau genommen ist am Anfang gar keine Speicherseite belegt - das Betriebssystem mapped das Programm in den Speicher, aber das Programm ist noch nicht geladen. Dann beginnt das Programm seine Ausführung und greift auf eine Speicheradresse zu, die nicht existiert.&lt;/p&gt;
&lt;p&gt;Das erste was also passiert ist eine Speicherschutzverletzung - aber eine legale. Das Betriebssystem wird aus seinem Pool leerer Speicherseiten eine auswählen, dort den auf Grund der Mappinginformationen benötigten Inhalt reinladen und die abgebrochene Instruktion nun neu starten.&lt;/p&gt;
&lt;p&gt;Im Beispiel wird beim Start des Programmes also auf Seite 1 zugegriffen, die jedoch nicht gemapped war. Das Betriebssystem unterbricht die Ausführung des Programmes, lädt die betreffende Seite von Disk in eine physikalische Speicherseite, hier B, stellt das Mapping her und restartet die Instruktion. Wird die Ausführung fortgesetzt entstehen weitere Seitenfehler (page faults) und das Programm wird sukzessive so weit in den Speicher geladen wie notwendig - aber es wird nie mehr Speicher verbraucht als unbedingt notwendig.&lt;/p&gt;
&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/mappedprocess1.png&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;

&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Beim Zugriff auf Seite 1 kommt es zu einem (legalen) Seitenfehler. Das Betriebssystem unterbricht die Anweisung, die den Fehler ausgelöst hat, lädt die fehlende Speicherseite von der Platte in das physikalische RAM (hier: Seite B) und stellt ein Mapping der virtuellen Seite 2 auf die physikalische Seite B her. Danach wird die unterbrochene Anweisung neu gestartet - das ausgeführte Programm merkt nichts vom Getrickse des Betriebssystems.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Die Optimierungen sind offensichtlich: Wenn beim Herstellen des Programms durch den Compiler und Linker oder durch Profiling von vorhergehenden Programmausführungen ermittelt werden kann, welche Teile des Programmes auf jeden Fall benötigt werden, dann kann man den Hagel der Seitenfehler beim Programmstart antizipieren und die gebrauchten Seiten gleich und linear in den Speicher laden. Das ist schneller und effektiver - moderne Betriebssysteme machen das auch so.&lt;/p&gt;
&lt;p&gt;In jedem Fall entsteht durch die Programmausführung ein Mapping von Seiten - dabei muß es keine lineare Entsprechung von virtuellen (Prozeß-) Adressen und physikalischen Speicheradressen geben.&lt;/p&gt;
&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/mappedprocess2.png&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;

&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Nach einiger Zeit sind alle benutzten Seiten des Programmes irgendwie auf physikalischen Speicher abgebildet, das Programm und seine Daten befinden sich im RAM.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;In Linux wird die Situation nun durch mehrere Dinge noch komplizierter: Zum einen existieren Shared Libraries. Das ist Code, der von allen oder vielen Programmen gebraucht wird und der deswegen in einer Extradatei abgelegt ist - zum Beispiel libc.so.6, die Laufzeitbibliothek der Sprache C:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;go&#34;&gt;h743107:/lib # ls -lL libc.so.6
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;-rwxr-xr-x 1 root root 1491141 Oct 19  2008 libc.so.6
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;h743107:/lib # size -x libc.so.6
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;   text    data     bss     dec     hex filename
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;0x1273dd         0x2758  0x2c58 1230733  12c78d libc.so.6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Wie man sieht ist die libc recht fett: 0x128000 Bytes, also 0x128 Speicherseiten an Code plus Daten. Jedes noch so kleine Hello-World-Programm das &lt;code&gt;printf()&lt;/code&gt; aufruft verwendet die ganze libc.&lt;/p&gt;
&lt;p&gt;Aber: Der Code für die libc wird nur einmal geladen und belegt nur einen Satz physikalische Speicherseiten. Er wird jedoch in jeden laufenden Prozeß im System eingeblendet:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;go&#34;&gt;h743107:/proc # ls -ld [0-9]* | wc -l 
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;198
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;h743107:/proc # grep libc-2.5 [0-9]*/maps | grep r-xp| wc -l 
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;175
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Okay, fast jeden. Etwas anderes fällt dabei auch noch auf:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;go&#34;&gt;h743107:/proc # grep libc-2.5 [0-9]*/maps | grep r-xp| head -10
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;1031/maps:b7c1f000-b7d47000 r-xp 00000000 08:03 6160449    /lib/libc-2.5.so
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;1131/maps:b7c1f000-b7d47000 r-xp 00000000 08:03 6160449    /lib/libc-2.5.so
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;1154/maps:b7b24000-b7c4c000 r-xp 00000000 08:03 6160449    /lib/libc-2.5.so
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;1155/maps:b7b24000-b7c4c000 r-xp 00000000 08:03 6160449    /lib/libc-2.5.so
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;1247/maps:b7c1f000-b7d47000 r-xp 00000000 08:03 6160449    /lib/libc-2.5.so
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;12512/maps:b7e4a000-b7f72000 r-xp 00000000 08:03 6160449    /lib/libc-2.5.so
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;1278/maps:b7c1f000-b7d47000 r-xp 00000000 08:03 6160449    /lib/libc-2.5.so
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;12906/maps:b7dae000-b7ed6000 r-xp 00000000 08:03 6160449    /lib/libc-2.5.so
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;13103/maps:b7cee000-b7e16000 r-xp 00000000 08:03 6160449    /lib/libc-2.5.so
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;1342/maps:b7b30000-b7c58000 r-xp 00000000 08:03 6160449    /lib/libc-2.5.so
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Der Code einer shared library ist verschieblich (PIC, position independent code) und kann so in verschiedenen Programmen an verschiedenen Stellen eingeblendet werden. Das kann wegen PIC geschehen, ohne daß die Inhalte der Speicherseiten angepaßt werden müssen: Sprünge im Code werden relativ (300 Bytes vor) statt absolut (springe nach b7c1fe34) angegeben. Die libc ist also einmal geladen, belegt 0x128 Speicherseiten, wird aber in unserem System in 175 von 198 Programmen eingeblendet.&lt;/p&gt;
&lt;p&gt;Das heißt, wir verbrauchen schon mal sehr viel weniger Speicher als gedacht. Gut.&lt;/p&gt;
&lt;p&gt;Nun hat zwar jedes Programm mit libc ein &lt;code&gt;printf()&lt;/code&gt; und ein &lt;code&gt;ctime()&lt;/code&gt;, aber in jedem Programm steht in dem statischen internen Puffer der Funktion ctime() eine andere Zeit - jedes Programm hat für seine libc also eigene private Daten. Die Datenseiten der verschiedenen libc können also nicht zwischen den Prozessen geshared werden. Darum haben sie auch eigene Mappings mit eigenen Zugriffsrechten:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;go&#34;&gt;h743107:/proc # grep libc /proc/self/maps
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;b7dbd000-b7ee5000 r-xp 00000000 08:03 6160449    /lib/libc-2.5.so
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;b7ee5000-b7ee6000 r--p 00128000 08:03 6160449    /lib/libc-2.5.so
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;b7ee6000-b7ee8000 rw-p 00129000 08:03 6160449    /lib/libc-2.5.so
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Dasselbe passiert auch mit Programmen, die sich per &lt;code&gt;fork()&lt;/code&gt; vervielfältigen oder mehrfach geladen werden: Wenn zwei Benutzer vi verwenden, dann steht der Code für vi selbst nur einmal im Speicher - aber jeder vi-Prozeß hat eigene Datenseiten, die eigenen Text speichern und eine eigene Cursorposition und einen eigenen Cut und Paste-Buffer haben. Das ist ja recht wichtig, wenn man nicht gerade Google Docs ist und Documente haben möchte, die von mehreren Personen zur Zeit bearbeitet werden können sollen.&lt;/p&gt;
&lt;p&gt;Hier greift noch eine weitere Optimierung: Copy on Write (COW). Wenn im Beispiel also Prozeß 2 durch fork() aus Prozeß 1 erzeugt wird, wie es der Apache Webserver zum Beispiel laufend tut, dann sind zunächt &lt;em&gt;alle&lt;/em&gt; Speicherseiten zwischen beiden Prozessen geshared - auch die, die beschrieben werden können.&lt;/p&gt;
&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/mappedprocess3.png&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;

&lt;/p&gt;
&lt;p&gt;&lt;em&gt;PID 2 versucht Seite 3 zu beschreiben, die auf die Seite F gemapped war. Da auch PID 1 diese Seite sehen kann, würde dieser Schreibzugriff von PID 2 Daten verändern, die PID 1 sieht - das geht nicht! Das Betriebssystem fängt den Zugriff ab, kopiert die Seite F nach G und mapped Seite 3 für PID 2 nach G. Jetzt haben PID 1 und PID 2 jeder eine private Kopie der veränderten Daten - der Rest wird aber noch geshared.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Schreibt nun etwa Prozeß 2 in seine Speicherseite 3, dann löst dies wiederum eine Zugriffsverletzung aus, weil die Seite zwar prinzipiell beschreibbar ist, aber vom Betriebssystem heimlich als schreibgeschützt markiert worden ist. Das Betriebssystem kopiert nun die physikalische Speicherseite F nach G, ändert das Mapping von 3 für den Prozeß 2 so, daß die Seite 3 nun auf G statt F zeigt und restarted die unterbrochene Instruktion. Beide Prozesse haben nun ihre private Kopie von Seite 3 (PID 1 hat F, PID 2 hat G) und können bis auf weiteres unbehelligt schreiben.&lt;/p&gt;
&lt;p&gt;Da das Kopieren von Seiten nur nach Bedarf - bei Schreibzugriffen - geschieht, wird von einer fork()-Kopie also nur so viel Speicher benötigt, wie unbedingt notwendig (zu Speicherseiten aufgerundet, natürlich). Es mag also sein, daß ich einen httpd2 mit 128M VSZ habe, der 20 Kopien von sich startet. Aber das erzeugt weder einen Speichermehrverbrauch von 20 * 128M, noch einen Speicherverbrauch von 20*24M (die RSS), sondern ist je nach Benutzung des Speichers sehr viel weniger.&lt;/p&gt;
&lt;p&gt;Leider kann man nicht leicht sagen, wie viel genau.&lt;/p&gt;
&lt;p&gt;An dieser Stelle kommen nun lustige Kernel-Erweiterungen und Werkzeuge ins Spiel und die sind der Grund, warum ich diesen Artikel überhaupt angefangen habe:&lt;/p&gt;
&lt;p&gt;Auf der &lt;a href=&#34;http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/2009-10/msg00329.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Perl5 Porters Mailingliste&lt;/a&gt;

 stellt Joshua ben Jore das Werkzeug &lt;a href=&#34;http://www.berthels.co.uk/exmap/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Exmap&lt;/a&gt;

 vor, zu dem es &lt;a href=&#34;http://github.com/cxreg/exmap/blob/00c3ad6fe135feb695dff7babcc02c408675ce15/README&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;auch noch Patches&lt;/a&gt;

 gibt. Auch &lt;a href=&#34;http://www.selenic.com/smem/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;smem&lt;/a&gt;

 kann die Speichernutzung von Prozessen detaillierter analysieren und so genauer ermitteln wie hoch der Speicherverbrauch eines Prozesses denn nun wirklich ist.&lt;/p&gt;
&lt;p&gt;Und das wiederum erlaubt dann genauere Planungen der MaxClients in einem Apache.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Unix-&#34;Standards&#34;</title>
      <link>https://blog.koehntopp.info/2009/07/26/unix-standards.html</link>
      <pubDate>Sun, 26 Jul 2009 17:14:50 +0000</pubDate>
      
      <guid>https://blog.koehntopp.info/2009/07/26/unix-standards.html</guid>
      <description>&lt;p&gt;Die Geschichte von Unix ist eine Geschichte der gescheiterten oder unbrauchbaren Standards - ihre Zahl ist Legion.&lt;/p&gt;
&lt;p&gt;Egal in welche Richtung man schaut: Sun zum Beispiel hatte einmal einen auf Postscript basierenden Desktop - &lt;a href=&#34;http://en.wikipedia.org/wiki/NeWS&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;NeWS&lt;/a&gt;

, der in gewissser Weise X11 um Jahrzehnte voraus war, sich aber nie hat durchsetzen können, unter anderem deswegen, weil das Ding von Sun als Waffe gegen andere Unix-Anbieter verwendet worden war und quasi tot-lizensiert wurde, gefolgt von&lt;a href=&#34;http://en.wikipedia.org/wiki/OPEN_LOOK&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Open Look&lt;/a&gt;

 und dann dem Motif-basierenden &lt;a href=&#34;http://en.wikipedia.org/wiki/Common_Desktop_Environment&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CDE&lt;/a&gt;

. Speziell letzteres war endlich ein herstellerübergreifendes Projekt, das von allen kommerziellen Unix-Anbietern unterstützt wurde (siehe auch &lt;a href=&#34;http://en.wikipedia.org/wiki/Solaris_%28operating_system%29#Desktop_environments&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;den Solaris-Artikel&lt;/a&gt;

). Da Motif als Toolkit aber bis zur Obsoleszens keine freie Software war und CDE auch keine nennenswerte Weiterentwicklung erfuhr, wurde es inzwischen großflächig durch KDE oder Gnome ersetzt - beides nativ freie Software.&lt;/p&gt;
&lt;p&gt;Auch auf Ebenen weiter unten war Standardisierung schwierig und ist vielfach gescheitert - so hat &lt;a href=&#34;http://en.wikipedia.org/wiki/POSIX&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;POSIX&lt;/a&gt;

 bis heute keine Norm für Access Control Lists von Dateisystemen und entsprechend ist etwa die Kommandozeilensyntax (und Ausdrucksstärke) von Access Control Lists auf einem Mac, einem Linux und einem Solaris unterschiedlich. Schaut man sich die Datumsangaben in dem verlinkten Wikipedia-Artikel an, kann man erkennen, daß Posix ein klassischer Nachfolgestandard ist - also kein Standard, der irgendetwas definiert oder voran bringt, sondern einer, der nur eine bereits vollzogene Entwicklung dokumentiert und festschreibt. Auch hier sind Herstellerkriege um Definitionsmacht die Ursache dafür.&lt;/p&gt;
&lt;p&gt;Auf der anderen Seite findet man eine Reihe von Innovationen in Unix, die sich universell durchgesetzt haben, aber erst nachdem ein Hersteller sie in klarer Verletzung aller formellen und informellen Standards eingeführt hat. Um bei Sun zu bleiben: Die heutige Architektur von Shared Libraries (.so&amp;rsquo;s) wie wir sie kennen ist einem Alleingang von Sun geschuldet, der so erfolgreich war, daß wir ihn heute in allen Unices finden, die überlebt haben. Genau so ist das heutige Layout von Dateisystemen, also die Einführung von /var, /home, /opt und die Aufgabe der Trennung von / und /usr ein Alleingang von Sun, der so erfolgreich war, daß er über den Umweg von SVR4 in alle nennenswerten modernen Unices Einzug gehalten hat.&lt;/p&gt;
&lt;p&gt;Sun hat das damals machen können, weil sie Workstations in großer Zahl abgesetzen konnten und so die entsprechende Definitionsmacht hatten. Außerdem sind die oben genannten Innovationen Beispiele für Innovationen, die nicht totlizensiert waren und so ohne Risiko experimentell von anderen Herstellern übernommen werden konnten.&lt;/p&gt;
&lt;p&gt;Die Rolle von Sun im heutigen Unix-Markt ist eine viel kleinere - Sun hat nicht nur nach Stückzahlen, sondern vor allen Dingen nach Developer- Mindshare eine sehr viel kleinere Rolle. Sun hat immer noch Ideen, einige von denen sind sogar kopierenswert. In die nach Stückzahlen und vor allen Dingen nach Developer-Mindshare sehr viel größere Linux-Welt werden sie jedoch nicht.&lt;/p&gt;
&lt;p&gt;Die Gründe sind immer noch dieselben wie oben:&lt;/p&gt;
&lt;p&gt;ZFS und Dtrace sind zwei Ideen, die sehr kopierenswert sind, die aber aus der Sicht der Linux-Welt totlizensiert sind. Sie sind totlizensiert in dem Sinne, daß die Lizenz dieser Stücke Software frei im Sinne von DFSG sein mag, aber die Lizenz ist mit der GPL inkompatibel. Das mag Absicht oder ein unglücklicher Zufall sein, Fakt ist, daß diese Ideen so nicht direkt als Code in Linux übernommen werden können. Also entwickeln sich in Linux alternative Projekte und es ist absehbar, daß diese in den nächsten 5 Jahren die entsprechenden Sun-Konzepte verdrängen werden - falls Oracle den Kram (&lt;strong&gt;Update wegen &lt;a href=&#34;http://blog.vodkamelone.de/archives/157-BTRFS-und-die-Lizenz....html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ixs Artikel&lt;/a&gt;

:&lt;/strong&gt; gemeint ist ZFS, das ja nun wie ganz Sun auch Oracle gehört) nicht Linux-kompatibel relizensiert. Letzteres wäre immerhin denkbar, denn die BTRFS-Entwicklung wurde zu einem guten Teil von Oracle finanziert und BTRFS ist das Linux-Gegenstück zu ZFS.&lt;/p&gt;
&lt;p&gt;Ein anderes Beispiel für eine Sun-Idee, die kopierbar wäre, aber nicht kopiert wird, ist SMF - hier ist die Sun-Lösung zu häßlich oder verkopft und es gibt zu viele konkurrierende Ideen, um &lt;a href=&#34;http://en.wikipedia.org/wiki/Init#Other_styles&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;init&lt;/a&gt;

 zu ersetzen. Wahrscheinlicher ist es, daß sich Konzepte wie &lt;a href=&#34;http://en.wikipedia.org/wiki/Upstart&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Upstart&lt;/a&gt;

 auf breiter Front durchsetzen.&lt;/p&gt;
&lt;p&gt;Unter dem Strich bleiben einige Erkenntnisse:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Standards sind öfter als nicht Festschreibungen bereits erfolgter Standardisierungsprozesse. Sie sind meist mehr Dokumentation als Innovation.&lt;/li&gt;
&lt;li&gt;Innovation wird im Unix-Bereich oft als Abweichung von einem vermeintlich oder tatsächlich bestehenden Standard wahrgenommen und daher oft schon aus Prinzip und ungeachtet ihres Nutzens mit Kritik überzogen.&lt;/li&gt;
&lt;li&gt;In 2009 haben die verschiedenen Linux-Distributionen endlich eine solche Marktmacht, daß sie de-facto Standards setzen können, die mit großer Wahrscheinlichkeit bald in Standarddokumenten dokumentiert werden. Die Tatsache, daß Sun
die GNU Tools im Pfad vor den eigenen Tools positioniert ist Testament dieser Entwicklung.&lt;/li&gt;
&lt;li&gt;Die Tatsache, daß es einen Unterschied macht ob man Sun Tools oder GNU Tools vorne im Pfad hat (oder BSD- statt SysV-Tools vorne im Pfad plaziert), ist Dokumentation der Tatsache, daß die existierenden Standardisierungen im Unix-Bereich noch lange nicht weit genug gehen, um eine Plattform zu erzeugen, die für die Anwendungsentwicklung groß genug wäre. Kommandozeilenwerkzeuge sind aber nur ein Aspekt der Sache - das Spiel setzt sich in rpm, deb, pkg und anderen Paketformaten, tar-Versionen, Desktop-Umgebungen und so weiter fort.&lt;/li&gt;
&lt;li&gt;Andererseits dokumentiert der bisherige Erfolg von Linux, daß das gar nicht so schlimm ist - von allen Unix-Versionen außer Linux sind überhaupt nur noch Solaris und AIX übrig geblieben und beide werden immer Linux-ähnlicher. Das ist eine gute Sache, und wenn man das erst einmal akzeptiert hat, kann man sich an den Tisch setzen und konstruktiv dokumentatorische Standards verabschieden.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(geschrieben nach der Lektüre von
&lt;a href=&#34;http://www.c0t0d0s0.org/archives/5785-Thoughts-of-an-admin-starting-to-get-old-....html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Jörgs Rant&lt;/a&gt;

)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Neue Ideen in Dateisystemen (oder: BTRFS in Fedora 11)</title>
      <link>https://blog.koehntopp.info/2009/02/06/neue-ideen-in-dateisystemen-oder-btrfs-in-fedora-11.html</link>
      <pubDate>Fri, 06 Feb 2009 16:34:20 +0000</pubDate>
      
      <guid>https://blog.koehntopp.info/2009/02/06/neue-ideen-in-dateisystemen-oder-btrfs-in-fedora-11.html</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;There are two kinds of fool. One says, “This is old, and therefore good..” And one says “This is new, and therefore better..”	—John Brunner, in The Shockwave Rider&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Neue Ideen in Dateisystemen sind so eine Sache. Es handelt sich bei einem Dateisystem ja um Infrastrukturcode par excellence, und so reden die meisten Leute gerne von ihrem letzten Datenverlust, wenn man sie nach Dateisystemen befragt. Das ist nicht neu, ich habe in &lt;a href=&#34;https://blog.koehntopp.info/2008/05/30/the-importance-of-fail.html&#34;&gt;The Importance Of FAIL&lt;/a&gt;

 das Thema ja schon mal angeschnitten.&lt;/p&gt;
&lt;p&gt;Neue Ideen in Dateisystemen sind auch langsam. 1984 bis 1992 gab es das
&lt;a href=&#34;http://en.wikipedia.org/wiki/Sprite_operating_system&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Sprite Projekt&lt;/a&gt;

 in Berkeley, bei dem es um die Entwicklung eines rechnerübergreifenden Betriebssystems ging. Teil von Sprite war auch etwas, das sich &lt;a href=&#34;http://en.wikipedia.org/wiki/Log-structured_file_system&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;LFS (Log Structured Filesystem)&lt;/a&gt;

 nannte.&lt;/p&gt;
&lt;p&gt;LFS basiert auf der Idee, daß nur noch Writes auf eine Platte übrig bleiben, wenn man nur genug RAM zum Cachen aller Reads hat. Also quasi die Situation, in der Google jetzt grad ist. Wenn das aber so ist, so geht die Überlegung weiter, dann muß man Daten auf der Platte nicht zum Lesen optimiert ablegen, sondern das Schreiben optimieren.&lt;/p&gt;
&lt;h2 id=&#34;ein-exkurs-in-fragmentierung&#34;&gt;
    &lt;a href=&#34;#ein-exkurs-in-fragmentierung&#34;&gt;
	Ein Exkurs in Fragmentierung
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Gegeben sei MS-DOS, also ein System mit nur einem Thread, der Read-Requests generieren kann und quasi ohne Read-Cache, der solche Reads wegoptimieren kann. Dann ist das Dateisystem dann für viele Anwendungen zum Lesen optimiert, wenn alle Dateien defragmentiert abspeichert sind, d.h die Blocknummern der physikalischen Blöcke jeder Datei unmittelbar aufeinanderfolgend sind.&lt;/p&gt;
&lt;p&gt;Gegeben sei ein System mit unendlich viel Speicher, das schon unendlich lange läuft. Dann wiederum sind alle Daten im RAM gecached, und die physikalische Anordnung der Daten auf der Platte ist aus der Sicht der Lesezugriffe total schnurz.&lt;/p&gt;
&lt;p&gt;Die meisten realen Systeme liegen irgendwo dazwischen - je mehr RAM und je besser die Caches vorgeglüht, desto mehr ist es egal, wie die Daten auf der Platte angeordnet sind.&lt;/p&gt;
&lt;p&gt;Die meisten realen Systeme haben heutzutage auch mehr als einen Thread, der Requests erzeugen kann und schon von daher ist das statisch lineare Layout von Dateien auf der Platte nicht mehr unmittelbar ein Garant für dynamisch lineare Lesezugriffe.&lt;/p&gt;
&lt;h2 id=&#34;lfs-dreht-den-spieß-um&#34;&gt;
    &lt;a href=&#34;#lfs-dreht-den-spie%c3%9f-um&#34;&gt;
	LFS dreht den Spieß um
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;LFS nimmt nun ein solches System mit unendlich viel Speicher und unendlich langer Laufzeit an, d.h, kümmert sich nicht um die Linearisierung von Reads, sondern lediglich noch um die Linearisierung von Writes: Das Dateisystem &lt;em&gt;hat&lt;/em&gt; kein Log, es &lt;em&gt;ist&lt;/em&gt; ein Log - ein großer Ringpuffer von Daten, bei dem die Platte von vorne nach hinten beschrieben wird und wenn man am Ende der Platte angekommen ist, fängt man von vorne an.&lt;/p&gt;
&lt;p&gt;Snapshots bekommt man bei einem solchen System gratis (Aber
&lt;a href=&#34;http://en.wikipedia.org/wiki/Log-structured_File_System_%28BSD%29&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;BSD hat es nicht implementiert&lt;/a&gt;

): Am Anfang der Platte hat man keinen Superblock, sondern einen Zeiger auf die letzten paar Superblöcke, die geschrieben wurden. Jede Operation kann als Transaktion geschrieben werden: Blöcke werden dabei nicht überschrieben, sondern geänderte Versionen des neuen Blockes werden linear rausgeschrieben.&lt;/p&gt;
&lt;p&gt;Beispiel: Eine Datei besteht aus einem Verzeichniseintrag, einer Inode und in der Inode aus Zeigern auf Datenblöcke. Überschreibt man nun das letzte KB der Datei und verlängert sie nun auch noch um ein KB, dann werden zunächst der &amp;ldquo;überschriebene&amp;rdquo; Datenblock und der neue Datenblock am Ende des Schreibpuffers neu geschrieben, dann wird die geänderte Inode der Datei dahinter neu geschrieben und dann der Block, der auf die aktuelle Version dieser Inode zeigt neu geschrieben und am Ende ein neuer Superblock.&lt;/p&gt;
&lt;p&gt;Beim Lesen folgt man dem neusten Superblock, findet man die neuste Version der Inode, und damit die geänderte und verlängerte Datei. Folgt man der älteren Kopie des Superblocks, findet man eine ältere Version der Inode derselben Datei und die dazu gehörenden älteren Versionen der Datenblöcke, also eine alte Version derselben Datei. Alle Blöcke, die zwischen beiden Versionen der Datei unverändert bleiben, sind beiden Versionen gemeinsam und nur einmal auf der Platte vorhanden.&lt;/p&gt;
&lt;h2 id=&#34;lfs-performance-stinkt&#34;&gt;
    &lt;a href=&#34;#lfs-performance-stinkt&#34;&gt;
	LFS Performance stinkt
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Nun ist es so, daß außerhalb des Googleplex RAM endlich und die Laufzeiten von Computern begrenzt sind. Daher ist es auch so, daß es zu Situationen kommen kann, in denen der File System Buffer Cache das aus Lesesicht absolut pessimale Layout von LFS nicht abschirmen kann. In solchen Fällen - die besonders von Datenbanken gerne provoziert werden - ist die Performance von LFS nur mit geologischen Fachbegriffen zu erfassen.&lt;/p&gt;
&lt;p&gt;Schon LFS auf Sprite, und sein späterer Port auf BSD Unix haben daher einen Repacker gehabt. Das ist ein Prozeß der Idlezeiten der Platte nutzt und die Daten auf dem Medium ein wenig read-freundlicher anordnet. Man kann sich das wie eine dauernd laufende Defragmentierung im Hintergrund vorstellen. Auch ReiserFS 4, das auf ähnlichen Ideen basiert hat einen solchen Repacker.&lt;/p&gt;
&lt;h2 id=&#34;in-with-the-out-old-with-the-new&#34;&gt;
    &lt;a href=&#34;#in-with-the-out-old-with-the-new&#34;&gt;
	In with the out, old with the new
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Die Idee, Daten niemals zu überschreiben ist sicherlich gut. Sie läßt sich jedoch auch mit Dateisystemen implementieren, die Daten gleich beim ersten Schreiben sinnvoll auf der Platte layouten ohne dabei eine Ringpuffer-Struktur zu erzeugen.&lt;/p&gt;
&lt;p&gt;Dateisysteme wie
&lt;a href=&#34;http://en.wikipedia.org/wiki/Write_Anywhere_File_Layout&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;WAFL&lt;/a&gt;

 auf einer NetAPP sind ein erster Schritt in diese Richtung, Suns
&lt;a href=&#34;http://en.wikipedia.org/wiki/ZFS&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ZFS&lt;/a&gt;

 geht ihn noch konsequenter. Beide Dateisysteme stammen aus Projekten, in denen Leute arbeiten, die vorher mit verschiedenen Versionen von LFS gearbeitet haben. Insofern ist es auch nicht weiter verwunderlich, daß solche Ideen in diesen Dateisystemen auftauchen - &lt;a href=&#34;http://www.sun.com/lawsuit/zfs/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;außer man ist Patentanwalt&lt;/a&gt;

 und wundert sich aus beruflichen Gründen.&lt;/p&gt;
&lt;p&gt;Solche Dateisysteme, die nie überschreiben (und daher laufend snapshotten), aber die Platte nicht als Ringpuffer betrachten sondern schon noch layouten, nennt man Copy-On-Write Dateisysteme (COW-FS).&lt;/p&gt;
&lt;h2 id=&#34;weitere-gute-ideen-importieren&#34;&gt;
    &lt;a href=&#34;#weitere-gute-ideen-importieren&#34;&gt;
	Weitere gute Ideen importieren
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;ZFS ist in diesem Zusammenhang besonders interessant, weil es noch weitere gute Ideen von anderswo importiert. &lt;a href=&#34;http://en.wikipedia.org/wiki/Episode_filesystem&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Episode&lt;/a&gt;

 zum Beispiel ist das Dateisystem der halb vergessenen DCE-Initiative, und vielen Leuten in der Geschmacksrichtung &lt;a href=&#34;http://en.wikipedia.org/wiki/AdvFS&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;AdvFS&lt;/a&gt;

 von DEC bekannt.&lt;/p&gt;
&lt;p&gt;AdvFS integriert das Storagemangement, das sonst von einem Logical Volume Manager erledigt wird und das Platzmanagement des Dateisystems ineinander. Eine File Domain kann man sich dabei wie eine Volume Group vorstellen - eine Art Kiste, in der die Blöcke enthalten sind, die beschrieben werden können.&lt;/p&gt;
&lt;p&gt;In der File Domain sind File Sets vorhanden, Dinge, die man anderswo Dateisysteme nennt. File Sets ist dabei nicht zwingend eine feste Größe zugewiesen - man kann sie sich wie Luftballons vorstellen, die in der Kiste sind und die nach bedarf aufgeblasen und verkleinert werden können. Mit einem Quota-System kann man einem File Set einen Mindestplatzbedarf und einen Maximalbedarf zuordnen und so den Platz in der File Domain verwalten. Der &lt;a href=&#34;http://advfs.sf.net/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;AdvFS-Source&lt;/a&gt;

 ist seit 2008 GPLed, aber er interessiert kaum noch jemanden.&lt;/p&gt;
&lt;p&gt;ZFS hat wie AdvFS diese Integration von Volume Management in das Dateisystem übernommen - etwas, das auf den Linux-Kernel-Mailinglisten von einigen Personen als &lt;a href=&#34;http://www.google.de/search?q=blatant&amp;#43;layering&amp;#43;violation&amp;amp;ie=utf-8&amp;amp;oe=utf-8&amp;amp;aq=t&amp;amp;rls=org.mozilla:en-US:official&amp;amp;client=firefox-a&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;blatant layering violation&lt;/a&gt;

 angesehen wurde - die Redewendung hat es zu einigem Google-Karma gebracht. Tatsächlich handelt es sich um eine andere Sicht auf den Stack, aber eine, die durchaus von anderen geteilt wird, die wie man an AdvFS sehen kann und die durchaus interne Struktur hat.&lt;/p&gt;
&lt;p&gt;Eine andere gute Idee, die ZFS aus der Datenbankwelt übernommen hat, sind Prüfsummen überall. Auf diese Weise - und nur auf diese Weise - ist es möglich, die Integrität des Dateisystems Ende-zu-Ende sicherzustellen und vor allen Dingen auch integre Teile des Systems zur Verfügung zu stellen, während man beschädigte Teile isoliert und abtrennt. Der ZFS-Code kann es nicht, aber grundsätzlich ist es möglich aus jedem defekten ZFS ein integres Sub-ZFS raus zu extrahieren und zu publizieren, während der Rest anderweitig recovered wird - die Datenstrukturen geben das her.&lt;/p&gt;
&lt;h2 id=&#34;open-source-management&#34;&gt;
    &lt;a href=&#34;#open-source-management&#34;&gt;
	Open Source Management
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Nun hat Sun ein sehr sauberes und durchaus &lt;a href=&#34;http://en.wikipedia.org/wiki/CDDL&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;politisches-strategisches Intellectual Property Management&lt;/a&gt;

. Das bewirkt, daß der Source von ZFS unter der &lt;a href=&#34;http://en.wikipedia.org/wiki/CDDL&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CDDL&lt;/a&gt;

 (&amp;ldquo;cuddle&amp;rdquo;, eine modifizierte MPL 1.1) verfügbar ist - er ist Teil von Opensolaris, FreeBSD, MacOS X und einigen anderen Systemen. Die CDDL verletzt aber die additional restrictions clause der GPL und ist mit der GPL nicht kompatibel - es wäre zwar technisch möglich einen Linux-Kernel zu bauen, der ZFS enthielte, aber es ist keinem Distributionshersteller juristisch möglich so etwas zu verteilen. ZFS läuft daher unter Linux nur als Userland-Prozeß als Teil von &lt;a href=&#34;http://en.wikipedia.org/wiki/Filesystem_in_Userspace&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;FUSE&lt;/a&gt;

.&lt;/p&gt;
&lt;h2 id=&#34;cow-fs-in-linux---btrfs&#34;&gt;
    &lt;a href=&#34;#cow-fs-in-linux---btrfs&#34;&gt;
	COW-FS in Linux - BTRFS
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Die Linux-Crowd ficht das nicht an. Im Linux-Kernelspace entwickelt man seit einiger Zeit an einem Nachfolger für die extX-Reihe von Dateisystemen, und einer der Kandidaten für eine solche Nachfolge ist &lt;a href=&#34;http://btrfs.wiki.kernel.org/index.php/Main_Page&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;BTRFS&lt;/a&gt;

 (&amp;lsquo;ButterFS&amp;rsquo;, nicht etwa &amp;lsquo;BetterFS&amp;rsquo;). Die Featureliste von BTRFS liest sich wie eine Shoppingliste in den Stammbäumen der oben genannten Ahnherrschaften: Extent-Based wie ext4 und XFS statt Bitmaps wie ext3 und ZFS, Tail-Packing wie bei Reiser3 und Reiser4, Verzeichnisse als Bäume wie inzwischen allgemein üblich, dynamisch erzeugte Inodes, wie sich fast zwingend aus COW-FS-Erfordernissen ergibt, writeable-snapshots, subvolumes (File Sets aus AdvFS), Object Level Mirroring und Striping, Checksums on Everything, Compression (und sicher auch Encryption), Integrated Multiple Device Support (besagte blatant layering violation), Online Filesystem Check (o.a. Teilvalidierung) und Online System Defragmentation (ein Repacker und die Möglichkeit des Online Filesystem Checks machen das leicht).&lt;/p&gt;
&lt;p&gt;Die BTRFS-Leute ziehen dabei ein paar echt eklige, aber vollkommen legale Stunts ab. In &lt;a href=&#34;http://btrfs.wiki.kernel.org/index.php/Conversion_from_Ext3&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Conversion from ext3&lt;/a&gt;

 wird gezeigt, wie die Metadatenstrukturen von BTRFS in ein existierendes ext3 reingemalt werden können ohne das ext3 zu beschädigen und wie kurzzeitig beide Systeme parallel existieren und die Datenblöcke teilen können. Das erlaubt eine Konvertierung von extX-Dateisystemen in BTRFS ohne Neuformatierung - ein echtes Killerfeature für Leute mit einem Arsch voll Linux-Daten.&lt;/p&gt;
&lt;p&gt;Einen schönen Überblick über die BTRFS-Strukturen findet man im &lt;a href=&#34;http://btrfs.wiki.kernel.org/index.php/Btrfs_design&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Design Dokument&lt;/a&gt;

. Zum Thema &lt;a href=&#34;http://btrfs.wiki.kernel.org/index.php/Multiple_Device_Support&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Multiple Device Support&lt;/a&gt;

 gibt es ebenfalls Seiten. Und eine Einführung in den Code gibt es auch - &lt;a href=&#34;http://btrfs.wiki.kernel.org/index.php/Code_documentation&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;hier&lt;/a&gt;

.&lt;/p&gt;
&lt;p&gt;BTRFS ist unter der GPL lizensiert, kompatibel mit dem Linux-Kernel und Bestandteil aktueller Standardkernel. Die gestern freigegebene &lt;a href=&#34;http://btrfs.wiki.kernel.org/index.php/Code_documentation#Sample_Item_Insertion&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Fedora 11 Alpha&lt;/a&gt;

 enthält BTRFS als experimentelles Dateisystem - gut genug zum Spielen und Testen, aber noch nicht gut genug für Wirkdaten.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Was bringt ext4?</title>
      <link>https://blog.koehntopp.info/2009/01/23/was-bringt-ext4.html</link>
      <pubDate>Fri, 23 Jan 2009 19:14:35 +0000</pubDate>
      
      <guid>https://blog.koehntopp.info/2009/01/23/was-bringt-ext4.html</guid>
      <description>&lt;p&gt;Der Linux-Kernel 2.6.28 enthält das ext4-Dateisystem standardmäßig und sowohl Fedora als auch Ubuntu werden es unterstützen. Was bringt ext4 an Änderungen?&lt;/p&gt;
&lt;p&gt;Ein Dateisystem ist für die meisten Benutzer eine quasi unsichtbare Sache. Es sind halt Dateien da und wenn man auf diese zugreift hat man halt Daten. So sind Dateisystem-Features für die meisten Leute also eine sehr unspektakuläre Sache. Die folgende Übersicht ist also etwas geekzentrisch.&lt;/p&gt;
&lt;h2 id=&#34;extents&#34;&gt;
    &lt;a href=&#34;#extents&#34;&gt;
	Extents
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;ext2 und ext3 sind sehr traditionelle Dateisysteme, die intern im Grunde auf Technik von 1984 basieren. ext2 ist eine minimal verbessere Nachprogrammierung des BSD ffs (bei Sun und MacOS X: ufs), ext3 fügt dem lediglich das Journal zur schnelleren Wiederherstellung nach Systemcrashes zu. Beide Dateisysteme speichern die Metadaten von Dateien in einer Inode ab und merken sich die Lage der Datenblöcke in einer Datei in einem (in sogenannten Indirect-Blocks gefalteten) Array von Blocknummern. In einem Artikel von 1994 habe ich das mal &lt;a href=&#34;http://kris.koehntopp.de/artikel/dateisysteme/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;länger ausgeführt&lt;/a&gt;

.&lt;/p&gt;
&lt;p&gt;Da mit einigem Glück die meisten Dateien nicht fragmentiert gespeichert sind, besteht dieses Array also bei vielen Dateien aus einer langen Folge von unmittelbar aufeinander folgenden Blocknummern. Das ist unglaublich ineffizient.&lt;/p&gt;
&lt;p&gt;XFS, also Technik von 1994, ist eines der ersten Dateisysteme gewesen, das stattdessen mit Extents arbeitet, also Blockfolgen durch Run Length Encoding komprimiert: Statt einer Folge von Blocknummern wird die Startnummer der Folge und ihre Länge als ein Paar gespeichert. 15 Jahre später führt man dieses Detail auch in ext4 endlich ein.&lt;/p&gt;
&lt;h2 id=&#34;große-dateisysteme&#34;&gt;
    &lt;a href=&#34;#gro%c3%9fe-dateisysteme&#34;&gt;
	Große Dateisysteme
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Eine andere Technik von XFS kopiert man dabei nicht: Kompression von Blocknummern. ext4 unterstützt große Dateisysteme durch den Einsatz von 64 Bit großen Blocknummern. Da die Kernel-Infrastruktur noch nicht entsprechend mitgewachsen ist, sind derzeit 48 Bit große Blocknummern nutzbar, was für immerhin schon Exabyte-große Dateisysteme ausreicht. Anders als XFS, das ebenfalls ein 64 Bit-Dateisystem ist, speichert ext4 jedoch immer ganze 8 Byte große Blocknummern, während XFS auch relative Blockadressen zum Beginn jeweils einer Zone verwenden kann und so an vielen Stellen mit 4 Byte langen Zahlen auskommt, auch wenn es 64 Bit adressieren kann.&lt;/p&gt;
&lt;p&gt;Weil ext2 und ext3 im Grunde saubere Rewrites von FFS waren, haben sie auch die 16 Bit große Linkcount-Zahl von diesem geerbt und konnten so bis zu 32767 Links pro Datei verwalten. Da Unterverzeichnisse durch den &amp;ldquo;..&amp;quot;-Eintrag den Linkcount des Elternverzeichnisses erhöhen, war man so auf 32765 Unterverzeichnisse pro Directory beschränkt. ext4 geht hier anders vor und das Limit existiert nicht mehr.&lt;/p&gt;
&lt;h2 id=&#34;neues-blockbelegungsschema&#34;&gt;
    &lt;a href=&#34;#neues-blockbelegungsschema&#34;&gt;
	Neues Blockbelegungsschema
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Jedes Dateisystem hat Funktionen mit denen es entscheidet auf welchen physischen Blöcken der Platte eine Datei zu liegen kommt. Ziel diese Allokators ist es dabei, die Fragmentierung von Dateien zu verhindern und die Dateien so anzuordnen, daß schnell lesen darauf zugegriffen werden kann.&lt;/p&gt;
&lt;p&gt;Der Allkokator von ext2 und ext3 ist dabei notorisch schlecht. Zum einen beherrschen diese Dateisyteme keine verzögerte Blockzuweisung: Jeder Block einer Datei muß physikalisch angeordnet werden sobald der Kernel Platz für den Block im File System Buffer Cache belegt. Wenn also eine große Datei linear geschrieben wird bedeutet das, daß das Dateisystem schon versucht den ersten Block der Datei zu positionieren ohne abzuwarten ob und wie viele weitere Blöcke noch folgen werden.&lt;/p&gt;
&lt;p&gt;XFS hatte schon 1994 eine bessere Strategie: Blöcke werden im File System Buffer Cache auch ohne physikalische Positionsinformation gecached. Dadurch kann etwa ein linearer Write einer ganzen Datei erst einmal im Cache abgelegt werden und erst am Ende, wenn die Datei geschlossen und geflushed wird, muß eine Layoutentscheidung getroffen werden. Diese kennt dann aber schon die Gesamtgröße der Datei und das Dateisystem kann versuchen die Datei am Stück zu schreiben. ext4 kann nun endlich auch solche delayed allocation und reiht sich so neben XFS, ZFS, btrfs und Reiser4 ein.&lt;/p&gt;
&lt;p&gt;ext2 und ext3 belegten dabei den Platz auf der Platte einzelblockweise (in 4KB großen Blöcken) und haben dabei maximal 8 Blocks in Folge im Voraus belegt. Wenn man also ein Verzeichnis hat, in dem zwei Dateien gleichzeitig offen sind und verlängert werden (etwa: /var/log), dann entstehen so Zonen von jeweils 32 KB großen Dateistummeln, die sich gegenseitig im Weg stehen. Die Dateien sind maximal fragmentiert. ext4 fixt das dann auch in der ext?-Serie von Dateisystemen endlich.&lt;/p&gt;
&lt;p&gt;ext4 bekommt außerdem ein Feature, das sich &amp;ldquo;persistent preallocation&amp;rdquo; nennt und das es Anwendungen erlaubt, dem Dateisystem schon vorab Hinweise darauf zu geben wie groß Dateien am Ende sein werden wenn die Anwendung mit ihnen fertig sein wird. Die Anwendungen dafür sind vielfältig: Mit ein wenig Management ließe sich so zum Beispiel das Guaranteed Rate I/O von XFS nachprogrammieren und ext4 kennt mit diesem Feature und ein wenig weiterer Magie auch Online-Defragmentierung.&lt;/p&gt;
&lt;h2 id=&#34;schnelleres-fsck-und-prüfsummen&#34;&gt;
    &lt;a href=&#34;#schnelleres-fsck-und-pr%c3%bcfsummen&#34;&gt;
	Schnelleres fsck und Prüfsummen
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;So wie ZFS und InnoDB es vorgemacht haben führt auch ext4 nun endlich Prüfsummen ein: Das Journal und Teile der Inode-Infrastruktur bekommen nun Prüfsummen, mit denen die Integrität der Daten nach einem Crash schneller gecheckt werden kann, sodaß der fsck optimiert werden kann und schneller abläuft wenn er dennoch einmal notwendig werden sollte. Dadurch kann auch der Journal-Commit selbst optimiert werden.&lt;/p&gt;
&lt;p&gt;Von einer durchgehenden Prüfsummen-Infrastruktur wie in ZFS und einer Online-Prüfung von Checksummen ist man in ext4 jedoch noch weit entfernt.&lt;/p&gt;
&lt;h2 id=&#34;inode-basteleien&#34;&gt;
    &lt;a href=&#34;#inode-basteleien&#34;&gt;
	Inode-Basteleien
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Die Größe einer Inode ist in ext4 gewachsen: 256 Byte Minimumgröße statt bisher 128 Bytes. ext4 macht mit dem zusätzlichen Platz sinnvolle Sachen: Dateien bekommen Timestamps, die in Nanosekunden statt wie bisher in Sekunden rechnen, time_t stirbt und der verbleibende Platz kann verwendet werden um Extentlisten oder erweiterte Dateiattribute inline zu speichern.&lt;/p&gt;
&lt;p&gt;Außerdem kann ext4 Inodes reservieren und dynamisch verwalten. Dadurch werden auch Metadata-Operationen sehr viel schneller und layouten sich besser physikalisch auf der Platte.&lt;/p&gt;
&lt;h2 id=&#34;barrier-writes&#34;&gt;
    &lt;a href=&#34;#barrier-writes&#34;&gt;
	Barrier Writes
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Schließlich erzeugt auch ext4 nun ohne Journal=Data immer konsistente Datenstrukturen auf der Platte, indem Barrier Writes verwendet werden.&lt;/p&gt;
&lt;h2 id=&#34;live-upgrade&#34;&gt;
    &lt;a href=&#34;#live-upgrade&#34;&gt;
	Live Upgrade
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;ext4 kann ext3-Dateisysteme lesen. Es ist also möglich, ein ext3-Dateisystem als ext4 zu mounten. Die meisten Features, die ein ext4 einem ext3 voraus hat, sind dabei jedoch nicht nutzbar. Auch ein&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;go&#34;&gt;tune2fs -O extents,uninit_bg,dir_index /dev/DEV
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;fsck -pf /dev/DEV
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;schaltet diese Features nur für neue Dateien um, baut aber die vorhandenen Dateien und Verzeichnisse nicht auf das neue Format um. Die volle Effizienzsteigerung erlangt man also nur durch ein Umkopieren der Daten auf ein neue angelegtes, leeres ext4-Dateisystem.&lt;/p&gt;
&lt;h2 id=&#34;was-fehlt-noch&#34;&gt;
    &lt;a href=&#34;#was-fehlt-noch&#34;&gt;
	Was fehlt noch?
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Grub unterstützt ext4 bisher noch nicht (d.h. die Grubs, die das können, haben es noch in keine Distro geschafft).&lt;/p&gt;
&lt;p&gt;(siehe auch:
&lt;a href=&#34;http://kernelnewbies.org/Ext4&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kernelnewbies: ext4&lt;/a&gt;

)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Historische Kernelsourcen</title>
      <link>https://blog.koehntopp.info/2008/05/27/historische-kernelsourcen.html</link>
      <pubDate>Tue, 27 May 2008 08:08:46 +0000</pubDate>
      
      <guid>https://blog.koehntopp.info/2008/05/27/historische-kernelsourcen.html</guid>
      <description>&lt;p&gt;In anderen Artikeln habe ich ja schon an Hand von &lt;a href=&#34;http://lxr.linux.no/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;http://lxr.linux.no/&lt;/a&gt;

 Strukturen im Linux-Kernel referenziert und in Erklärungen verwendet.&lt;/p&gt;
&lt;p&gt;Auf &lt;a href=&#34;http://www.tamacom.com/tour.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Tamacom&lt;/a&gt;

 gibt es zum Vergleich die Quellen von Linux 2.6, FreeBSD 7, NetBSD 4.x, OpenBSD 4.x, GNU Hurd 0.3 und OpenSolaris zum verlinken. Auch liegen dort ein UNIX V7 Kernel und ein 4.3BSD rum.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://minnie.tuhs.org/UnixTree/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Minnie&lt;/a&gt;

 hat eine schöne Sequenz wirklich alter Unix-Trees, der die Entwicklung der 70er Jahre und einige BSD-Trees miteinander vergleicht. Das älteste nützliche Zeugs von dort ist &lt;a href=&#34;http://minnie.tuhs.org/UnixTree/Nsys/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;von 1973&lt;/a&gt;

.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The nsys files are timestamped August 31, 1973. This is consistent with other known dates. The files use structs, but in December 1972 the C compiler didn&amp;rsquo;t support structs. In September 1973, the C version of the kernel finally supplanted the assembly version, and the kernel here certainly works fine.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Mit anderen Worten, wir schauen hier der gleichzeitigen Entstehung der Sprache C und des Unix-Kernels zu. So kennt der V3 Kernel &lt;a href=&#34;http://minnie.tuhs.org/UnixTree/V3/usr/man/man2/stat.2.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;noch keine GID&lt;/a&gt;

 im stat(2) Systemaufruf, und der Compiler kann noch keine &amp;ldquo;struct&amp;rdquo; - im nsys-Kernel 6 Monate später existieren beide - und andere wichtige Erfindungen werden gemacht.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://minnie.tuhs.org/UnixTree/Nsys/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Goldenes Zitat&lt;/a&gt;

:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The number of UNIX installations is now above 20&amp;hellip;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>fork und exec vs. CreateProcess</title>
      <link>https://blog.koehntopp.info/2007/01/07/fork-und-exec-vs-createprocess.html</link>
      <pubDate>Sun, 07 Jan 2007 09:06:13 +0000</pubDate>
      
      <guid>https://blog.koehntopp.info/2007/01/07/fork-und-exec-vs-createprocess.html</guid>
      <description>&lt;p&gt;&lt;strong&gt;Disclaimer:&lt;/strong&gt; Meine Windows-Kenntnisse sind beschränkt, veraltet und ausschließlich theoretischer Natur. Im Zweifel erzählt dieser Artikel Unsinn nach Hörensagen.&lt;/p&gt;
&lt;p&gt;Nach dem Artikel &lt;a href=&#34;https://blog.koehntopp.info/2007/01/07/fork-exec-wait-und-exit.html&#34;&gt;form, exec, wait und exit&lt;/a&gt;

 habe ich mir aber einmal meine Kopie von Jeffrey Richters &lt;a href=&#34;http://www.amazon.de/Microsoft-Windows-Programmierung-fuer-Experten/dp/3860633899/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Windows - Programmierung für Experten (Advanced Windows)&lt;/a&gt;

 (1997) gegriffen und dort nachgeschlagen, wie man sich das mit den Prozessen und Programmen unter Windows vorstellt (oder jedenfalls vor 10 Jahren vorgestellt hat).&lt;/p&gt;
&lt;p&gt;Windows hat zu diesem Zweck die Systemfunktion &lt;a href=&#34;http://msdn.microsoft.com/library/default.asp?url=https://blog.koehntopp.info/library/en-us/dllproc/base/createprocess.asp&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CreateProcess&lt;/a&gt;

(10 Parameters). Die liest sich so:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;BOOL WINAPI CreateProcess(  LPCTSTR lpApplicationName,  LPTSTR lpCommandLine,  LPSECURITY_ATTRIBUTES lpProcessAttributes,  LPSECURITY_ATTRIBUTES lpThreadAttributes,  BOOL bInheritHandles,  DWORD dwCreationFlags,  LPVOID lpEnvironment,  LPCTSTR lpCurrentDirectory,  LPSTARTUPINFO lpStartupInfo,  LPPROCESS_INFORMATION lpProcessInformation);&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Die Funktion erzeugt einen neuen Prozeß und lädt in diesen ein neues Programm. Dieses wird dann gestartet. lpApplicationName ist der Pfadname des auszuführenden Programmes.&lt;/p&gt;
&lt;p&gt;lpCommandLine ist die Kommandozeile (der argv) des neuen Programmes. Sie wird als String und nicht als Vektor von Strings übergeben. Das Parsen der Kommandozeile in Wort wird also durch das Betriebssystem übernommen und kann nicht durch den Aufrufer kontrolliert werden. In Unix muß man bei execve() einen Vektor von Strings übergeben, das Zerlegen der Kommandozeile in Worte muß also durch den Aufrufer, z.B. die Shell übernommen werden. Die anderen Funktionen der exec-Familie sind Bibliotheksfunktionen, die einem hier einen Teil der Arbeit abnehmen.&lt;/p&gt;
&lt;p&gt;lpApplicationName und lpCommandLine interagieren: lpApplicationName darf NULL sein, dann wird das erste Wort von lpCommandLine nach der Zerlegung in Worte als lpApplicationName interpretiert. lpApplicationName darf ohne Endung angegeben werden, dann rät Windows die Extension bzw. probiert eine Liste von ausführbaren System-Extensions aus.&lt;/p&gt;
&lt;p&gt;lpApplicationName darf auch ein unqualifizierter Pfadname sein. In diesem Fall wird das Absuchen eines System-Suchpfades wird durch diese Funktion von Windows übernommen. In Unix führt execve() genau das Binary aus, dessen Pfadnamen man angegeben hat. Will man einen Suchpfad absuchen, muß man execve() in einer Schleife so lange ausführen, bis es nicht mehr zurück kommt.&lt;/p&gt;
&lt;p&gt;lpProcessAttributes ist kein einzelner Parameter, sondern ein Zeiger auf eine &lt;a href=&#34;http://msdn2.microsoft.com/en-us/library/aa379560.aspx&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SECURITY_ATTRIBUTES&lt;/a&gt;

-Struktur, die man ausfüllen kann und die viele Parameter enthalten kann. Die Struktur enthält eine ACL für die Discretionary Access Control, bestimmt also im wesentlichen, wer diesen Prozeß anfassen und was mit ihm machen darf. In Unix gibt es kein vergleichbares Konzept für Prozesse: Ein Prozeß hat entweder die entsprechende Capability (etwa CAP_KILL oder CAP_SYS_PTRACE) oder nicht.&lt;/p&gt;
&lt;p&gt;lpThreadAttributes erzeugt ist der passende Parameter für den in dem Prozeß zwingend enthaltenen Thread. bInheritHandles definiert, ob vererbbare Handles auf Objekte von dem neu erzeugten Prozeß geerbt werden.&lt;/p&gt;
&lt;p&gt;dwCreationFlags legt die Priorität des Prozesses und &lt;a href=&#34;http://msdn2.microsoft.com/en-us/library/ms684863.aspx&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;weitere Flags&lt;/a&gt;

 für den neuen Prozeß fest. In Unix würde man all dies zwischen dem fork() und dem exec() mit einzelnen Calls machen, etwa mit Calls aus der setpriority()-Familie oder mit Aufrufen nach setpgrp().&lt;/p&gt;
&lt;p&gt;lpEnvironment entspricht konzeptuell, aber nicht im Format dem envp von execve.&lt;/p&gt;
&lt;p&gt;lpCurrentDirectory ist das aktuelle Verzeichnis des neuen Prozesses. In Unix würde man den identischen Effekt erreichen, indem man zwischen dem fork() und dem exec()-Systemaufruf ein chdir() (oder chroot()) aufruft.&lt;/p&gt;
&lt;p&gt;lpStartupInfo ist ein Zeiger auf eine eine Struktur &lt;a href=&#34;http://msdn2.microsoft.com/en-us/library/ms686331.aspx&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;STARTUPINFO&lt;/a&gt;

, die keine Entsprechung in Unix hat, weil hier Dinge angegeben werden, die mit den Fenstern einer Anwendung zu tun haben. Unix handhabt diese Dinge komplett vom Betriebssystemkern getrennt und daher finden wir in den Betriebssystem-Primitiven zu Prozessen keine Fensterinformationen. Genaugenommen ist lpStartupInfo entweder ein Zeiger auf eine STARTUPINFO oder STARTUPINFOEX-Struktur. Was es genau ist wird mit einem Flag in dwCreationFlags angegeben. Das ist nicht typsicher, und das ist bemerkenswert, weil Windows an anderer Stelle sehr viel Wert auf solche Dinge legt.&lt;/p&gt;
&lt;p&gt;Der letzte Parameter von CreateProcess, lpProcessInformation, ist ein Referenzparameter auf eine &lt;a href=&#34;http://msdn2.microsoft.com/en-us/library/ms684873.aspx&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;PROCESS_INFORMATION&lt;/a&gt;

-Struktur, die von Windows überschrieben und ausgefüllt wird. Wir finden dort die Handles zu unserem Prozeß und dem darin enthaltenen Thread sowie eine ProcessId und eine ThreadId.&lt;/p&gt;
&lt;p&gt;Will man das Äquivalent zu einem setuid()-Eignerwechsel in Unix in Windows durchführen, kommt dieses Konzept an seine Grenzen - so etwas ist trotz der Vielzahl der Parameter von CreateProcess() in Windows nicht vorgesehen. Man braucht eine neue Funktion, &lt;a href=&#34;http://msdn2.microsoft.com/en-us/library/ms682429.aspx&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CreateProcessAsUser&lt;/a&gt;

(11 Parameter).&lt;/p&gt;
&lt;h2 id=&#34;analyse&#34;&gt;
    &lt;a href=&#34;#analyse&#34;&gt;
	Analyse
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Hier wird der grundlegende Unterschied zwischen den Konzepten von Windows und Unix deutlich: Die Unix-API stammt von Mitte der 70er Jahre und hat sich in den vergangenen mehr als 30 Jahren nicht wesentlich verändert.&lt;/p&gt;
&lt;p&gt;Sie genügt heutigen Ansprüchen, weil sie alle Ansprüche nicht erfüllt - sie liefert stattdessen relativ atomare primitive Funktionen und trennt sogar auf den ersten, flüchtigen Blick zusammengehörende Dinge wie Erzeugen von Prozessen und Laden von Programmen. Dadurch muß ein Programmierer einer Anwendung entweder eine Bibliotheksfunktion verwenden, die fork() und exec() in etwas bequemeres einpackt (etwa system() oder popen()) oder all die Dinge selber machen, die Windows im Kernel für den Programmierer erledigt. fork() hat keine Parameter und execve() hat deren drei.&lt;/p&gt;
&lt;p&gt;Will man mehr, hat man die Gelegenheit, das Environment des neuen Prozesses nach dem fork() vor dem Start des neuen Programmes mit execve() von innen zu verändern.&lt;/p&gt;
&lt;p&gt;Windows dagegen erzeugt eine alles-in-einem Funktion, die für den häufigen Anwendungsfall und alle denkbaren Varianten Extraparameter hat. Windows hat dabei die Sicht von außen auf den Kindprozeß. Dies führt zu nützlichen Dingen wie einer Thread- und Prozeß DACL, ist aber konzeptuell nicht gut erweiterbar. Dinge wie ein setuid()-Aufruf zwischen fork() und exec() sind mit CreateProcess() nicht abbildbar und machen weitere Funktionen erforderlich, die noch mehr Parameter haben.&lt;/p&gt;
&lt;p&gt;Das Konzept von Unix ist auf den ersten Blick umständlich und wenig intuitiv. Es genügt von der Aufteilung her jedoch den Ansprüchen, die man als Datenbanker an eine Normalform hätte und ist daher flexibel und ohne Änderungen am Kern erweiterbar - unabhängige Konzepte sind als unabhängige Funktionen implementiert und Erweiterung erfolgt durch Einschieben weiterer Aufrufe zwischen fork() und exec(). Neben dem Vorteil der Erweiterbarkeit hat dies den Nachteil, daß mehr Systemaufrufe notwendig sind als bei Windows (Unix-Systemaufrufe müssen schnell sein, damit dieses Konzept aufgeht) und daß man unter Umständen ein Problem mit der Atomizität bekommen kann.&lt;/p&gt;
&lt;p&gt;Beispiel ist hier die Aufgabe: &amp;ldquo;Starte aus einem Debugger einen Programm in einem Kindprozeß und zwar so, daß der Kindprozeß ohne Racecondition auf der ersten Anweisung des Kindes stoppt und debugbar ist.&amp;rdquo;. Das Problem war lange Zeit nicht lösbar, und wurde von Linux durch das PTRACE_TRACEME-Flag zu ptrace() gelöst, das neben einigen anderen Dingen bewirkt, daß ein Kindprozeß nach einem execve() erst mal mit einem SIGTRAP stehen, bleibt bevor er irgendwas selber macht. Bemerkenswert ist, daß die Erweiterung möglich war, ohne das bestehende 30 Jahre alte Konzept von fork, exec und wait verändern zu müssen.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>fork, exec, wait und exit</title>
      <link>https://blog.koehntopp.info/2007/01/07/fork-exec-wait-und-exit.html</link>
      <pubDate>Sun, 07 Jan 2007 01:09:00 +0000</pubDate>
      
      <guid>https://blog.koehntopp.info/2007/01/07/fork-exec-wait-und-exit.html</guid>
      <description>&lt;p&gt;In
&lt;a href=&#34;news:de.comp.os.unix.linux.misc&#34;&gt;de.comp.os.unix.linux.misc&lt;/a&gt;

 fragte jemand:&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Werden in einem Skript die Befehle streng sequentiell ausgeführt, d.h.
der nächste erst bearbeitet, wenn der Vorgänger vollständig ausgeführt
ist, oder wird &lt;strong&gt;automatisch&lt;/strong&gt; bei unvollständiger Auslastung des
Systems bereits der nächste Befehl angefangen?&lt;/li&gt;
&lt;li&gt;Läßt sich das Standardverhalten - wie auch immer es sein mag - bei
Bedarf ändern?&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;Wenn man in ein Shellbuch schaut, wird einem an der einen oder anderen
Stelle möglicherweise erläutert, daß die Shell jeden Befehl in einem eigenen
Prozeß abarbeitet. Dann wiederum fängt man möglicherweise an zu denken und
fragt sich, wie das alles zusammenhängt. Sobald man dort angekommen ist,
kann man sich mit dem Unix-Prozeßzyklus beschäftigen.&lt;/p&gt;
&lt;h2 id=&#34;prozeß-und-programm&#34;&gt;
    &lt;a href=&#34;#proze%c3%9f-und-programm&#34;&gt;
	Prozeß und Programm
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Ein Programm ist in Unix eine Serie von ausführbaren Maschineninstruktionen
auf der Platte. Man kann mit dem Befehl &lt;em&gt;size&lt;/em&gt; einen sehr oberflächlichen
Blick auf die Struktur des Programmes werfen oder mit &lt;em&gt;objdump&lt;/em&gt; sehr viel
mehr Detailinformation bekommen. Der Aspekt, der uns hier interessieren
soll: Ein Programm ist eine Folge von Anweisungen und Daten (auf der
Platte), die möglicherweise einmal ausgeführt werden.&lt;/p&gt;
&lt;p&gt;Ein Prozeß ist ein in Ausführung befindliches Programm. Er besteht aus dem
Programm selbst (also der Versammlung von Anweisungen und Daten) und dem
aktuellen Zustand der Ausführung. Dazu gehört neben der Memory-Map, die sagt
wie das Programm und seine Daten im Speicher angeordnet sind auch der
Programmzähler, die Prozessorregister und der Stack des Prozesses, aber auch
sein Root-Directory, sein aktuelles Verzeichnis, die Umgebungsvariablen und
alle offenen Dateien sowie einigen weiteren Dingen.&lt;/p&gt;
&lt;p&gt;Unix behandelt Prozesse und Programme als die verschiedenen Dinge, die es
sind: Es ist möglich, ein Programm mehr als einmal auszuführen - es ist zum
Beispiel möglich, mehr als eine Kopie des Texteditors vi offen zu haben, die
zwei unterschiedliche Texte bearbeiten. Programm und (initiale) Daten beider
Prozesse sind gleich, aber der Zustand beider Prozesse ist verschieden. Es
ist auch möglich, im selben Prozeß nacheinander mehr als ein Programm
auszuführen - dazu schmeißt sich das aktuelle Programm in dem Prozeß selbst
weg und ersetzt sich durch ein zweites, in diesen Prozeß nachgeladene
Programm.&lt;/p&gt;
&lt;p&gt;Unix regelt all diese Dinge mit vier sehr einfachen Systemkonzepten -
&lt;code&gt;fork()&lt;/code&gt;, &lt;code&gt;exec()&lt;/code&gt;, &lt;code&gt;wait()&lt;/code&gt; und &lt;code&gt;exit()&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&#34;usermode-und-kernel&#34;&gt;
    &lt;a href=&#34;#usermode-und-kernel&#34;&gt;
	Usermode und Kernel
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/prozesswechsel.png&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;

&lt;/p&gt;
&lt;p&gt;Prozeßwechsel: Es wird ein Stück Prozeß 1 abgearbeitet, dann (1) auf Prozeß
2 umgeschaltet. Nach einer Weile wird (2) wieder auf Prozeß 1 zurück
geschaltet. Die Ausführung von Prozeß 1 erscheint lückenlos, erfolgt aber in
zeitlich nicht zusammenhängenden Intervallen.&lt;/p&gt;
&lt;p&gt;Wenn ein Unix-Prozeß eine Systemfunktion aufruft (und noch bei ein paar
anderen Gelegenheiten), dann verläßt der betreffende Prozeß seinen
Userkontext und betritt den privilegierten Betriebsystemkern, den Kernel.
Dort wird die aufgerufene Systemfunktion ausgeführt und danach landet jede
dieser Funktionen im Scheduler. Der Scheduler entscheidet dann, welcher
Prozeß als nächstes dran kommt und kehrt aus dem Kernel in diesen Prozeß
zurück. Das kann unser Ausgangsprozeß oder nach Entscheidung des Schedulers
ein anderer Prozeß sein.&lt;/p&gt;
&lt;p&gt;Wir halten für die Zwecke diese Textes fest: Jeder Systemaufruf wechselt vom
Userkontext in den Kernel. Der einzige Weg aus dem Kernel in einen
Userkontext führt durch den Scheduler, und dann kehren wir unter Umständen
nicht in den Ausgangsprozeß zurück. Bei jedem Systemaufruf kann ein Prozeß
also seine CPU verlieren.&lt;/p&gt;
&lt;p&gt;Das ist nicht schlimm, weil dieser andere Prozeß auch irgendwann einmal die
CPU aufgeben muß und wir dann in unseren eigenen Prozeß zurück kehren als
sei nichts gewesen.&lt;/p&gt;
&lt;p&gt;Unser Programm wird also nicht linear abgearbeitet, sondern in kurzen
linearen Segmenten, zwischen denen Pausen liegen können. In den Pausen
arbeitet die CPU an den Segmenten der anderen Prozesse, die ebenfalls
lauffähig sind.&lt;/p&gt;
&lt;h2 id=&#34;fork-und-exit&#34;&gt;
    &lt;a href=&#34;#fork-und-exit&#34;&gt;
	fork() und exit()
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;In traditionellem Unix ist der Systemaufruf &lt;code&gt;fork()&lt;/code&gt; die einzige Methode,
einen neuen Prozeß zu erzeugen. Der neue Prozeß enthält eine Kopie des
laufenden Programmes. Er hat eine neue Prozeß-ID und die Prozeß-ID des
Erzeugers ist als seine Parent Prozeß-ID (PPID) eingetragen.&lt;/p&gt;
&lt;p&gt;Im Parent-Prozeß kehrt &lt;code&gt;fork()&lt;/code&gt; mit der PID des neuen Prozesses als Ergebnis
zurück. Der neue Prozeß kehrt ebenfalls aus dem Systemaufruf &lt;code&gt;fork()&lt;/code&gt; zurück,
liefert dort aber das Resultat 0.&lt;/p&gt;
&lt;p&gt;Der Systemaufruf fork() ist also insofern besonders, als daß er einmal
betreten wird, aber zweimal verlassen wird: Einmal im Elternprozeß und
einmal im neu erzeugten Kindprozeß. &lt;code&gt;fork()&lt;/code&gt; erhöht die Anzahl der laufenden
Prozesse im System um eins.&lt;/p&gt;
&lt;p&gt;Jeder Unix-Prozeß beginnt seine Existenz also, indem er aus einem
&lt;code&gt;fork()&lt;/code&gt;-Systemaufruf spontan zurückkehrt und ein Programm ausführt, daß
eine Kopie des Elternprogrammes ist. Sein Schicksal unterscheidet sich vom
Schicksal des Elternprozesses, weil das Ergebnis des &lt;code&gt;fork()&lt;/code&gt;-Aufrufes
unterschiedlich ist (0 statt der PID des Kindes) und man dies zur
Verzweigung nutzen kann.&lt;/p&gt;
&lt;p&gt;In Code:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;pid_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

        &lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fork&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
                &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Ich bin der Kindprozess.&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
                &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Ich bin der Elternprozess, das Kind ist %d.&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
                &lt;span class=&#34;n&#34;&gt;perror&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;In fork():&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

        &lt;span class=&#34;n&#34;&gt;exit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;und&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;go&#34;&gt;kris@linux:/tmp/kris&amp;gt; make probe1
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;cc     probe1.c   -o probe1
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;kris@linux:/tmp/kris&amp;gt; ./probe1
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;Ich bin der Kindprozess.
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;Ich bin der Elternprozess, das Kind ist 16959.
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Wir vereinbaren also eine Variable &lt;code&gt;pid&lt;/code&gt; vom Typ &lt;code&gt;pid_t&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Diese Variable speichert das Ergebnis des Systemaufrufes &lt;code&gt;fork()&lt;/code&gt; und mit
Hilfe dieses Wertes aktivieren wir entweder das eine (&amp;ldquo;Ich bin der
Kindprozeß&amp;rdquo;) oder das andere (&amp;ldquo;Ich bin der Elternprozeß&amp;rdquo;) if().&lt;/p&gt;
&lt;p&gt;Starten wir das Programm, erhalten wir zwei Ausgaben. Da innerhalb eines
Prozesses nur ein Status existieren kann und nur eines der beiden if()
betreten werden kann, wir aber zwei Ausgaben erhalten haben, müssen wir zwei
Prozesse erzeugt haben.&lt;/p&gt;
&lt;p&gt;Indem wir das Ergebnis von &lt;code&gt;getpid()&lt;/code&gt; druckten, könnten wir das sogar noch
anschaulicher zeigen.&lt;/p&gt;
&lt;p&gt;Der Systemaufruf &lt;code&gt;fork()&lt;/code&gt; wird einmal betreten, aber zweimal verlassen und
erhöht die Anzahl der Prozesse im System um eins. Nach dem Ablauf unseres
Programmes ist die Anzahl der Prozesse im System aber wieder genauso hoch
wie vor dem Aufruf des Programmes. Es muß also einen weiteren Systemaufruf
geben, der die Anzahl der Prozesse im System um eins erniedrigt.&lt;/p&gt;
&lt;p&gt;Dieser Aufruf ist &lt;code&gt;exit()&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;exit()&lt;/code&gt; wird einmal betreten und nie verlassen. Er verkleinert die Anzahl
der Prozesse im System um eins. &lt;code&gt;exit()&lt;/code&gt; liefert außerdem einen Exitstatus,
den der Elternprozeß abholen kann (oder gar muß) und der ihn über das
Schicksal seines Kindes informiert.&lt;/p&gt;
&lt;p&gt;In unserem Beispiel enden alle Varianten unseres Programmes mit &lt;code&gt;exit()&lt;/code&gt; -
wir rufen &lt;code&gt;exit()&lt;/code&gt; also im Elternprozeß und im Kindprozeß auf, beenden also
zwei Prozesse. Das können wir nur deswegen tun, weil unser Elternprozeß auch
ein Kindprozeß ist und zwar ein Kind der Shell.&lt;/p&gt;
&lt;p&gt;Die Shell arbeitet also genau wie wir:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;go&#34;&gt;bash (16957) --- erzeugt durch fork() ---&amp;gt; bash (16958) --- wird zu ---&amp;gt; probe1 (16958)
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;probe1 (16958) --- erzeugt durch fork() ---&amp;gt; probe1 (16959) --&amp;gt; exit()
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;   |
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;   +---&amp;gt; exit()
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;exit()&lt;/code&gt; schließt alle Dateien und Internetverbindungen eines Prozesses,
gibt allen Speicher frei und beendet dann den Prozeß. Der Parameter von
&lt;code&gt;exit()&lt;/code&gt;, der Exitstatus, wird an den Elternprozeß zurückgegeben.&lt;/p&gt;
&lt;h2 id=&#34;wait&#34;&gt;
    &lt;a href=&#34;#wait&#34;&gt;
	wait()
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Der Kindprozeß endet durch ein exit(0). Die 0 ist der Exitstatus unseres
Programmes und steht nun zur Abholung bereit. Wir müssen im Elternprozeß den
Exitstatus abholen. Dies geschieht mit der Systemfunktion &lt;code&gt;wait()&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;In Code:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;
&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;sys/types.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;sys/wait.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;pid_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
        &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;   &lt;span class=&#34;n&#34;&gt;status&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

        &lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fork&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
                &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Ich bin der Kindprozess.&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
                &lt;span class=&#34;n&#34;&gt;sleep&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
                &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Ich bin der Kindprozess 10 Sekunden spaeter.&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
                &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Ich bin der Elternprozess, das Kind ist %d.&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
                &lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;wait&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;status&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
                &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Ende des Prozesses %d: &amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
                &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;WIFEXITED&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;status&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
                        &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Der Prozess wurde mit exit(%d) beendet.&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;WEXITSTATUS&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;status&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
                &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
                &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;WIFSIGNALED&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;status&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
                        &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Der Prozess wurde mit kill -%d beendet.&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;WTERMSIG&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;status&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
                &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
                &lt;span class=&#34;n&#34;&gt;perror&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;In fork():&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

        &lt;span class=&#34;n&#34;&gt;exit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;und&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;go&#34;&gt;kris@linux:/tmp/kris&amp;gt; make probe2
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;cc     probe2.c   -o probe2
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;kris@linux:/tmp/kris&amp;gt; ./probe2
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;Ich bin der Kindprozess.
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;Ich bin der Elternprozess, das Kind ist 17399.
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;Ich bin der Kindprozess 10 Sekunden spaeter.
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;Ende des Prozesses 17399: Der Prozess wurde mit exit(0) beendet.
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Die Variable &lt;code&gt;status&lt;/code&gt; wird dem Systemaufruf &lt;code&gt;wait()&lt;/code&gt; als Referenzparameter
mit übergeben und von diesem überschrieben. Neben dem Exitstatus finden wir
dort auch noch weitere Informationen über den Grund des Programmendes
hinterlegt. Zur Decodierung stellt das System eine Reihe von Prädikaten wie
&lt;code&gt;WIFEXITED()&lt;/code&gt; oder &lt;code&gt;WIFSIGNALED()&lt;/code&gt; zur Abfrage bereit und Extraktoren wie
&lt;code&gt;WEXITSTATUS()&lt;/code&gt; und &lt;code&gt;WTERMSIG()&lt;/code&gt;. &lt;code&gt;wait()&lt;/code&gt; gibt außerdem die Prozeß-ID des
Prozesses zurück, der beendet wurde.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;wait()&lt;/code&gt; hängt im Elternprozeß so lange bis entweder ein Signal eintrifft
oder ein Kindprozeß beendet wird.&lt;/p&gt;
&lt;p&gt;Das Programm init mit der PID 1 macht übrigens den ganzen lieben langen Tag
nix anderes: Es hängt im &lt;code&gt;wait()&lt;/code&gt; und frühstückt die ihm zugeworfenen
Exitstati ab, um sie zu verwerfen. Außerdem liest es die &lt;code&gt;/etc/inittab&lt;/code&gt; und
startet die dort konfigurierten Programme. Ist eines dieser Programme auf
Respawn gesetzt und wird beendet, wird es von init neu gestartet.&lt;/p&gt;
&lt;p&gt;Beendet sich ein Kindprozeß, ohne daß der Elternprozeß ein &lt;code&gt;wait()&lt;/code&gt; macht,
zerstört &lt;code&gt;exit()&lt;/code&gt; schon einmal alle Datenstrukturen des Kindprozesses, kann
jedoch den Prozeßlisteneintrag des Prozesses noch nicht wegwerfen, denn hier
steht der Exitstatus des Kindes drin. Es könnte ja nun sein, daß der
Elternprozeß sich irgendwann entschließt, ein &lt;code&gt;wait()&lt;/code&gt; auszuführen und dann
muß der Exitstatus ja bereitstehen.&lt;/p&gt;
&lt;p&gt;Der Kindprozeß ist also bereits tot - er hat &lt;code&gt;exit()&lt;/code&gt; ausgeführt und alle
Ressourcen freigegeben, kann aber noch nicht sterben, weil ja der
Elternprozeß den Status noch nicht abgeholt hat. Unix nennt so einen Prozeß
einen Zombie-Prozeß. Zombies werden in der Prozeßliste sichtbar, wenn ein
Prozeßerzeuger falsch programmiert ist und nicht ausreichend &lt;code&gt;wait()&lt;/code&gt; aufruft.&lt;/p&gt;
&lt;p&gt;Anders herum ist es auch möglich, daß ein Kindprozeß weiter läuft, während
ein Elternprozeß beendet wird. Dann wird die Parent Prozeß-ID (PPID) des
Kindes von der PID des Elternprozesses auf die Konstante 1 geändert, oder in
anderen Worten - init erbt den Prozeß.&lt;/p&gt;
&lt;p&gt;Beendet sich das Kind, empfängt init den Exitstatus des Kindes, denn init
hängt ja sowieso dauernd im wait. Dadurch wird die Entstehung eines Zombies
in diesem Fall verhindert.&lt;/p&gt;
&lt;p&gt;Wenn die Anzahl der Prozesse im System über die Laufzeit des System im
Mittel konstant ist, dann ist die Anzahl der &lt;code&gt;fork()&lt;/code&gt;, &lt;code&gt;exit()&lt;/code&gt; und
&lt;code&gt;wait()&lt;/code&gt;-Aufrufe im System ebenfalls im Mittel gleich, denn für jedes
&lt;code&gt;fork()&lt;/code&gt; muß irgendwann einmal ein &lt;code&gt;exit()&lt;/code&gt; gemacht werden und für jedes
&lt;code&gt;exit()&lt;/code&gt; muß der Elternprozeß einmal ein &lt;code&gt;wait()&lt;/code&gt; machen (In Wirklichkeit
ist die Situation wegen einiger anderer Regeln noch ein wenig komplizierter,
aber erst einmal soll dies hier genügen).&lt;/p&gt;
&lt;p&gt;Wir haben also ein sauberes fork-exit-wait-Dreieck.&lt;/p&gt;
&lt;h2 id=&#34;exec&#34;&gt;
    &lt;a href=&#34;#exec&#34;&gt;
	exec()
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;So wie &lt;code&gt;fork()&lt;/code&gt; Prozesse erzeugt, so lädt &lt;code&gt;exec()&lt;/code&gt; Programme in einen Prozeß.&lt;/p&gt;
&lt;p&gt;In  Code:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;
&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;sys/types.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;sys/wait.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;pid_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
        &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;   &lt;span class=&#34;n&#34;&gt;status&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

        &lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fork&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
                &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Ich bin der Kindprozess.&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
                &lt;span class=&#34;n&#34;&gt;execl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;/bin/ls&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;ls&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;-l&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;/tmp/kris&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
                &lt;span class=&#34;n&#34;&gt;perror&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;In exec(): &amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
                &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Ich bin der Elternprozess, das Kind ist %d.&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
                &lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;wait&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;status&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
                &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Ende des Prozesses %d: &amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
                &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;WIFEXITED&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;status&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
                        &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Der Prozess wurde mit exit(%d) beendet.&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;WEXITSTATUS&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;status&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
                &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
                &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;WIFSIGNALED&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;status&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
                        &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Der Prozess wurde mit kill -%d beendet.&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;WTERMSIG&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;status&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
                &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
                &lt;span class=&#34;n&#34;&gt;perror&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;In fork():&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

        &lt;span class=&#34;n&#34;&gt;exit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;go&#34;&gt;kris@linux:/tmp/kris&amp;gt; make probe3
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;cc     probe3.c   -o probe3
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;kris@linux:/tmp/kris&amp;gt; ./probe3
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;Ich bin der Kindprozess.
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;Ich bin der Elternprozess, das Kind ist 17690.
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;total 36
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;-rwxr-xr-x 1 kris users 6984 2007-01-05 13:29 probe1
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;-rw-r--r-- 1 kris users  303 2007-01-05 13:36 probe1.c
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;-rwxr-xr-x 1 kris users 7489 2007-01-05 13:37 probe2
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;-rw-r--r-- 1 kris users  719 2007-01-05 13:40 probe2.c
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;-rwxr-xr-x 1 kris users 7513 2007-01-05 13:42 probe3
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;-rw-r--r-- 1 kris users  728 2007-01-05 13:42 probe3.c
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;Ende des Prozesses 17690: Der Prozess wurde mit exit(0) beendet.
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Hier wird im Sohnprozeß der Code von probe3 weggeworfen (Das &lt;code&gt;perror(&amp;quot;In exec():&amp;quot;)&lt;/code&gt; wird niemals ausgeführt) und durch den angegebenen Aufruf von
&lt;code&gt;ls&lt;/code&gt; ersetzt. In der Ausführung erkennen wir, daß probe3 wartet, bis das
&lt;code&gt;ls&lt;/code&gt; sich mit &lt;code&gt;exit()&lt;/code&gt; beendet hat und dann seine eigene Ausführung danach
fortsetzt.&lt;/p&gt;
&lt;h2 id=&#34;als-shellscript&#34;&gt;
    &lt;a href=&#34;#als-shellscript&#34;&gt;
	Als Shellscript
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Die Beispiele oben operieren in C. In bash sieht es so aus:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;go&#34;&gt;kris@linux:/tmp/kris&amp;gt; cat probe1.sh
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;&lt;/span&gt;&lt;span class=&#34;gp&#34;&gt;#&lt;/span&gt;! /bin/bash --
&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;echo &amp;#34;Starte Kindprozess&amp;#34;
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;sleep 10 &amp;amp;
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;echo &amp;#34;Der Kindprozess hat die ID $!&amp;#34;
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;echo &amp;#34;Der Elternprozess hat die ID $$&amp;#34;
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;echo &amp;#34;$(date): Elternprozess geht schlafen.&amp;#34;
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;wait
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;echo &amp;#34;Der Kindprozess $! hat den Exit-Status $?&amp;#34;
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;echo &amp;#34;$(date): Elternprozess ist aufgewacht.&amp;#34;
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;kris@linux:/tmp/kris&amp;gt; ./probe1.sh
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;Starte Kindprozess
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;Der Kindprozess hat die ID 18071
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;Der Elternprozess hat die ID 18070
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;Fri Jan  5 13:49:56 CET 2007: Elternprozess geht schlafen.
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;Der Kindprozess 18071 hat den Exit-Status 0
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;Fri Jan  5 13:50:06 CET 2007: Elternprozess ist aufgewacht.
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Und hier beobachten wie die Shell bei der Ausführung von Kommandos:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;go&#34;&gt;kris@linux:~&amp;gt; strace -f -e execve,clone,fork,waitpid bash
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;kris@linux:~&amp;gt; ls
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;clone(Process 30048 attached
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD,
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;child_tidptr=0xb7dab6f8) = 30048
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;[pid 30025] waitpid(-1, Process 30025 suspended
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt; &amp;lt;unfinished ...&amp;gt;
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;[pid 30048] execve(&amp;#34;/bin/ls&amp;#34;, [&amp;#34;/bin/ls&amp;#34;, &amp;#34;-N&amp;#34;, &amp;#34;--color=tty&amp;#34;, &amp;#34;-T&amp;#34;, &amp;#34;0&amp;#34;],
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;[/* 107 vars */]) = 0
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;...
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;Process 30025 resumed
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;Process 30048 detached
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;&amp;lt;... waitpid resumed&amp;gt; [{WIFEXITED(s) &amp;amp;&amp;amp; WEXITSTATUS(s) == 0}], WSTOPPED
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;WCONTINUED) = 30048
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;--- SIGCHLD (Child exited) @ 0 (0) ---
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;...
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Linux verwendet eine Verallgemeinerung von &lt;code&gt;fork()&lt;/code&gt; mit dem Namen &lt;code&gt;clone()&lt;/code&gt; um
einen Kindprozeß zu erzeugen. Daher sehen wir keinen &lt;code&gt;fork()&lt;/code&gt;, sondern einen
&lt;code&gt;clone()&lt;/code&gt;-Aufruf mit einigen Parametern.&lt;/p&gt;
&lt;p&gt;Linux verwendet außerdem die Variante &lt;code&gt;waitpid()&lt;/code&gt; von &lt;code&gt;wait()&lt;/code&gt;, um auf eine
bestimmte PID zu warten.&lt;/p&gt;
&lt;p&gt;Linux startet außerdem das Programm mit &lt;code&gt;execve()&lt;/code&gt; statt mit &lt;code&gt;execl()&lt;/code&gt;, aber
das ist nur eine andere Anordnung von Parametern. Nach dem Ende von &lt;code&gt;ls&lt;/code&gt;
(PID 30048) wird der Prozeß 30025 aus dem &lt;code&gt;wait()&lt;/code&gt; erweckt und fortgesetzt.&lt;/p&gt;
&lt;p&gt;Und
&lt;a href=&#34;http://minnie.tuhs.org/UnixTree/V7/usr/src/cmd/sh/xec.c.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;hier&lt;/a&gt;

 ist
der C-Code der Originalshell aus dem Jahre 1979, mit dem &lt;code&gt;fork()&lt;/code&gt; (Man suche
nach &amp;ldquo;case TFORK:&amp;rdquo; und wundere sich nicht über den Programmierstil von Herrn
Bourne). Ja, bash ist schöner - GNU Code oder nicht.&lt;/p&gt;
&lt;p&gt;(nach
&lt;a href=&#34;http://groups.google.com/group/de.comp.os.unix.linux.misc/msg/4035c67415f9bc09&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;einem News-Artikel&lt;/a&gt;

 von mir)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Dynamisch geladener Code</title>
      <link>https://blog.koehntopp.info/2005/10/08/dynamisch-geladener-code.html</link>
      <pubDate>Sat, 08 Oct 2005 12:21:27 +0000</pubDate>
      
      <guid>https://blog.koehntopp.info/2005/10/08/dynamisch-geladener-code.html</guid>
      <description>&lt;p&gt;Inzwischen bin ich so weit, daß ich viele
Unix-Kommandozeilenprogramme zwar nützlich finde, aber in einem
größeren Maßstab als unhandlich und schlecht wiederzuverwenden
ansehe. Das liegt daran, daß das Konzept der Pipeline und der
Kommandozeile zwar sehr mächtig sind, insbesondere wenn man sie
mit einer guten Shell verwendet, aber einen nur so weit bringen.&lt;/p&gt;
&lt;p&gt;Manchmal muß man doch richtigen Code schreiben, und wenn man
dann den Compiler oder auch nur eine Scriptsprache schwingen
muß, dann nützen einem die ganzen Kommandozeilen-Utilities gar
nichts mehr.&lt;/p&gt;
&lt;p&gt;Ja, es geht sogar so weit, daß sich diese ganzen Hilfsmittel als
gefährlich erweisen, wenn irgendein Schlaumeier in seiner
Gedankenlosigkeit Benutzereingaben und Kommandozeilenbefehle
zusammenmischt und dann ohne das Gehirn einzuschalten an
&lt;code&gt;system()&lt;/code&gt; oder &lt;code&gt;popen()&lt;/code&gt; übergibt. Die Geschichte von PHP und
Perl ist voll von solchen bedauerlichen Betriebsunfällen und
tausende von deface-ten Webseiten existieren, um Zeugnis davon
abzulegen.&lt;/p&gt;
&lt;p&gt;Recode ist so ein Utilitiy gewesen, daß ich nützlich gefunden
hätte, wenn ich es - damals - in den nn hätte einbauen können.
Aber eine librecode gab es nicht - immerhin hat man einen
Bugreport irgendwann erhört und eine solche erzeugt und so war
es dann ganz einfach, die entsprechende PHP Extension zu
schreiben.&lt;/p&gt;
&lt;p&gt;Tidy ist ebenso ein Fall, der als Bibliothek sehr viel
nützlicher gewesen wäre als als Kommandozeilenprogramm, und
immerhin gibt es inzwischen auch eine Libtidy, auch wenn Suse
Tidy per Default ohne diese baut und man daher das Suse-Paket
erst einmal durch was richtiges ersetzen muß, bevor man sich ein
zeitgemäßes PHP5 übersetzt.&lt;/p&gt;
&lt;p&gt;Es gibt eine ganze Reihe von Programmen, die ich ebenfalls sehr
viel lieber als Bibliotheken sehen würde statt als
Standalone-Programme - allen voran den C-Compiler selber. Wie
coole Sachen könnte man machen, stünde einem Funktionalität wie
die Folgende bereit.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;code&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;void function(void) { printf(&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\&amp;#34;&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;Hello, World&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n\&amp;#34;&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;); }&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;PARSETREE_T&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;t&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;parse&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;code&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;EXEC_T&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;e&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;compile&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;f&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;find_symbol&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;function&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Oder bin ich der einzige, der so etwas cool finden würde?&lt;/p&gt;
&lt;p&gt;Aber auch ohne die Rekursion der Bibliothekserzeugung durch Bibliotheken
kann man nützliche Dinge tun. Und das geht so&amp;hellip;&lt;/p&gt;
&lt;h2 id=&#34;ein-stück-monolithischer-code&#34;&gt;
    &lt;a href=&#34;#ein-st%c3%bcck-monolithischer-code&#34;&gt;
	Ein Stück monolithischer Code
    &lt;/a&gt;
&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;func&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;para&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;result&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Entering func(%d)&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;para&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

    &lt;span class=&#34;n&#34;&gt;result&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;para&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

    &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Leaving func(%d) = %d&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;para&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;result&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;result&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;argc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;argv&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[])&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;main start&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

    &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Calling func(4) = %d&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;func&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;

    &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;main end&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Das ist ein mächtig aufregendes Programm: Es hat eine Funktion
&lt;code&gt;func&lt;/code&gt;, die ihren numerischen Eingabewert mit drei multipliziert
und zurückgibt. Es besteht aus einem Stück und ist trivial zu
übersetzen und auszuführen:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-makefile&#34; data-lang=&#34;makefile&#34;&gt;&lt;span class=&#34;nf&#34;&gt;.PHONY&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;clean&lt;/span&gt;

&lt;span class=&#34;nf&#34;&gt;prog&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;prog&lt;/span&gt;.&lt;span class=&#34;n&#34;&gt;c&lt;/span&gt;
    cc -Wall -o prog prog.c

&lt;span class=&#34;nf&#34;&gt;clean&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;
    rm prog
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;zwei-einzelne-module&#34;&gt;
    &lt;a href=&#34;#zwei-einzelne-module&#34;&gt;
	Zwei einzelne Module
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Für so ein kleines Testprogramm wie dieses ist das ausreichend, aber wenn
Programme größer werden, wollen wir sie aufteilen. Wir bekommen drei
Teilprogramme. Das erste, &lt;code&gt;func.c&lt;/code&gt;, enthält unsere Rechenfunktion:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;#34;func.h&amp;#34;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;func&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;para&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;result&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Entering func(%d)&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;para&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

    &lt;span class=&#34;n&#34;&gt;result&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;para&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

    &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Leaving func(%d) = %d&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;para&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;result&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;result&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Der zweite Teil, &lt;code&gt;prog.c&lt;/code&gt;, ruft diese Funktion nun auf:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;#34;func.h&amp;#34;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;argc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;argv&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[])&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;main start&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

    &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Calling func(4) = %d&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;func&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;

    &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;main end&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Der dritte Teil, &lt;code&gt;func.h&lt;/code&gt;, ist winzig klein:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;k&#34;&gt;extern&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;func&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;para&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Die &lt;code&gt;&amp;quot;extern&lt;/code&gt;-Anweisung in dieser Include-Datei muß in &lt;code&gt;prog.c&lt;/code&gt; eingebunden
werden. Sie macht dem Compiler, der &lt;code&gt;prog.c&lt;/code&gt; übersetzt, klar, daß es eine
Funktion &lt;code&gt;func()&lt;/code&gt; gibt, und welche Parameter sie ergibt sowie welches Ergebnis
sie liefert. Ohne diese Include-Datei würde der Compiler nicht wissen, daß
es eine solche Funktion gibt und einen Fehler generieren. Mit dem Include
vertagt er seine Entscheidung auf später, und generiert lediglich eine
&amp;ldquo;undefined reference&amp;rdquo; auf die Funktion, die dann zu einem späteren Zeitpunkt
gefunden und gelinkt werden muß.&lt;/p&gt;
&lt;p&gt;Bevor wir uns das genauer ansehen, hier erst einmal das
Makefile:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-makefile&#34; data-lang=&#34;makefile&#34;&gt;&lt;span class=&#34;nf&#34;&gt;prog&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;   &lt;span class=&#34;n&#34;&gt;prog&lt;/span&gt;.&lt;span class=&#34;n&#34;&gt;o&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;func&lt;/span&gt;.&lt;span class=&#34;n&#34;&gt;o&lt;/span&gt;
    cc -o prog $^

&lt;span class=&#34;nf&#34;&gt;.PHONY&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;
    clean

&lt;span class=&#34;nf&#34;&gt;.c.o&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;
    cc -Wall -c $&amp;lt;

&lt;span class=&#34;nf&#34;&gt;clean&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;
    rm -f *.o prog .dependencies

&lt;span class=&#34;nf&#34;&gt;.dependencies&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;
    cc -MM *.c &amp;gt; .dependencies

&lt;span class=&#34;err&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;.dependencies&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Ein Testlauf:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;go&#34;&gt;kris@valiant:~/Source/dlopen/02-multifile&amp;gt; make clean
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;rm -f *.o prog .dependencies
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;kris@valiant:~/Source/dlopen/02-multifile&amp;gt; make
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;Makefile:18: .dependencies: Datei oder Verzeichnis nicht gefunden
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;cc -MM *.c &amp;gt; .dependencies
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;cc -Wall -c prog.c
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;cc -Wall -c func.c
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;cc -o prog prog.o func.o
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;kris@valiant:~/Source/dlopen/02-multifile&amp;gt; ./prog
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;main start
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;Entering func(4)
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;Leaving func(4) = 12
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;Calling func(4) = 12
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;main end
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Unser Makefile generiert also mit mehreren einzelnen
Compileraufrufen eine &lt;code&gt;prog.o&lt;/code&gt; und eine &lt;code&gt;func.o&lt;/code&gt;-Datei. Ein
dritte Aufruf fügt dann &lt;code&gt;prog&lt;/code&gt; aus &lt;code&gt;prog.o&lt;/code&gt; und &lt;code&gt;func.o&lt;/code&gt;
zusammen.&lt;/p&gt;
&lt;p&gt;Wenn wir einmal einen genaueren Blick auf diese Dateien werden,
erkennen wir, wie das funktioniert:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;go&#34;&gt;kris@valiant:~/Source/dlopen/02-multifile&amp;gt; nm func.o
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;00000000 T func
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;U printf
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;kris@valiant:~/Source/dlopen/02-multifile&amp;gt; nm prog.o
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;U func
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;00000000 T main
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;U printf
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Die Datei &lt;code&gt;prog.o&lt;/code&gt; enthält ein &lt;code&gt;U func&lt;/code&gt;, ein &amp;ldquo;undefined symbol&amp;rdquo;
für die Funktionen &lt;code&gt;func&lt;/code&gt; und &lt;code&gt;printf&lt;/code&gt;. Sie definiert ein Symbol
&lt;code&gt;main&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Die Datei &lt;code&gt;func.o&lt;/code&gt; enthält ebenfalls ein &amp;ldquo;undefined symbol&amp;rdquo; für
&lt;code&gt;printf&lt;/code&gt;, und definiert ein Symbol &lt;code&gt;func&lt;/code&gt;. Durch das
Zusammenfügen beider Dateien wird das undefinierte Symbol &lt;code&gt;func&lt;/code&gt;
mit der Definition für &lt;code&gt;func&lt;/code&gt; aufgefüllt.&lt;/p&gt;
&lt;p&gt;Es bleibt jetzt noch die Definition von &lt;code&gt;printf&lt;/code&gt; zu erfüllen -
dies geschieht mit der libc, die jedem C-Programm automatisch
zugeügt wird, wenn man dies nicht abbestellt.&lt;/p&gt;
&lt;p&gt;Der C-Startupcode, der sich auch um die Parameterbehandlung mit
argc und argv kümmert, ruft dann &lt;code&gt;main&lt;/code&gt; auf. Er kann dies, weil
&lt;code&gt;main&lt;/code&gt; ein definiertes (und exportiertes) Symbol ist, sodaß er
die Funktion finden kann.&lt;/p&gt;
&lt;h2 id=&#34;eine-statische-bibliothek-bauen-und-verwenden&#34;&gt;
    &lt;a href=&#34;#eine-statische-bibliothek-bauen-und-verwenden&#34;&gt;
	Eine statische Bibliothek bauen und verwenden
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Wir können dieses Code nun ohne Änderung verwenden, um eine
statische Bibliothek zu bauen und zu verwenden. Dazu müssen wir
lediglich die Zusammenbauanweisung, das Makefile, anpassen.&lt;/p&gt;
&lt;p&gt;Unser neues Makefile sieht so aus:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-makefile&#34; data-lang=&#34;makefile&#34;&gt;&lt;span class=&#34;nf&#34;&gt;prog&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;   &lt;span class=&#34;n&#34;&gt;prog&lt;/span&gt;.&lt;span class=&#34;n&#34;&gt;o&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;libfunc&lt;/span&gt;.&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;
        cc -o prog prog.o -L. -lfunc

&lt;span class=&#34;nf&#34;&gt;.PHONY&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;
        clean

&lt;span class=&#34;nf&#34;&gt;.c.o&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;
        cc -Wall -c $&amp;lt;

&lt;span class=&#34;nf&#34;&gt;libfunc.a&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;      &lt;span class=&#34;n&#34;&gt;func&lt;/span&gt;.&lt;span class=&#34;n&#34;&gt;o&lt;/span&gt;
        ar rcs &lt;span class=&#34;nv&#34;&gt;$@&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;$?&lt;/span&gt;

&lt;span class=&#34;nf&#34;&gt;clean&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;
        rm -f *.o *.a prog .dependencies

&lt;span class=&#34;nf&#34;&gt;.dependencies&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;
        cc -MM *.c &amp;gt; .dependencies

&lt;span class=&#34;err&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;.dependencies&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;und es tut dies:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;go&#34;&gt;kris@valiant:~/Source/dlopen/03-staticlib&amp;gt; make
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;Makefile:19: .dependencies: Datei oder Verzeichnis nicht gefunden
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;cc -MM *.c &amp;gt; .dependencies
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;cc -Wall -c prog.c
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;cc -Wall -c func.c
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;ar rcs libfunc.a func.o
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;cc -o prog prog.o -L. -lfunc
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Wie zuvor übersetzen wir unsere beiden &lt;code&gt;.c&lt;/code&gt;-Dateien in &lt;code&gt;.o&lt;/code&gt;-Dateien.
Alle Bibliotheksmodule fügen wir nun in eine Bibliothek
&lt;code&gt;libfunc.a&lt;/code&gt; ein. Hier ist dies nur eine Datei, &lt;code&gt;func.o&lt;/code&gt;, aber in
einem richtigen Projekt können das sehr viele Dateien sein.&lt;/p&gt;
&lt;p&gt;Zum Erzeugen der Bibliothek verwenden wir den Archiver, &lt;code&gt;ar&lt;/code&gt;.
Mit der Option &lt;code&gt;r&lt;/code&gt; (&lt;code&gt;Replace&lt;/code&gt;, also entweder einfügen oder
aktualisieren von Bibliotheksmodulen) fügen wir &lt;code&gt;func.o&lt;/code&gt; in die
neue Bibliothek ein.&lt;/p&gt;
&lt;p&gt;Mit Hilfe der Suboption &lt;code&gt;c&lt;/code&gt; (&lt;code&gt;Create&lt;/code&gt;, Anlegen der Bibliothek
bei Bedarf) sorgen wir dafür, daß die Bibliothek auch erzeugt
wird, wenn sie noch nicht existiert.&lt;/p&gt;
&lt;p&gt;Die Suboption &lt;code&gt;s&lt;/code&gt; erzeugt einen Objektindex im Archiv oder
aktualisiert diesen. Dies erleichtert dem Linker später die
Arbeit, wenn er das Programm aus Bibliotheksmodulen
zusammenbauen muß.&lt;/p&gt;
&lt;p&gt;Unser Programm-Modul &lt;code&gt;prog.o&lt;/code&gt; enthält nun ein undefined Symbol,
&lt;code&gt;func&lt;/code&gt;. Mit der Option &lt;code&gt;-L&lt;/code&gt; setzen wir den Suchpfad für
Bibliotheken, und zwar auf &lt;code&gt;.&lt;/code&gt;, das aktuelle Verzeichnis. Dort
suchen wir mit &lt;code&gt;-lfunc&lt;/code&gt; nach der Bibliothek &lt;code&gt;libfunc.a&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Alle &lt;code&gt;.o&lt;/code&gt;-Dateien in der &lt;code&gt;libfunc.a&lt;/code&gt; werden durchsucht. Wenn eine von
ihnen das gesuchte Symbol &lt;code&gt;func&lt;/code&gt; enthält, wird diese &lt;code&gt;.o&lt;/code&gt;-Datei
dem Programm zugefügt. Dadurch wird &lt;code&gt;func&lt;/code&gt; von der Liste der
undefined symbols gestrichen und es werden ggf. weitere
undefined symbols der Liste hinzugefügt, nämlich diejenigen, die
das Modul &lt;code&gt;func.o&lt;/code&gt; selber mitbringt, wenn es dem Programm
hinzugefügt wird - in unserem Beispiel &lt;code&gt;printf&lt;/code&gt;. Aber &lt;code&gt;printf&lt;/code&gt;
war ja sowieso schon auf der Liste der undefinierten Symbole,
denn es wird ja auch in &lt;code&gt;prog.o&lt;/code&gt; verwendet.&lt;/p&gt;
&lt;p&gt;Es ist wichtig, eine Bibliothek so zu schreiben, daß sie aus
vielen kleinen Objektdateien besteht - jeweils eine Funktion pro
Objektdatei. Das muß so sein, weil der Linker für jedes
undefined symbol die Objektdatei aus dem Archiv extrahiert und
dem Programm hinzufügt, die eine Definition für das gesuchte
Symbol enthält. Wenn die Objektdateien groß sind und viele
Funktionen enthalten, dann werden unserem Endprogramm unter
Umständen Funktionen zugefügt, die wir gar nicht brauchen, weil
sie in derselben Objektdatei stehen wie eine Funktion, die wir
brauchen. Unsere Programme werden dann unnötig groß.&lt;/p&gt;
&lt;h2 id=&#34;dynamische-bibliotheken&#34;&gt;
    &lt;a href=&#34;#dynamische-bibliotheken&#34;&gt;
	Dynamische Bibliotheken
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Bei statischen Bibliotheken enthält nun jedes Programm, das wir
schreiben und in dem wir &lt;code&gt;func&lt;/code&gt; verwenden, eine Kopie von
&lt;code&gt;func&lt;/code&gt;. Wenn wir drei oder vier von diesen Programmen zugleich
starten, dann stehen auf dem Rechner drei oder vier Kopien von
&lt;code&gt;func&lt;/code&gt; im Speicher.&lt;/p&gt;
&lt;p&gt;Das muß nicht so sein. Wir können - wieder ohne Code zu ändern -
unser Programm so bauen, daß es stattdessen dynamische
Bibliotheken verwendet. Eine dynamische Bibliothek wird immer
als Ganzes geladen, steht dafür aber nur einmal im Speicher.
Wenn also drei oder vier verschiedene Programme die Bibliothek
verwenden, wird sie zwar für jedes dieser Programme in dessen
Speicherbereich eingeblendet, verbraucht dafür aber nur einmal
physikalischen Speicher.&lt;/p&gt;
&lt;p&gt;Damit das funktioniert, ändern wir das Makefile noch einmal ab:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-makefile&#34; data-lang=&#34;makefile&#34;&gt;&lt;span class=&#34;nf&#34;&gt;prog&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;   &lt;span class=&#34;n&#34;&gt;prog&lt;/span&gt;.&lt;span class=&#34;n&#34;&gt;o&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;libfunc&lt;/span&gt;.&lt;span class=&#34;n&#34;&gt;so&lt;/span&gt;
        cc -o prog prog.o -L&lt;span class=&#34;sb&#34;&gt;`&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;pwd&lt;/span&gt;&lt;span class=&#34;sb&#34;&gt;`&lt;/span&gt; -lfunc -Wl,-rpath &lt;span class=&#34;sb&#34;&gt;`&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;pwd&lt;/span&gt;&lt;span class=&#34;sb&#34;&gt;`&lt;/span&gt;

&lt;span class=&#34;nf&#34;&gt;.PHONY&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;
        clean

&lt;span class=&#34;nf&#34;&gt;.c.o&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;
        cc -Wall -c $&amp;lt;

&lt;span class=&#34;nf&#34;&gt;libfunc.so&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;     &lt;span class=&#34;n&#34;&gt;func&lt;/span&gt;.&lt;span class=&#34;n&#34;&gt;o&lt;/span&gt;
        cc -rdynamic -shared -o libfunc.so func.o

&lt;span class=&#34;nf&#34;&gt;clean&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;
        rm -f *.o *.a *.so prog .dependencies

&lt;span class=&#34;nf&#34;&gt;.dependencies&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;
        cc -MM *.c &amp;gt; .dependencies

&lt;span class=&#34;err&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;.dependencies&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Der Build sieht jetzt so aus:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;go&#34;&gt;kris@valiant:~/Source/dlopen/04-dynamiclib&amp;gt; make
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;Makefile:20: .dependencies: Datei oder Verzeichnis nicht gefunden
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;cc -MM *.c &amp;gt; .dependencies
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;cc -Wall -c prog.c
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;cc -Wall -c func.c
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;cc -rdynamic -shared -o libfunc.so func.o
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;cc -o prog prog.o -L`pwd` -lfunc -Wl,-rpath,`pwd`
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Hier werden die Objektmodule ohne eigene &lt;code&gt;main&lt;/code&gt;-Funktion nicht
mit &lt;code&gt;ar&lt;/code&gt; in eine &lt;code&gt;lib*.a&lt;/code&gt;-Datei überführt, sondern mit einem
&lt;code&gt;cc&lt;/code&gt;-Aufruf in eine &lt;code&gt;.so&lt;/code&gt;-Datei umgewandelt.&lt;/p&gt;
&lt;p&gt;So wie man &lt;code&gt;nm&lt;/code&gt; auf Objektdateien (&lt;code&gt;*.o&lt;/code&gt;) und Bibliotheken
(&lt;code&gt;*.a&lt;/code&gt;) anwenden kann, kann man mit &lt;code&gt;objdump -T libfunc.so&lt;/code&gt;
eine Liste der in der .so-Datei definierten Symbole bekommen -
leider bekommt man neben den interessanten Informationen auch
noch eine ganze Menge Verwaltungsklimbim angezeigt, sodaß man
das Ergebnis ein wenig filtern muß, bevor man es sinnvoll lesen
kann.&lt;/p&gt;
&lt;p&gt;Der eigentliche Build-Aufruf ist&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;go&#34;&gt;cc -o prog prog.o -L`pwd` -lfunc -Wl,-rpath,`pwd`
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Die Optionen &lt;code&gt;-L&lt;/code&gt; und &lt;code&gt;-l&lt;/code&gt; funktionieren genau wie bei
statischen Bibliotheken. Mit der Option &lt;code&gt;-Wl&lt;/code&gt; wird eine Option
an den Linker weitergegeben, den wir mit &lt;code&gt;-rpath,\&lt;/code&gt;pwd``
instruieren, das aktuelle Verzeichnis als Suchpfad für die
dynamischen Bibliotheken im resultierenden Binary mit zu
vermerken.&lt;/p&gt;
&lt;p&gt;Wenn wir das nicht täten, würde &lt;code&gt;libfunc.so&lt;/code&gt; nicht gefunden
werden, solange wir sie nicht in einem der in
&lt;code&gt;/etc/ld.so.conf&lt;/code&gt; genannten Verzeichnisse installieren und einmal
&lt;code&gt;ldconfig&lt;/code&gt; aufrufen.&lt;/p&gt;
&lt;p&gt;Wer dem Linker bei der Arbeit zuschauen will, der kann dies tun,
indem er die Shell-Variable &lt;code&gt;LD_DEBUG&lt;/code&gt; setzt und exportiert. Der
Wert &lt;code&gt;help&lt;/code&gt; zeigt einem, auf was für Werte man &lt;code&gt;LD_DEBUG&lt;/code&gt; setzen
kann:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;go&#34;&gt;kris@valiant:~/Source/dlopen/04-dynamiclib&amp;gt; export LD_DEBUG=help
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;kris@valiant:~/Source/dlopen/04-dynamiclib&amp;gt; ./prog
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;Valid options for the LD_DEBUG environment variable are:
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;libs display library search paths
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;reloc display relocation processing
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;files display progress for input file
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;symbols display symbol table processing
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;bindings display information about symbol binding
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;versions display version dependencies
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;all all previous options combined
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;statistics display relocation statistics
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;unused determined unused DSOs
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;help display this help message and exit
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;To direct the debugging output into a file instead of standard output
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;a filename can be specified using the LD_DEBUG_OUTPUT environment variable.
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;dlopen&#34;&gt;
    &lt;a href=&#34;#dlopen&#34;&gt;
	dlopen()
    &lt;/a&gt;
&lt;/h2&gt;
&lt;p&gt;Manchmal kann man zur Compilezeit noch nicht vorhersagen, welche
Module das laufende Programm später einmal benötigen wird.&lt;/p&gt;
&lt;p&gt;Speziell Programme mit Plugin-Architekturen haben den Bedarf,
&lt;code&gt;.so&lt;/code&gt;-Dateien zur Laufzeit anziehen zu können, um so ihre
Funktionalität durch das Laden von Plugins zu erweitern. Während
statisch eingebundene &lt;code&gt;.so&lt;/code&gt;-Dateien keine Änderungen am Code
notwendig machen, ist für dynamisch geladene Dateien ein wenig
Änderung notwendig - allerdings nur auf der ladenden Seite.&lt;/p&gt;
&lt;p&gt;Auf der Seite des Bibliothekscodes, in unserem Falle also
&lt;code&gt;func.c&lt;/code&gt;, &lt;code&gt;func.o&lt;/code&gt; und &lt;code&gt;libfunc.so&lt;/code&gt;, ist keine Änderung
notwendig.&lt;/p&gt;
&lt;p&gt;Das Makefile sieht nun jedoch so aus:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-makefile&#34; data-lang=&#34;makefile&#34;&gt;&lt;span class=&#34;nf&#34;&gt;all&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;prog&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;libfunc&lt;/span&gt;.&lt;span class=&#34;n&#34;&gt;so&lt;/span&gt;

&lt;span class=&#34;nf&#34;&gt;prog&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;   &lt;span class=&#34;n&#34;&gt;prog&lt;/span&gt;.&lt;span class=&#34;n&#34;&gt;o&lt;/span&gt;
        cc -o prog prog.o -ldl

&lt;span class=&#34;nf&#34;&gt;.PHONY&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;
        clean all

&lt;span class=&#34;nf&#34;&gt;.c.o&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;
        cc -Wall -c $&amp;lt;

&lt;span class=&#34;nf&#34;&gt;libfunc.so&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;     &lt;span class=&#34;n&#34;&gt;func&lt;/span&gt;.&lt;span class=&#34;n&#34;&gt;o&lt;/span&gt;
        cc -rdynamic -shared -o libfunc.so func.o

&lt;span class=&#34;nf&#34;&gt;clean&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;
        rm -f *.o *.a *.so prog .dependencies

&lt;span class=&#34;nf&#34;&gt;.dependencies&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;
        cc -MM *.c &amp;gt; .dependencies

&lt;span class=&#34;err&#34;&gt;include&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;.dependencies&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Wir haben nun also zwei unabhängige Targets beim Build: Die
&lt;code&gt;.so&lt;/code&gt;-Datei und das Programm, das sie verwendet, teilen keine
gemeinsame Abhängigkeit mehr. Das Programm, &lt;code&gt;prog&lt;/code&gt;, wird nun
auch nicht mehr gegen die &lt;code&gt;.so&lt;/code&gt;-Datei gelinkt. Stattdessen wird
mit &lt;code&gt;-ldl&lt;/code&gt; die libdl eingebunden, die uns die Funktionen
&lt;code&gt;dlopen()&lt;/code&gt;, &lt;code&gt;dlsym()&lt;/code&gt; und &lt;code&gt;dlclose()&lt;/code&gt; bereitstellt.&lt;/p&gt;
&lt;p&gt;Der Code in &lt;code&gt;prog.c&lt;/code&gt; sieht nun so aus:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;dlfcn.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;
&lt;span class=&#34;cp&#34;&gt;#define LIBNAME &amp;#34;./libfunc.so&amp;#34;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;func_t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;argc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;argv&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[])&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;func_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;error_msg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;libhandle&lt;/span&gt;   &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;NULL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

    &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;main start&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

    &lt;span class=&#34;cm&#34;&gt;/* .so oeffnen */&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;libhandle&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;dlopen&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;LIBNAME&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;RTLD_LAZY&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;!&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;libhandle&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;fprintf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;stderr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;dlopen(%s, RTLD_LAZY failed: %s&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; 
                &lt;span class=&#34;n&#34;&gt;LIBNAME&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; 
                &lt;span class=&#34;n&#34;&gt;dlerror&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;exit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;dlopen() = %p&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;libhandle&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

    &lt;span class=&#34;cm&#34;&gt;/* func() finden */&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;error_msg&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;dlerror&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;f&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;dlsym&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;libhandle&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;func&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;error_msg&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;dlerror&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;error_msg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;fprintf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;stderr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;dlsym(%p, &lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\&amp;#34;&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;func&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\&amp;#34;&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;) failed: %s&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; 
                &lt;span class=&#34;n&#34;&gt;libhandle&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
                &lt;span class=&#34;n&#34;&gt;error_msg&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;exit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

    &lt;span class=&#34;cm&#34;&gt;/* func() aufrufen */&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Calling func(4) = %d&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;

    &lt;span class=&#34;cm&#34;&gt;/* .so droppen */&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;dlclose&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;libhandle&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

    &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;main end&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Dieser Code definiert eine Variable &lt;code&gt;f&lt;/code&gt; vom Typ &amp;ldquo;Zeiger auf eine
Funktion, die ein int liefert und einen int-Parameter annimmt&amp;rdquo;.&lt;/p&gt;
&lt;p&gt;Er lädt mit &lt;code&gt;dlopen()&lt;/code&gt; die &lt;code&gt;libfunc.so&lt;/code&gt; ein. Wenn dies gelingt,
steht ein Handle für die Bibliothek zur Verfügung. Mit &lt;code&gt;dlsym()&lt;/code&gt;
können wir mit Hilfe des Handles in dieser Bibliothek nach der
dem Symbol &lt;code&gt;func&lt;/code&gt; suchen und bekommen so einen Zeiger auf &lt;code&gt;func&lt;/code&gt;
in &lt;code&gt;f&lt;/code&gt; abgelegt oder nicht.&lt;/p&gt;
&lt;p&gt;Man beachte das Errorchecking für das Ergebnis von &lt;code&gt;dlsym()&lt;/code&gt; nach
Lehrbuch - das Interface von &lt;code&gt;dlsym()&lt;/code&gt; ist &lt;del&gt;mehr als bekloppt&lt;/del&gt; nicht
sehr schön designed.&lt;/p&gt;
&lt;p&gt;Wir können &lt;code&gt;f&lt;/code&gt; dann ganz normal aufrufen. &lt;code&gt;dlclose()&lt;/code&gt; entlädt
das Plugin dann wieder.&lt;/p&gt;
&lt;p&gt;Wenn mehr Leute sich angewöhnen würden, ihre Programme in Form
von Bibliothek und Kommandozeilenwrapper zu schreiben, wäre es
sehr viel leichter, Code in Form von Bibliotheken in Sprachkerne
wie PHP oder in andere Programme einzubinden. Technisch ist das
nicht sehr schwer, solange man sich die Mühe macht, die
Infrastruktur drumherum in Form von Makefiles und
Include-Dateien ordentlich zu erstellen.&lt;/p&gt;
&lt;h5 id=&#34;material&#34;&gt;
    &lt;a href=&#34;#material&#34;&gt;
	Material
    &lt;/a&gt;
&lt;/h5&gt;
&lt;p&gt;Das
&lt;a href=&#34;http://www.dwheeler.com/program-library/Program-Library-HOWTO/t1.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Program Library Howto&lt;/a&gt;

 zeigt den ganzen Kram noch einmal in aller Ausführlichkeit. Ein
&lt;a href=&#34;http://people.redhat.com/drepper/dsohowto.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;PDF von Ulrich Drepper&lt;/a&gt;

 diskutiert  die dabei ablaufenden Interna.&lt;/p&gt;
&lt;p&gt;Das
&lt;a href=&#34;http://www.isotton.com/howtos/C&amp;#43;&amp;#43;-dlopen-mini-HOWTO/C&amp;#43;&amp;#43;-dlopen-mini-HOWTO.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;C++ dlopen Mini-Howto&lt;/a&gt;

 beschreibt, wie das ganze mit C++ zu bewerkstelligen ist. James Norton baut da in
&lt;a href=&#34;http://www2.linuxjournal.com/article/3687&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Dynamic Class Loading in C++&lt;/a&gt;

 sogar einen schönen Wrapper drumherum.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://actcomm.thayer.dartmouth.edu/dynamic/README.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Dynamic C++ Classes - Code Distribution&lt;/a&gt;

 ist die Downloadseite der dynamic-class library für C++. Das Paper
&lt;a href=&#34;http://actcomm.thayer.dartmouth.edu/dynamic/gh98.usenix98.camera.ps&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&amp;ldquo;Dynamic C++ classes: A lightweight mechanism to update code in a running program&amp;rdquo;&lt;/a&gt;

 von Gísli Hjálmtýsson and Bob Gray beschreibt den Hintergrund.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Wieviel Load darf es denn sein?</title>
      <link>https://blog.koehntopp.info/2005/06/24/wieviel-load-darf-es-denn-sein.html</link>
      <pubDate>Fri, 24 Jun 2005 08:47:16 +0000</pubDate>
      
      <guid>https://blog.koehntopp.info/2005/06/24/wieviel-load-darf-es-denn-sein.html</guid>
      <description>&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/load-beispiel.png&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;

&lt;/p&gt;
&lt;p&gt;In
&lt;a href=&#34;http://webhostingtech.de/2106/677.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Wann ist die Serverload zu hoch?&lt;/a&gt;


fragt Reimer:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Die Frage, ob ein Serverload von n zu hoch sei, höre ich häufig.
Die Antworten sind jedoch ebenso unterschiedlich.
So wird häufig die Zahl 1,00 als normaler Wert gehandelt, aber genau so fallen Zahlen wie 5,00 und 8,00 etc.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;In Linux und Unix gibt es einige Zahlen, mit denen man die CPU-Auslastung des Systems ausdrücken kann.
Da ist erst einmal die momentane CPU-Auslastung in Prozent, wie sie von &lt;code&gt;top&lt;/code&gt; und anderen Tools angezeigt wird:&lt;/p&gt;
&lt;p&gt;Diese Zahl gibt detailliert Auskunft darüber, wie die CPU &lt;em&gt;in diesem Moment&lt;/em&gt; ihre Zeit verbringt:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-console&#34; data-lang=&#34;console&#34;&gt;&lt;span class=&#34;go&#34;&gt;top - 10:49:36 up 11:53,  4 users,  load average: 2.71, 2.33, 2.20
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;Tasks: 109 total,   3 running, 106 sleeping,   0 stopped,   0 zombie
&lt;/span&gt;&lt;span class=&#34;go&#34;&gt;Cpu(s): 31.4% us,  8.9% sy,  0.0% ni, 47.5% id,  0.0% wa, 10.2% hi,  2.0% si
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Die Zahl &lt;code&gt;id&lt;/code&gt; ist die Idle-Zeit, die ungenutzte Zeit der CPU.
Die anderen Zahlen sagen detailliert, wie die CPU ihre Zeit verbringt: &lt;code&gt;us&lt;/code&gt; (User-Time) ist Zeit, die im Programm verbracht wird, und &lt;code&gt;sy&lt;/code&gt; (System-Time) die Zeit, die vom Kernel im Auftrag dieses Programmes verbraucht wird.
&lt;code&gt;ni&lt;/code&gt; (Nice-Time) ist Zeit, die von herunter priorisierten Prozessen sinnvoll verbraucht wird.
Alle drei Zeiten zusammen sind sinnvoll genutzte Arbeitszeit.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;wa&lt;/code&gt; (Wait-Time) ist I/O-Wait, also Zeit, die der Rechner auf das Eintreffen von Daten von der Platte oder dem Netzwerk wartet.
&lt;code&gt;hi&lt;/code&gt; und &lt;code&gt;si&lt;/code&gt; (Hard- und Soft Interrupt) sind Zeiten, die das System mit der Bearbeitung von Interrupts zubringt, also in Gerätetreibern und Timer-Routinen.&lt;/p&gt;
&lt;p&gt;Die Loadzahlen geben die mittlere Länge der Run-Queue über eine Minute (erste Zahl), fünf Minuten (zweite Zahl) und 15 Minuten (dritte Zahl) an.
Die Zahl sagt, wie viele Prozessoren das System im Schnitt auslasten könnte.
Wenn also die Load 1 ist, ist ein Einprozessorsystem so in etwa ausgelastet, eine Enterprise 10000 mit 64 CPUs in einer Domain ist bei einer Load von 64 gut ausgelastet.&lt;/p&gt;
&lt;p&gt;Die Load auf meinem System ist derzeit so:&lt;/p&gt;
&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/load-beispiel.png&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;

&lt;/p&gt;
&lt;p&gt;Für Auslastungsabschätzungen ist die blaue Fläche aussagekräftig, denn sie stellt die 15 Minuten-Load dar.
Diese Zahl ist relativ unempfindlich gegen lokale Lastspitzen und daher ein besseres Maß für die Auslastung (im Gegensatz zur Elastizität) des Systems.
Meine Maschine läuft derzeit tagsüber mit einer Load von ca. 0.8, ist also mit einem Prozessor zu etwa 80 % voll.
Zu einzelnen Zeitpunkten (nachts um 4:15 Uhr, wenn das News-Expire läuft), wird die Ideal-Last von 1 deutlich überschritten.
Das ist zu diesem Zeitpunkt aber nicht schlimm.&lt;/p&gt;
&lt;p&gt;Die Spitzenlasten (rote Kurve: 1 Minuten-Load, und davon das Maximum) halten sich außer um 4:15 Uhr im Rahmen, die Maschine kommt nicht nennenswert über Load 2 hinaus.
Die Kiste hat also nicht mehr allzu viel Reserven, ist aber auch noch nicht überlastet.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Von 10^3 nach 10^7: Wachstumsschmerzen mit Linux</title>
      <link>https://blog.koehntopp.info/2004/06/23/von-10-hoch-3-nach-10-hoch-7.html</link>
      <pubDate>Wed, 23 Jun 2004 09:00:00 +0000</pubDate>
      
      <guid>https://blog.koehntopp.info/2004/06/23/von-10-hoch-3-nach-10-hoch-7.html</guid>
      <description>&lt;h1 id=&#34;warum-wachstum-weh-tut&#34;&gt;
    &lt;a href=&#34;#warum-wachstum-weh-tut&#34;&gt;
	Warum Wachstum weh tut
    &lt;/a&gt;
&lt;/h1&gt;
&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/2004/06/von-10-hoch-3-nach-10-hoch-7/img0.jpg&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;

&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&amp;ldquo;Systemadministration&amp;rdquo;
&lt;ul&gt;
&lt;li&gt;Eine Aufgabe, die in sehr unterschiedlichen Größenordnungen kommt&lt;/li&gt;
&lt;li&gt;Ein mögliches Maß: Anzahl der betroffenen Benutzer
&lt;ul&gt;
&lt;li&gt;10^1 - für sich selbst und seinen Partner oder für eine WG&lt;/li&gt;
&lt;li&gt;10^3 - für einen kleinen Verein (&amp;ldquo;Toppoint e.V&amp;rdquo;, &amp;ldquo;INKA&amp;rdquo;)&lt;/li&gt;
&lt;li&gt;10^5 - für ein kleines Internet Unternehmen&lt;/li&gt;
&lt;li&gt;10^7 - für ein großes Internet Unternehmen&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Die Aufgabe verändert sich nicht, aber die möglichen Lösungen und die daran hängenden Strukturen&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/2004/06/von-10-hoch-3-nach-10-hoch-7/img1.jpg&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;

&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Wachstum ist eine Folge von Erfolg
&lt;ul&gt;
&lt;li&gt;Ich muß mit meinem Erfolg wachsen. Ich kann nicht planen.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Beispiele:
&lt;ul&gt;
&lt;li&gt;Stark schwankende Dienstenutzung (&amp;ldquo;Grußkarten&amp;rdquo;)&lt;/li&gt;
&lt;li&gt;Strukturveränderung in Diensten (&amp;ldquo;POP3 vs. IMAP&amp;rdquo;, &amp;ldquo;SSL&amp;rdquo;)&lt;/li&gt;
&lt;li&gt;Dienste mit unbekannter Akzeptanz (&amp;ldquo;Videomail&amp;rdquo;)&lt;/li&gt;
&lt;li&gt;Dienstwachstum erfordert strukturelle Veränderung (&amp;ldquo;Freemail&amp;rdquo;)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;limits&#34;&gt;
    &lt;a href=&#34;#limits&#34;&gt;
	Limits
    &lt;/a&gt;
&lt;/h1&gt;
&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/2004/06/von-10-hoch-3-nach-10-hoch-7/img2.jpg&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;

&lt;/p&gt;
&lt;h1 id=&#34;limits-in-hardware-und-software&#34;&gt;
    &lt;a href=&#34;#limits-in-hardware-und-software&#34;&gt;
	Limits in Hardware und Software
    &lt;/a&gt;
&lt;/h1&gt;
&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/2004/06/von-10-hoch-3-nach-10-hoch-7/img3.jpg&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;

&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Hardwaregrenzen
&lt;ul&gt;
&lt;li&gt;Intel-Hardware: 4 CPU, x GB RAM, 60 MB/sec Random I/O&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Softwaregrenzen
&lt;ul&gt;
&lt;li&gt;Die verwendete Datenbank fällt bei bestimmten Daten- und Lastgrößenordnungen schlicht auseinander oder degradiert über die Zeit.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Hotspots
&lt;ul&gt;
&lt;li&gt;Ein stark belasteter Block bremst die Gesamtperformance eines RAID-Systems&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;reaktionen-auf-wachstum&#34;&gt;
    &lt;a href=&#34;#reaktionen-auf-wachstum&#34;&gt;
	Reaktionen auf Wachstum
    &lt;/a&gt;
&lt;/h1&gt;
&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/2004/06/von-10-hoch-3-nach-10-hoch-7/img4.jpg&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;

&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Wachstum erfolgt aus dem Betrieb
&lt;ul&gt;
&lt;li&gt;&amp;ldquo;Jetzt wachsen&amp;rdquo; =&amp;gt; &amp;ldquo;mehr Kisten&amp;rdquo;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Kurzfristige und längerfristige Lösungen gleichzeitig verfolgen
&lt;ul&gt;
&lt;li&gt;Das ist nicht immer schön&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Lastverteilung:
&lt;ul&gt;
&lt;li&gt;DNS RR&lt;/li&gt;
&lt;li&gt;Loadbalancer Appliance&lt;/li&gt;
&lt;li&gt;Linux Virtual Server&lt;/li&gt;
&lt;li&gt;Applikation verteilt (login, hashes)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Schreibrate beeinflußt die Architektur
&lt;ul&gt;
&lt;li&gt;Livebetrieb auf Snapshots und Kopien&lt;/li&gt;
&lt;li&gt;Zentrale Datenhaltung bildet Flaschenhälse&lt;/li&gt;
&lt;li&gt;Anwendungen verteilbar realisieren&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;erfahrungen&#34;&gt;
    &lt;a href=&#34;#erfahrungen&#34;&gt;
	Erfahrungen
    &lt;/a&gt;
&lt;/h1&gt;
&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/2004/06/von-10-hoch-3-nach-10-hoch-7/img5.jpg&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;

&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Hardware ist billiger als Software&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Software ist billiger als Leute&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Hardware ist schneller als Software&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Software ist schneller als Leute&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Der Preis ist nie das Problem.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Lösbarkeit in Zeit ist das Problem&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;zentrale-und-dezentrale-systeme&#34;&gt;
    &lt;a href=&#34;#zentrale-und-dezentrale-systeme&#34;&gt;
	Zentrale und dezentrale Systeme
    &lt;/a&gt;
&lt;/h1&gt;
&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/2004/06/von-10-hoch-3-nach-10-hoch-7/img6.jpg&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;

&lt;/p&gt;
&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/2004/06/von-10-hoch-3-nach-10-hoch-7/img7.jpg&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;

&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Historisches Wechselspiel
&lt;ul&gt;
&lt;li&gt;Hosts&lt;/li&gt;
&lt;li&gt;PCs
&lt;ul&gt;
&lt;li&gt;Zentraler Storage, zentrales drucken&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Workstation Cluster
&lt;ul&gt;
&lt;li&gt;Zentrale Administration&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Webanwendungen
&lt;ul&gt;
&lt;li&gt;Zentrale Anwendungsinstallation, zentrale Datenhaltung&lt;/li&gt;
&lt;li&gt;Webanwendungen können im RZ verteilt werden -&amp;gt; Cluster&lt;/li&gt;
&lt;li&gt;Webanwendungen können dezentral ablaufen -&amp;gt; Applets, Thin Clients&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Einflußfaktoren:
&lt;ul&gt;
&lt;li&gt;Netzbandbreite und Latenz vs. zentrale Rechenleistung&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/2004/06/von-10-hoch-3-nach-10-hoch-7/img8.jpg&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;

&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Dezentralisierung funktioniert.&lt;/li&gt;
&lt;li&gt;Limits in der verfügbaren Hard- und Software erzwingen dezentrale Systeme
&lt;ul&gt;
&lt;li&gt;Zentrale Systeme haben immer ein wachstumsbegrenzendes Limit.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Verteilung:
&lt;ul&gt;
&lt;li&gt;Zustand bremst. Zustandslos verteilen!&lt;/li&gt;
&lt;li&gt;Writes bremsen. Dezentral schreiben!&lt;/li&gt;
&lt;li&gt;Synchronisation bremst. Asynchrone Strukturen bauen!&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;berg-der-verzweiflung&#34;&gt;
    &lt;a href=&#34;#berg-der-verzweiflung&#34;&gt;
	&amp;ldquo;Berg der Verzweiflung&amp;rdquo;
    &lt;/a&gt;
&lt;/h1&gt;
&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/2004/06/von-10-hoch-3-nach-10-hoch-7/img9.jpg&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;

&lt;/p&gt;
&lt;h1 id=&#34;architektur&#34;&gt;
    &lt;a href=&#34;#architektur&#34;&gt;
	Architektur
    &lt;/a&gt;
&lt;/h1&gt;
&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/2004/06/von-10-hoch-3-nach-10-hoch-7/img10.jpg&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;

&lt;/p&gt;
&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/2004/06/von-10-hoch-3-nach-10-hoch-7/img11.jpg&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;

&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Freemail:
&lt;ul&gt;
&lt;li&gt;Plugin im Webserver (eine Art PHP/FI)
&lt;ul&gt;
&lt;li&gt;Alle Funktionen des Dienstes in einer Schicht als Teil des Webservers&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Differenzierung
&lt;ul&gt;
&lt;li&gt;Funktionstrennung&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Multi-Tier Architektur für zwei Dutzend Teildienste&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Folgen:
&lt;ul&gt;
&lt;li&gt;Abhängigkeiten-Netze&lt;/li&gt;
&lt;li&gt;Debug-Komplexität&lt;/li&gt;
&lt;li&gt;Update-Komplexität&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;un-architektur&#34;&gt;
    &lt;a href=&#34;#un-architektur&#34;&gt;
	Un-Architektur
    &lt;/a&gt;
&lt;/h1&gt;
&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/2004/06/von-10-hoch-3-nach-10-hoch-7/img12.jpg&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;

&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Architektur vs. Betriebliche Erfordernisse
&lt;ul&gt;
&lt;li&gt;Manche Probleme löst man nur durch brachiale Gewalt&lt;/li&gt;
&lt;li&gt;Das Resultat ist niemals ästhetisch.
&lt;ul&gt;
&lt;li&gt;Aber es macht die Kasse voll. :)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Problem: Dokumente liefern
&lt;ul&gt;
&lt;li&gt;Informatiker-Lösung:
&lt;ul&gt;
&lt;li&gt;Dokumentenserver in Corba-Dienst verpacken&lt;/li&gt;
&lt;li&gt;Details wegabstrahieren&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Folge:
&lt;ul&gt;
&lt;li&gt;Performance&amp;hellip; läßt Wünsche offen&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Lösung:
&lt;ul&gt;
&lt;li&gt;NFS, Datenbank liefert Dateinamen&lt;/li&gt;
&lt;li&gt;Laufender Dialog mit der F&amp;amp;E&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;denormalisierung&#34;&gt;
    &lt;a href=&#34;#denormalisierung&#34;&gt;
	Denormalisierung
    &lt;/a&gt;
&lt;/h1&gt;
&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/2004/06/von-10-hoch-3-nach-10-hoch-7/img13.jpg&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;

&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Problem:
&lt;ul&gt;
&lt;li&gt;Speicherung von Mail-Headerinformationen in Datenbanken&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Informatiker-Lösung:
&lt;ul&gt;
&lt;li&gt;3NF Datenspeicher&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Folge:
&lt;ul&gt;
&lt;li&gt;Datenbank explodiert&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Lösung:
&lt;ul&gt;
&lt;li&gt;Messen. Hotspots identifizieren. Denormalisierung.&lt;/li&gt;
&lt;li&gt;Daraus folgend: Fehler → Fehlerbehandlung&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;der-ganz-normale-wahnsinn&#34;&gt;
    &lt;a href=&#34;#der-ganz-normale-wahnsinn&#34;&gt;
	Der ganz normale Wahnsinn
    &lt;/a&gt;
&lt;/h1&gt;
&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/2004/06/von-10-hoch-3-nach-10-hoch-7/img14.jpg&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;

&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Problem:
&lt;ul&gt;
&lt;li&gt;&amp;ldquo;Ab morgen machen wir SSL&amp;rdquo;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Folgen?
&lt;ul&gt;
&lt;li&gt;Architektur (mod_gzip + mod_ssl?)&lt;/li&gt;
&lt;li&gt;Infrastruktur
&lt;ul&gt;
&lt;li&gt;CPU?&lt;/li&gt;
&lt;li&gt;CPU-Verteilung aka Balancing?&lt;/li&gt;
&lt;li&gt;Rackspace?&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Logistik
&lt;ul&gt;
&lt;li&gt;Installation?&lt;/li&gt;
&lt;li&gt;Rollout?&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;katalog-vs-reality&#34;&gt;
    &lt;a href=&#34;#katalog-vs-reality&#34;&gt;
	Katalog vs. Reality
    &lt;/a&gt;
&lt;/h1&gt;
&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/2004/06/von-10-hoch-3-nach-10-hoch-7/img15.jpg&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;

&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Hersteller nehmen den Mund gerne voll.
&lt;ul&gt;
&lt;li&gt;&amp;ldquo;4400 RSA-Operations pro Sekunde&amp;rdquo;
&lt;ul&gt;
&lt;li&gt;Resultat: Montag Mittag, 0% Idle, Totalstillstand&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&amp;ldquo;SAN Storage Lösungen&amp;rdquo;, &amp;ldquo;sie sind eher einer unserer kleineren Kunden&amp;rdquo;
&lt;ul&gt;
&lt;li&gt;Resultat: Systemstillstand beim Erstellen von Snapshots, &amp;ldquo;mit so vielen kleinen Dateien haben wir nicht gerechnet&amp;rdquo;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&amp;ldquo;x tausend Firewall-Connections pro Sekunde&amp;rdquo;
&lt;ul&gt;
&lt;li&gt;&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Reiserfs, XFS
&lt;ul&gt;
&lt;li&gt;&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;erfahrungen-1&#34;&gt;
    &lt;a href=&#34;#erfahrungen-1&#34;&gt;
	Erfahrungen
    &lt;/a&gt;
&lt;/h1&gt;
&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/2004/06/von-10-hoch-3-nach-10-hoch-7/img16.jpg&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;

&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Normalisierung gut!&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Denormalisierung besser!&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Architektur gut!&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Einfache Konzepte besser!&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Trau keinem Katalog!&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Alle Hersteller versagen in der Praxis.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/2004/06/von-10-hoch-3-nach-10-hoch-7/img17.jpg&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;

&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&amp;ldquo;XP&amp;rdquo;: Architektur als Prozeß:&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Tu&#39; nur was notwendig ist. Behalte die Vision im Hinterkopf.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Kritik: Was ist mit Projektkriterien?&lt;/li&gt;
&lt;li&gt;Mache kurze, überschaubare Projekte (&amp;lt;3 Monate)&lt;/li&gt;
&lt;li&gt;Sei bereit, Dinge wegzuwerfen.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Projekt &amp;lt;-&amp;gt; Prozeß&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;serviceprozesse&#34;&gt;
    &lt;a href=&#34;#serviceprozesse&#34;&gt;
	Serviceprozesse
    &lt;/a&gt;
&lt;/h1&gt;
&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/2004/06/von-10-hoch-3-nach-10-hoch-7/img18.jpg&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;

&lt;/p&gt;
&lt;h1 id=&#34;prozesse-nach-außen&#34;&gt;
    &lt;a href=&#34;#prozesse-nach-au%c3%9fen&#34;&gt;
	Prozesse nach Außen
    &lt;/a&gt;
&lt;/h1&gt;
&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/2004/06/von-10-hoch-3-nach-10-hoch-7/img19.jpg&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;

&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Testballon -&amp;gt; virtueller SLA
&lt;ul&gt;
&lt;li&gt;Auch wenn es kostenlos ist erwartet der Kunde, daß es funktioniert.&lt;/li&gt;
&lt;li&gt;Ausbildung von Supportstrukturen&lt;/li&gt;
&lt;li&gt;Steigerung der Abhängigkeiten -&amp;gt; Steigerung der Erwartungen&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&amp;ldquo;Der User ist produktiv.&amp;rdquo;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;prozesse-nach-innen&#34;&gt;
    &lt;a href=&#34;#prozesse-nach-innen&#34;&gt;
	Prozesse nach Innen
    &lt;/a&gt;
&lt;/h1&gt;
&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/2004/06/von-10-hoch-3-nach-10-hoch-7/img20.jpg&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;

&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Differenzierung
&lt;ul&gt;
&lt;li&gt;Allroundqualifikation -&amp;gt; Spezialistenbildung&lt;/li&gt;
&lt;li&gt;Kommunikationsbedarf&lt;/li&gt;
&lt;li&gt;Dinge explizit machen
&lt;ul&gt;
&lt;li&gt;Dokumentation&lt;/li&gt;
&lt;li&gt;Prozesse&lt;/li&gt;
&lt;li&gt;Verantwortungen&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;prozesstrennungen&#34;&gt;
    &lt;a href=&#34;#prozesstrennungen&#34;&gt;
	Prozesstrennungen
    &lt;/a&gt;
&lt;/h1&gt;
&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/2004/06/von-10-hoch-3-nach-10-hoch-7/img21.jpg&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;

&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ITIL (&amp;ldquo;The IT Infrastructure Library&amp;rdquo;)
&lt;ul&gt;
&lt;li&gt;ITIL Phasen in der F&amp;amp;E (&amp;ldquo;Funktionalität&amp;rdquo;)&lt;/li&gt;
&lt;li&gt;ITIL Phasen in der IT (&amp;ldquo;Verfügbarkeit, Wachstum und Qualität&amp;rdquo;)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Was F&amp;amp;E macht, ist allgemein bekannt.&lt;/li&gt;
&lt;li&gt;Was IT macht, können die meisten Leute nicht benennen.
&lt;ul&gt;
&lt;li&gt;Abgrenzung gegen F&amp;amp;E&lt;/li&gt;
&lt;li&gt;Abgrenzung gegen Support&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Trennung von IT und F&amp;amp;E wird oft nicht durchdacht.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;ausblick&#34;&gt;
    &lt;a href=&#34;#ausblick&#34;&gt;
	Ausblick
    &lt;/a&gt;
&lt;/h1&gt;
&lt;p&gt;&lt;p class=&#34;md__image&#34;&gt;
  &lt;img src=&#34;https://blog.koehntopp.info/uploads/2004/06/von-10-hoch-3-nach-10-hoch-7/img22.jpg&#34; alt=&#34;&#34;  /&gt;
&lt;/p&gt;

&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Spannungsfelder
&lt;ul&gt;
&lt;li&gt;Zentral &amp;lt;-&amp;gt; Dezentral&lt;/li&gt;
&lt;li&gt;Projekt &amp;lt;-&amp;gt; Prozeß&lt;/li&gt;
&lt;li&gt;&amp;ldquo;Jetzt&amp;rdquo; &amp;lt;-&amp;gt; &amp;ldquo;Richtig&amp;rdquo;, &amp;ldquo;Ordentlich&amp;rdquo;&lt;/li&gt;
&lt;li&gt;&amp;ldquo;F&amp;amp;E&amp;rdquo; &amp;lt;-&amp;gt; &amp;ldquo;IT&amp;rdquo; &amp;lt;-&amp;gt; &amp;ldquo;Support&amp;rdquo;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>

