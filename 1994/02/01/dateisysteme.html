<!doctype html>
<html lang="en">
    <head>
    <meta charset="utf-8">
<meta http-equiv="x-ua-compatible" content="ie=edge">
<title>UNIX Dateisysteme | Die wunderbare Welt von Isotopp</title>
<meta name="description" content="Kris Köhntopp&#39;s blog (Fedi: @isotoppinfosec.exchange)">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="apple-touch-icon" href="icon.png">
<link rel="icon" href="favicon.ico" type="image/ico">
<link rel="shortcut icon" href="favicon.ico">
<link rel="canonical" href="https://blog.koehntopp.info/1994/02/01/dateisysteme.html">

<link rel="alternate" type="application/rss+xml" href='https://blog.koehntopp.info/feed.xml' title="Die wunderbare Welt von Isotopp">
<link rel="alternate" type="application/rss+xml" href='https://blog.koehntopp.info/tags/mysql/feed.xml' title="Feed: mysql Articles for Die wunderbare Welt von Isotopp">
<link rel="alternate" type="application/rss+xml" href='https://blog.koehntopp.info/tags/review/feed.xml' title="Feed: review Articles for Die wunderbare Welt von Isotopp">


<meta name="generator" content="Hugo 0.145.0">
<meta property="og:title" content='UNIX Dateisysteme | Die wunderbare Welt von Isotopp' />
<meta property="og:site_name" content='Die wunderbare Welt von Isotopp' />
<meta property="og:locale" content="de_DE" />
<meta name="description" content='Kris Köhntopp&#39;s blog (Fedi: @isotoppinfosec.exchange)' />
<meta property="og:description" content='Kris Köhntopp&#39;s blog (Fedi: @isotoppinfosec.exchange)' />
<meta property="og:url" content="https://blog.koehntopp.info/1994/02/01/dateisysteme.html" />
<meta property="og:type" content="article" />
<meta name="article:published_time" content='1994-02-01T09:00:00Z' />
<meta name="fediverse:creator" content="@isotopp@infosec.exchange">
<meta property="og:image" content='https://blog.koehntopp.info/assets/img/background/rijksmuseum.jpg' />
<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:creator" content='@isotopp@infosec.exchange' />
<meta property="twitter:title" content='UNIX Dateisysteme' />
<meta property="twitter:description" content='Kris Köhntopp&#39;s blog (Fedi: @isotoppinfosec.exchange)' />
<meta property="twitter:image" content='https://blog.koehntopp.info/assets/img/background/rijksmuseum.jpg' />


    



<link rel="stylesheet" href="https://blog.koehntopp.info/style.min.dd9d518fe6cac55191b6af874e18327dff051055754ffc7e106131baf826e6d3.css">


    </head>
    <body>
        

        <nav class="navbar navbar-expand-lg navbar-light px-lg-4 pt-lg-4">
    <div class="container-fluid">
        <a class="navbar-brand justify-content-center" href="https://blog.koehntopp.info/" rel="home" title="Die wunderbare Welt von Isotopp">
            <img alt="Kris" height='48' width='48' src='/assets/img/avatars/isotopp.jpg' class='p-0 me-3 d-block d-lg-inline'>
            <span class='h4 d-block d-lg-inline'>Die wunderbare Welt von Isotopp</span>
        </a>

        <button class="navbar-toggler ms-auto" type="button" data-bs-toggle="collapse"
                data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false"
                aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse text-center" id="navbarSupportedContent">
            <ul class="navbar-nav ms-auto">
                
                <li class="nav-item ">
                    <a class="nav-link" href="/about/">
                        <span class="">About</span>
                        
                    </a>
                </li>
                <li class="nav-item ">
                    <a class="nav-link" href="/contribute/">
                        <span class="">Contribute</span>
                        
                    </a>
                </li>
                <li class="nav-item ">
                    <a class="nav-link" href="/search/">
                        <span class=""><svg class='bi' height='1.5rem' width='1.5rem' fill='currentColor'><use xlink:href='/bootstrap-icons.svg#search'/></svg></span>
                        
                    </a>
                </li>
                <li class="nav-item ">
                    <a class="nav-link" href="/tags/">
                        <span class=""><svg class='bi' width='1.5rem' height='1.5rem' fill='currentColor'><use xlink:href='/bootstrap-icons.svg#tags-fill'/></svg></span>
                        
                    </a>
                </li>
                
            </ul>
            
        </div>

    </div>
</nav>


        <main role="main" class="container-fluid p-0">

            









<div class="page">
	<article class="unix-dateisysteme-page">
		<div class='row  justify-content-center text-center my-4 mx-0'>
			<header class="headerbanner">
				<div class='col'>
					<h1 class="title mb-lg-4 text-white">
						UNIX Dateisysteme
					</h1>
					<div class='text-uppercase text-light' style='letter-spacing: 0.1rem;'>
						<img alt='@isotopp@infosec.exchange image' src='/assets/img/avatars/isotopp.jpg' class='me-1 p-0'
						     style='width: 1.9rem; border-radius: 1rem;'>
						<a href="https://infosec.exchange/@isotopp" class='text-light text-decoration-none'>
							Kristian Köhntopp
						</a>
						
						<span class='d-none d-lg-inline'>-</span>
						<div class='d-block d-lg-inline'>February 1, 1994</div>
						
					</div>
				</div>
				
				<img alt='a featured image' src="/assets/img/background/rijksmuseum.jpg">
				
			</header>
		</div>

		<div class='row justify-content-center mx-0'>
			<div class='col-lg-4 text-center text-lg-start'>
				
				<div>
					<div class='letter-spacing-01 text-uppercase text-secondary'>
						Previous Post
					</div>
					<a class='text-decoration-none' href="https://blog.koehntopp.info/1993/04/01/tcpip-technik.html">TCP/IP Technik</a>
				</div>
				
			</div>

			<div class='col-lg-4 text-lg-end mt-5 mt-lg-0 text-center'>
				
				<div>
					<div class='letter-spacing-01 text-uppercase text-secondary'>
						Next Post
					</div>
					<a class='text-decoration-none' href="https://blog.koehntopp.info/1995/02/01/datenuebertragung.html">Grundlagen der Datenübertragung</a>
				</div>
				
			</div>
		</div>

		<div class='row justify-content-center mx-0 mt-3 mb-5'>
			<div class="col-lg-8 mb-3">
				
			</div>
			<div class='col-lg-8'>
				<h1 id="unix-dateisysteme">
    <a href="#unix-dateisysteme">
	UNIX Dateisysteme
    </a>
</h1>
<p><strong>aus »c&rsquo;t - Magazin für Computertechnik«, Ausgabe 2/94</strong></p>
<p><em>Die Aufgaben eines Betriebssystems bestehen in der fairen Zuteilung der Systemressourcen an alle Bewerber und in der Abstraktion unterschiedlichster Hardware zu einer virtuellen Maschine.
Für den Bereich der Plattenplatzverwaltung hat diese Aufgabe das Dateisystem.
UNIX Dateisysteme haben eine mehr als zwanzigjährige Entwicklung hinter sich und dienten als Vorbild für die Dateisysteme vieler anderer Betriebssysteme.
Trotz vieler Mängel der ursprünglichen Implementation haben sich die dahinter stehenden Ideen in den letzten zwanzig Jahren nicht wesentlich verändert.</em></p>
<h2 id="daten-wiederfinden">
    <a href="#daten-wiederfinden">
	Daten wiederfinden
    </a>
</h2>
<p>UNIX schlägt sich auf den höheren Ebenen des Betriebssystems nicht mit Angaben zur Plattengeometrie herum.
Es betrachtet eine Festplatte als ein langes Band von Plattenblöcken, die linear durchnummeriert sind.
Die Umrechnung von linearen Blockadressen in Angaben von Zylinder, Kopf und Sektor ist entweder Aufgabe eines Festplattengerätetreibers
oder - im Fall von SCSI - der Festplatte selbst.
Die ersten paar Datenblöcke einer Festplatte sind reserviert für den Bootloader und ähnliche Dinge,
die vor dem Betriebssystem geladen werden und deshalb außerhalb seiner Reichweite gelagert werden.
Der Rest der Platte wird in Form eines Dateisystems verwaltet.
UNIX operiert bei Dateisystemen mit der Blockgröße des Mediums.
Anders als bei DOS werden die Verwaltungseinheiten auf einer Platte also nicht größer, wenn man sehr große Partitionen anlegt.</p>
<p>Den Anfang eines Dateisystems bildet der sogenannte Superblock, der das Dateisystem selbst beschreibt.
Er enthält Geometriedaten der Platte, gibt an, wie viele Blöcke das Dateisystem enthält und welche davon Verwaltungsinformationen und welche Daten enthalten.</p>
<p><p class="md__image">
  <img src="/uploads/1994/02/disklayout.gif" alt=""  />
</p>

</p>
<p><em>Bild 1: Am Anfang des Dateisystems steht der Superblock.
Er enthält alle Metainformationen, die das Dateisystem beschreiben.
Der &ldquo;vordere&rdquo; Teil des Dateisystems enthält I-Nodes, Dateiköpfe, die alle Metainformationen über eine Datei speichern.
In den Datenblöcken sind dann die eigentlichen Nutzdaten untergebracht.
Das Bild zeigt eine I-Node mit ihren Verweisen auf die Datenblöcke der Datei.</em></p>
<p>Die Basis der Dateiverwaltung bildet in UNIX eine Datenstruktur, die sogenannte <em>index node</em> oder I-Node (Bild 2).</p>
<p>In ihr sind - mit einer Ausnahme, dem Dateinamen - alle wesentlichen Informationen über eine Datei gesammelt.
Für jede Datei, jedes Verzeichnis und jedes Gerät legt UNIX eine I-Node an, in der es alles vermerkt, was es über dieses Datenobjekt weiß.
Dazu gehören zum einen Informationen über Zugriffsrechte, Dateieigentümer und Zeitmarken, zum anderen Verweise auf die Datenblöcke, die die Daten der Datei enthalten.
Ursprünglich hat UNIX die I-Nodes eines Dateisystems in Form einer Tabelle zusammengefasst und am Anfang des Dateisystems untergebracht.</p>
<p>Die Größe dieser Tabelle muss schon beim Anlegen des Dateisystems festgelegt werden,
d.h. ein Systemverwalter auf einem UNIX-Rechner muss beim Formatieren einer Platte festlegen,
wie viele Dateien später einmal maximal auf dieser Platte angelegt werden können.
Üblicherweise berechnet man mindestens eine I-Node für jeweils 4 KB zur Verfügung stehenden Plattenplatz,
sodass auf einer 200 MB Festplatte in etwa 50 000 I-Nodes angelegt werden.
Zum Glück sind I-Nodes relativ kleine Datenstrukturen von nur 128 Bytes.
Im Schnitt verschwinden also auf diese Weise 3 % des gesamten Plattenplatzes in Verwaltungsinformationen.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-console" data-lang="console"><span class="line"><span class="cl"><span class="go">struct  dinode
</span></span></span><span class="line"><span class="cl"><span class="go">{
</span></span></span><span class="line"><span class="cl"><span class="go">/*	Typ     Feldname          Byte-Offset: Beschreibung */
</span></span></span><span class="line"><span class="cl"><span class="go">	u_short ino_mode;        /*  0: Dateityp und Zugriffsrechte */
</span></span></span><span class="line"><span class="cl"><span class="go">	short   ino_nlink;       /*  2: Anzahl der Namen der Datei  */
</span></span></span><span class="line"><span class="cl"><span class="go">        uid_t   ino_uid;         /*  4: Benutzernummer Dateieigentümer */
</span></span></span><span class="line"><span class="cl"><span class="go">	gid_t   ino_gid;         /*  6: Gruppennummer Dateieigentümer */
</span></span></span><span class="line"><span class="cl"><span class="go">	off_t   ino_size;        /*  8: Größe in Bytes */
</span></span></span><span class="line"><span class="cl"><span class="go">	time_t  ino_atime;       /* 16: Zeit des letzten Lesezugriffs */
</span></span></span><span class="line"><span class="cl"><span class="go">	long    ino_atspare;     /*     in Sekunden seit 1.1.1970, 0 Uhr */
</span></span></span><span class="line"><span class="cl"><span class="go">	time_t  ino_mtime;       /* 24: Zeit des letzten Schreibzugriffs */
</span></span></span><span class="line"><span class="cl"><span class="go">	long    ino_mtspare;
</span></span></span><span class="line"><span class="cl"><span class="go">	time_t  ino_ctime;       /* 32: Zeit der letzten Statusänderung */
</span></span></span><span class="line"><span class="cl"><span class="go">	long    ino_ctspare;
</span></span></span><span class="line"><span class="cl"><span class="go">        daddr_t ino_db[NDADDR];  /* 40: Blocknummern der ersten 12 Datenblöcke */
</span></span></span><span class="line"><span class="cl"><span class="go">        daddr_t ino_ib[NIADDR];  /* 88: Blocknummern der 3 indirekten Datenblöcke */
</span></span></span><span class="line"><span class="cl"><span class="go">        long    ino_blocks;      /* 100: Größe der Datei in Blöcken */
</span></span></span><span class="line"><span class="cl"><span class="go">        long    ino_gen;         /* 104: Generationsnummer (NFS) */
</span></span></span><span class="line"><span class="cl"><span class="go">};
</span></span></span></code></pre></div><p><em>Bild 2: Aufbau einer I-Node eines modernen UNIX-Dateisystems.
Die Datenstruktur paßt in ein Feld von 128 Bytes,
sodass ein Hardware-Plattenblock 8 I-Nodes halten kann.
Sie enthält alle Metainformationen über eine Datei mit Ausnahme der Namen der Datei.</em></p>
<p>Untersucht man die durchschnittliche Länge von Dateien in einem Dateisystem, dann stellt man fest, das kurze Dateien relativ häufig auftreten.
Daher versucht UNIX, die Blocknummern der ersten paar Plattenblöcke einer Datei direkt in der I-Node zu speichern.
In der I-Node aus Bild 2 werden die ersten 12 Datenblöcke einer Datei im Feld <code>ino_db[]</code> abgelegt.
Wenn über ihre I-Nodenummer auf diese Datei zugegriffen wird, stehen die 12 direkten Datenblöcke der Datei also ohne weitere Leseoperation zur Verfügung.</p>
<p>Für große Dateien ist dieses Verfahren natürlich nicht praktikabel, denn die I-Node würde dann sehr groß werden.
Wächst eine Datei über die Größe von 12 Datenblöcken hinaus,
besorgt UNIX einen freien Datenblock und trägt diesen als ersten indirekten Datenblock einer Datei ein.
In diesem indirekten Datenblock werden jetzt die Blocknummern der weiteren Datenblöcke einer Datei abgelegt.
Bei einer angenommenen Blockgröße von einem Kilobyte können in einem indirekten Block 256 Blocknummern gespeichert werden,
von denen jede einen Datenblock von einem Kilobyte adressiert.
Zusammen mit den direkten Datenblöcken können also Dateien bis zu einer Größe von 266 KB angelegt werden,
ohne daß mehr als eine Ebene der Indirektion durchlaufen werden muss.
Modernere Dateisysteme, die mit einer Blockgröße von 8 Kilobyte arbeiten, bringen 2048 Blocknummern in einem Block unter
und können so bis zu 16 Megabyte große Dateien mit einem einzigen indirekten Block verwalten.</p>
<p>Für noch größere Dateien sieht UNIX doppelt indirekte Blöcke vor, die die Blocknummern von einfach indirekten Blöcken enthalten.
Diese wiederum zeigen dann endlich auf die Daten.
Bei einer Blockgröße von 8 KB kann man mit diesem Schema schon mehr als die vier Gigabyte verwalten,
die sich im Größenfeld <code>ino_size</code> einer I-Node verwalten lassen.
Bei Dateisystemen mit einer Blockgröße von einem Kilobyte muss dagegen ab einer Dateigröße von 64 MB
von einem dreifach indirekten Block Gebrauch gemacht werden (Bild 3).
Zum Glück sind zum Laden eines solchen Datenblockes aber keine vier Plattenzugriffe notwendig,
denn alle UNIX-Versionen haben einen Plattencache, der häufig benötigte Daten im RAM präsent hält.</p>
<p><p class="md__image">
  <img src="/uploads/1994/02/filestructure.gif" alt=""  />
</p>

</p>
<p><em>Bild 3: Von der I-Node zu den Datenblöcken einer Datei</em></p>
<p>Bei der Belegung von Plattenblöcken für eine Datei ist UNIX sehr effizient.
Nur diejenigen Blöcke einer Datei, die schon einmal beschrieben wurden, belegen auch wirklich Platz auf der Platte.
Wird beispielsweise begonnen, einen doppelt indirekten Block zu verwenden,
so wird für diesen zunächst der erste einfach indirekte Block beschafft und belegt.
Die Blocknummern der anderen indirekten Blöcke werden dagegen einfach auf Null gesetzt.</p>
<p>Das führt zu interessanten Effekten bei Dateien, die nicht durchgehend beschrieben werden:
Legt man unter UNIX eine neue Datei an und bewegt dann den Dateizeiger irgendwo in die oberen Megabytes,
um dort ein einziges Byte zu beschreiben, dann wird nur der eine Datenblock belegt,
der notwendig ist, um dieses Byte zu speichern (plus der möglicherweise notwendigen indirekten Blöcke, die notwendig sind, um den Block zu erreichen).
Die Blocknummer aller anderen nicht verwendeten Blöcke bleiben auf Null stehen
und es werden auch keine Datenblöcke zwischen dem gespeicherten Byte und dem Dateianfang angefordert.
Es entsteht eine Datei, die in der Verzeichnisausgabe viele Megabytes groß erscheint, in Wirklichkeit aber nur wenige Kilobytes belegt.
Eine solche Datei nennt man in UNIX eine dünn besetzte Datei (sparse file).
Beim Lesen einer solchen Datei werden für die nicht vorhandenen Blöcke entsprechend viele Nullbytes zurückgemeldet.</p>
<p>Das kann beim Kopieren oder Sichern solcher Dateien natürlich zu seltsamen Effekten führen, wenn man nicht aufpasst:
Beim naiven Kopieren wird eine Datei von vorne nach hinten durchgelesen und die gelesenen Daten werden in die Zieldatei geschrieben.
Während eine dünn besetzte Quelldatei also möglicherweise nur wenige Blöcke wirklich belegt, wird die Zieldatei von vorne nach hinten beschrieben und belegt dann wirklich so viel Platz, wie im Verzeichnis angegeben.
Dateien, die ein Abbild eines häufig ebenfalls dünn besetzten Prozessadressraumes darstellen, sind oft sparse files:
Die shared libraries in einem Linux-System oder Speicherabzüge von gecrashten Programmen unter SunOS sollten tunlichst nicht naiv kopiert werden.</p>
<h2 id="dateinamen">
    <a href="#dateinamen">
	Dateinamen
    </a>
</h2>
<p>Die I-Node enthält gesammelt alle Informationen, die UNIX über eine Datei hat, mit einer Ausnahme: dem Dateinamen.
Dateinamen speichert UNIX in besonderen Dateien, den Verzeichnissen.
Ein Verzeichnis ist n jeder Hinsicht eine normale Datei mit einer I-Node, Datenblöcken und so weiter.
Verzeichnisdateien werden jedoch nicht von Benutzerprogrammen, sondern ausschließlich vom Betriebssystem verwaltet.
Es unterhält in einem Verzeichnis eine feste Satzstruktur.</p>
<p>Beim älteren UNIX-Dateisystem ist diese sehr einfach aufgebaut:
Ein Verzeichnis besteht aus Datensätzen zu 16 Byte Länge.
Die ersten 2 Byte enthalten die I-Nodenummer einer Datei, die folgenden 14 Byte nehmen einen Dateinamen auf.
Falls ein Dateiname kürzer als 14 Zeichen ist, wird er einfach mit Nullbytes aufgefüllt.
Bei moderneren UNIX-Systemen ist die Verzeichnisstruktur etwas komplizierter, um 4 Byte lange I-Nodenummern und bis zu 255 Byte lange Dateinamen ohne große Platzverschwendung verwalten zu können, aber im Prinzip handelt es sich immer noch um eine einfache Zuordnung von Name zu I-Nodenummer.</p>
<p>Es ist in UNIX ohne weiteres möglich, mehr als einen Dateinamen für eine Datei zu vergeben.
Dazu wird einfach mit der Systemfunktion link() in einem weiteren Verzeichnis ein Namenseintrag gemacht, der dieselbe I-Nodenummer hat wie der erste Name der Datei.
Im Feld <code>ino_nlink</code> einer I-Node wird die Anzahl der Namen einer Datei gezählt.
Beide Namen einer Datei sind gleichberechtigt und nicht voneinander zu unterscheiden:
Man kann nicht sagen, welcher von zwei Namen einer Datei der erste und welcher der zweite Name der Datei war.
Anstatt eine Datei zu löschen, kann man in UNIX nur die Anzahl ihrer Namen um Eins vermindern.
Sobald die Anzahl der Namen einer Datei Null wird, gibt das Betriebssystem dem Plattenplatz frei, der zu einer Datei gehört.</p>
<p><p class="md__image">
  <img src="/uploads/1994/02/verzeichnis.gif" alt=""  />
</p>


<em>Bild 4: Das alte System V UNIX Dateisystem behandelt Verzeichnisse als gewöhnliche Dateien mit einer festen Satzstruktur von 16 Byte. Die ersten beiden Byte enthalten die I-Node Nummer einer Datei, die folgenden 14 Bytes stellen den Namen der Datei (mit Nullbytes aufgefüllt) dar.</em></p>
<p><em>Im BSD Dateisystem sind längere Dateinamen erlaubt. Um die Platzverschwendung zu minimieren, ist die Struktur eines Verzeichnisses etwas komplizierter, aber das Prinzip der Zuordnung eines Namens zu einer
I-Nodenummer wird nicht verletzt.</em></p>
<p>Um eine Datei zu öffnen, muss ihr Name in eine I-Nodenummer übersetzt werden.
Nach dem Öffnen der Datei arbeitet das Betriebssystem dann intern ausschließlich mit der I-Nodenummer weiter.
Die Übersetzung von Namen in Nodenummern wird in UNIX an einer zentralen Stelle im Betriebssystemkern abgehandelt, in der Kern-internen Funktion <code>namei()</code>.
Für jeden Prozess verwaltet UNIX in der Prozessstruktur zwei Einträge, in denen die I-Nodenummer des Hauptverzeichnisses und des aktuellen Verzeichnisses dieses Prozesses hinterlegt sind.
Wenn dem Betriebssystem in einem Systemaufruf ein Pfadname übermittelt wird, wird zunächst geprüft, ob es sich um einen absoluten oder relativen Pfadnamen handelt.
Je nachdem, ob der Pfadname mit einem führenden &ldquo;<code>/</code>&rdquo; beginnt, wird entweder im Hauptverzeichnis oder im aktuellen Verzeichnis des Prozesses begonnen, den Pfadnamen aufzulösen.
<code>namei()</code> isoliert dazu die erste Komponente des Pfadnamens und sucht diese im Startverzeichnis der Suche.
Sobald der gesuchte Namenseintrag dort gefunden ist, kann die zugehörige I-Nodenummer abgelesen werden und das nächste Stück des Pfadnamens aufgelöst werden.</p>
<p>In Bild 5 ist zu sehen, was bei der Auflösung eines Pfadnamens wie &ldquo;<code>/bin/ls</code>&rdquo; passiert:
Weil der Pfadname mit einem &ldquo;<code>/</code>&rdquo; beginnt, durchsucht <code>namei()</code> das Hauptverzeichnis des Prozesses, der den Systemaufruf getätigt hat, nach einem Eintrag für &ldquo;<code>bin</code>&rdquo;.
Sobald die I-Nodenummer für das &ldquo;<code>bin</code>&quot;-Verzeichnis gefunden ist, kann es nach einem Eintrag für &ldquo;<code>ls</code>&rdquo; durchsucht werden.
Erst wenn die I-Nodenummer von &ldquo;<code>ls</code>&rdquo; bekannt ist, kann die Datei geöffnet oder geladen werden.
Bei der Auflösung von Pfadnamen ergibt sich also eine wechselseitige Verkettung von Datenblöcken und I-Nodes: I-Nodes enthalten Zeiger auf Datenblöcke und die Datenblöcke eines Verzeichnisses enthalten Zeiger auf I-Nodes.</p>
<p><p class="md__image">
  <img src="/uploads/1994/02/nameiresolver.gif" alt=""  />
</p>

</p>
<p><em>Bild 5: Zugriffe beim Auflösen eines Pfadnamens</em></p>
<h2 id="zugriffsrechte">
    <a href="#zugriffsrechte">
	Zugriffsrechte
    </a>
</h2>
<p>In der I-Node existiert ein Feld <code>ino_mode</code>.
Es enthält neben anderen Informationen 9 Bits, die die Zugriffsrechte auf die Datei festlegen.
UNIX unterscheidet an jedem Objekt im Dateisystem 3 Rechte: r-Recht bestimmt, ob eine Datei zu Lesen geöffnet werden darf, w-Recht bestimmt, ob eine Datei beschrieben werden darf und x-Recht bestimmt, ob eine Datei ausgeführt werden kann.
Diese Rechte rwx sind jeweils einmal für den Eigentümer der Datei, für Angehörige seiner Benutzergruppe und für den Rest der Welt vorhanden, sodass sich insgesamt 9 Rechte-Bits ergeben.</p>
<p>Da Verzeichnisse auch Dateien sind, haben auch sie diese Zugriffsrechte.
In Zusammenhang mit Verzeichnissen werden sie jedoch etwas anders interpretiert: r-Recht an einem Verzeichnis erlaubt einem Benutzer, die Namensliste eines Verzeichnisses zu lesen.
w-Recht an einem Verzeichnis gestattet es ihm, Dateien anzulegen oder zu löschen.
x-Recht schließlich ist notwendig, um auf die Dateien in einem Verzeichnis zuzugreifen. In Bild 5 ist zu sehen, an welchen Stellen welche Zugriffsrechte geprüft werden, wenn die Datei &ldquo;<code>/bin/ls</code>&rdquo; zum Lesen geöffnet werden soll:
Zunächst einmal muss am Hauptverzeichnis x-Recht vorhanden sein, damit auf die Datei &ldquo;<code>bin</code>&rdquo; zugegriffen werden kann, die im Hauptverzeichnis enthalten ist.
Danach wird auf ein x-Recht am &ldquo;<code>bin</code>&quot;-Verzeichnis geprüft, um auf die Datei &ldquo;<code>ls</code>&rdquo; zugreifen zu können.
Und schließlich muss an der Datei &ldquo;<code>ls</code>&rdquo; selbst noch r-Recht vorhanden sein, damit auf die Datenblöcke der Datei lesen zugegriffen werden darf.</p>
<p>x-Recht an einem Verzeichnis ist also immer dann erforderlich, wenn <code>namei()</code> einem Zeiger aus diesem Verzeichnis in die I-Nodetabelle folgen muss.
In Bild 5 sind diese aufwärts führenden Pfeile etwas dicker hervorgehoben.</p>
<h2 id="fragmente">
    <a href="#fragmente">
	Fragmente
    </a>
</h2>
<p>Dateisysteme verwalten den Plattenplatz in Form von Blöcken fester Größe.
Deswegen ist am Ende der meisten Dateien ein Block vorhanden, der nicht ganz ausgenutzt werden kann, denn bei den meisten Dateien ist die Dateilänge nicht genau ein Vielfaches der Blockgröße des Dateisystems.
So geht, abhängig von der mittleren Dateigröße und der Blockgröße des Dateisystems ein mehr oder weniger großer Anteil des Plattenplatzes verloren.
Je kleiner die Verwaltungseinheiten des Dateisystems sind, umso effektiver kann es seinen Platz verwalten.
Andererseits ist der Datendurchsatz eines Dateisystems um so größer, je größer die Blöcke sind, die es verwaltet.
Und schließlich kann man bei der Verwendung von großen Datenblöcken oft mehrfach indirekte Blöcke einsparen und macht das Dateisystem auf diese Weise schneller und reduziert den Verwaltungsaufwand.
In modernen UNIX-Dateisystem löst man dieses Dilemma, indem man ein Dateisystem mit einer relativ großen Blockgröße (meistens 8 Kilobyte) anlegt, Dateienden aber in speziellen Blöcken, den Fragmenten, speichert.
Fragmente werden erzeugt, in dem man einen normalen Plattenblock in mehrere gleich grosse Teilblöcke unterteilt, die jeweils das Dateiende einer anderen Datei aufnehmen können.</p>
<p><p class="md__image">
  <img src="/uploads/1994/02/bsdfragment.gif" alt=""  />
</p>

</p>
<p><em>Bild 6: Zwei Dateienden in einem fragmentierten Block</em></p>
<p>Auf diese Weise werden die Dateienden verschiedener Dateien praktisch in einem Block zusammen komprimiert und der Verlust an Plattenplatz durch nicht ausgenutzte Blöcke wird reduziert.
Trotzdem kann das Dateisystem die meiste Zeit mit vollständigen, großen Blöcken arbeiten und so hohe Geschwindigkeiten erreichen.
Der Nachteil dieses Systems ist, daß ein Dateiende unter Umständen mehrfach umkopiert werden muss, wenn eine Datei wächst:
Zunächst passt das Dateiende noch in sein Fragment hinein, wenn es wächst, muss jedoch ein größeres Fragment gesucht werden, das jedoch durch weitere Schreiboperationen sofort wieder überläuft, bis die Datei endlich den nächsten vollständigen Block füllt.
Solche Kopieroperationen lassen sich vermeiden, wenn Anwendungsprogramme ihre Schreiboperationen der Blockgröße des Dateisystems anpassen.
Da so etwas sehr unbequem ist, wenn man es selber programmieren muss, nimmt die C-Standardbibliothek in einem UNIX-System einem diese Arbeit ab:
Sie fragt die Blockgröße des unterliegenden Dateisystems ab und stimmt ihre Schreibzugriffe so ab, daß mit maximaler Geschwindigkeit geschrieben werden kann.</p>
<p>Weitere Geschwindigkeitsvorteile lassen sich erzielen, wenn man dafür sorgen kann, daß Dateien möglichst hintereinanderliegende Blöcke auf einer Platte belegen.
Die Platte kann in diesem Fall ihren internen Cache füllen und die Daten schneller abliefern.
Außerdem entfallen Bewegungen des Schreib-/Lesekopfes der Platte.
Wie man am Beispiel von DOS sehen kann, ist es leider ist es nicht damit getan, die Blöcke einer Datei hintereinander anzuordnen.
Man muss ausserdem auch Platz lassen, damit Dateien wachsen können.</p>
<p><p class="md__image">
  <img src="/uploads/1994/02/fragmentierung.gif" alt=""  />
</p>

</p>
<p><em>Bild 7: Durch unkluge Anordnung von Daten zerstückelt MS-DOS Dateien in kleine, nicht zusammenhängende Fragmente.</em></p>
<p>Moderne UNIX-Dateisysteme unterteilen eine Festplatte deswegen in Streifen von einigen Megabyte Größe, sogenannte cylinder groups.
Jeder dieser Streifen enthält eine eigene kleine I-Nodetabelle und seinen Anteil an Datenblöcken.
Neue Dateien werden in derjenigen Zylindergruppe angelegt, die im Verhältnis am meisten freie Datenblöcke aufzuweisen hat.
Dadurch wird sichergestellt, daß solche Dateien gerade nicht direkt hintereinanderliegen, sondern genügend freien Platz haben, um zu wachsen.
Bei sehr langen Dateien wird außerdem nach dem Schreiben von jeweils einem Megabyte an Daten ein Wechsel der Zylindergruppe erzwungen:
Man geht davon aus, daß man sehr lange Dateien sowieso nicht in einem Stück zusammenhängend lagern kann.
Stattdessen versucht man, die einzelnen Stücke möglichst groß zu machen.</p>
<p><p class="md__image">
  <img src="/uploads/1994/02/bsdlayout.gif" alt=""  />
</p>

</p>
<p><em>Bild 8: Das BSD Fast Filing System unterteilt die Platte in Streifen von einigen MB Größe. Das Betriebssystem versucht durch verschiedene Verfahren,
das Verhältnis von belegten Datenblöcken zu belegten I-Nodes in allen cylinder groups einer Platte in etwa ausgewogen zu halten. Dadurch ist das Dateisystem effektiv selbst defragmentierend.</em></p>
<p>Außerdem würde eine sehr lange Datei alle Datenblöcke, aber nur eine einzige I-Node in einer Zylindergruppe belegen.
Die Daten zu den I-Nodes aller weiteren Dateien in derselben Zylindergruppe müssten dann auf andere Zylindergruppen verlagert werden, was dort wiederum das ausgewogene Verhältnis zwischen freien I-Nodes und freien Datenblöcken stören würde.
Dadurch, dass man jeweils ein Megabyte einer sehr großen Datei auf eine andere Zylindergruppe verlagert, wird der Platz auf der Platte gleichmäßig verbraucht.
Man verhindert, daß andere Dateien dann nicht mehr günstig auf der Platte angeordnet werden können.</p>
<h2 id="abgeleitete-dateisysteme">
    <a href="#abgeleitete-dateisysteme">
	Abgeleitete Dateisysteme
    </a>
</h2>
<p>Die grundlegenden Strukturen des UNIX-Dateisystems wurden von Ritchie und Thompson vor 20 Jahren in den Laboratorien von AT&amp;T entwickelt und haben sich grundsätzlich bewährt.
Selbst das Entwicklerteam von BSD UNIX, das das Dateisystem vor 10 Jahren einer gründlichen Überarbeitung unterzogen hat, hat die zugrundeliegenden Ideen nicht verändert, sondern UNIX lediglich beigebracht, auf die Geometrie der Platte Rücksicht zu nehmen, um weitere Geschwindigkeitsgewinne zu erzielen.</p>
<p>Das UNIX-Dateisystem ist dem nur halb so alten, aber wesentlich weniger effektiv organisierten MS-DOS Dateisystem in Sachen Geschwindigkeit, Zugriffsschutz und Benutzerfreundlichkeit weit überlegen.
Die Ideen der UNIX-Entwickler waren letztlich so überzeugend, daß sie sich letztendlich im OS/2 HPFS und schließlich auch im Dateisystem von Windows NT wiederfinden.</p>
<p><p class="md__image">
  <img src="/uploads/1994/02/mount.gif" alt=""  />
</p>

</p>
<p><em>Bild 9: 26 Laufwerksbuchstaben wären für eine gut ausgelastete Workstation viel zu wenig. UNIX kennt deswegen nur einen einzigen Dateibaum. Beim Anmelden (mounten) eines Dateisystems wird eine Platte an einer
bestimmten Stelle in den Verzeichnisbaum eingehängt. Beim Wechsel des Verzeichnisses wechselt man so auch gleich die Platte oder bei Netzwerkplatten sogar den Rechner, auf dem man aktiv ist.</em></p>
<h1 id="literatur">
    <a href="#literatur">
	Literatur
    </a>
</h1>
<ul>
<li>&ldquo;The UNIX Time Sharing System&rdquo;, Ritchie, Thompson, Communications of the ACM 7/74, p.365</li>
<li>&ldquo;A Fast File System for UNIX&rdquo;, McKusick et al, ACM Trans. on Computer Systems, August 84, p.181</li>
<li>&ldquo;Operating Systems&rdquo;, A. Tanenbaum, Prentice-Hall</li>
<li>&ldquo;The Design of the UNIX Operating System&rdquo;, M. Bach, Prentice-Hall</li>
<li>&ldquo;The Design of the 4.3 BSD UNIX Operating System&rdquo;, McKusick, Addison-Wesley</li>
<li>&ldquo;Advanced Programming in the UNIX Environment,&rdquo; W. R. Stevens, Addison-Wesley</li>
</ul>

			</div>
		</div>

		
		
		<div class='row justify-content-center py-3 mb-3 mx-0'>
			<div class='col-lg-8 text-center'>
				<span class='letter-spacing-01 text-uppercase text-secondary me-2'>Tags</span>
				
				<a href="/tags/#lang_de" class='btn btn-sm btn-outline-primary mb-1'>
				<svg class="bi" width="1rem" height="1rem" fill="currentColor">
					<use xlink:href="/bootstrap-icons.svg#tag-fill"></use>
				</svg>
				lang_de
				</a>
				
				<a href="/tags/#publication" class='btn btn-sm btn-outline-primary mb-1'>
				<svg class="bi" width="1rem" height="1rem" fill="currentColor">
					<use xlink:href="/bootstrap-icons.svg#tag-fill"></use>
				</svg>
				publication
				</a>
				
				<a href="/tags/#unix" class='btn btn-sm btn-outline-primary mb-1'>
				<svg class="bi" width="1rem" height="1rem" fill="currentColor">
					<use xlink:href="/bootstrap-icons.svg#tag-fill"></use>
				</svg>
				unix
				</a>
				
			</div>
		</div>

		
		
		
		
		<div class='row justify-content-center py-3 mb-3 mx-0'>
			<div class='col-lg-8 text-center'>
				<a href="https://github.com/isotopp/isotopp.github.io/edit/main/content/posts/1994-02-01-dateisysteme.md"
				   rel="noopener noreferrer" target="_blank">
					<span class='letter-spacing-01 text-uppercase text-secondary me-2'>Suggest Changes</span>
				</a>
			</div>
		</div>
		

		<div class='row justify-content-center mx-0'>
			<div class='col-lg-4 text-center text-lg-start'>
				
				<div>
					<div class='letter-spacing-01 text-uppercase text-secondary'>
						Previous Post
					</div>
					<a class='text-decoration-none' href="https://blog.koehntopp.info/1993/04/01/tcpip-technik.html">TCP/IP Technik</a>
				</div>
				
			</div>

			<div class='col-lg-4 text-lg-end mt-5 mt-lg-0 text-center'>
				
				<div>
					<div class='letter-spacing-01 text-uppercase text-secondary'>
						Next Post
					</div>
					<a class='text-decoration-none' href="https://blog.koehntopp.info/1995/02/01/datenuebertragung.html">Grundlagen der Datenübertragung</a>
				</div>
				
			</div>
		</div>


		
	</article>
</div>



            <footer class='row justify-content-center mb-4 pb-4 mx-0'>
  <div class='col-8 text-center'>
    <div>
      A collection of old stuff, new stuff and random stuff.
    </div>
    <div class='row text-primary mt-4'>
      <div class='col'>

        <a href='/feed.xml' title='Follow RSS feed' class='me-3 text-decoration-none'>
          <svg class='bi' height='2.5rem' width='2.5rem' fill='currentColor'>
            <use xlink:href='/bootstrap-icons.svg#rss-fill'/>
          </svg>
        </a>

        <a href='mailto:kristian.koehntopp@gmail.com' title='Email' class='me-3 text-decoration-none'>
          <svg class='bi' height='2.5rem' width='2.5rem' fill='currentColor'>
            <use xlink:href='/bootstrap-icons.svg#envelope'/>
          </svg>
        </a>

        <a href='https://github.com/isotopp' title='Follow on GitHub' class='me-3 text-decoration-none'>
          <svg class='bi' height='2.5rem' width='2.5rem' fill='currentColor'>
            <use xlink:href='/bootstrap-icons.svg#github'/>
          </svg>
        </a>

        <a rel="me" href="https://infosec.exchange/@isotopp" title='Follow on Mastodon' class='me-3 text-decoration-none'>
          <svg class='bi' height='2.5rem' width='2.5rem' fill='currentColor'>
            <use xlink:href='/bootstrap-icons.svg#mastodon'/>
          </svg>
        </a>

        
        <a href='http://steamcommunity.com/id/ixotopp' title='Follow on Steam' class='me-3 text-decoration-none'>
          <svg class='bi' height='2.5rem' width='2.5rem' fill='currentColor'>
            <use xlink:href='/bootstrap-icons.svg#steam'/>
          </svg>
        </a>

        

        <a href='https://www.youtube.com/user/isotopp' title='Follow on YouTube' class=''>
          <svg class='bi' height='2.5rem' width='2.5rem' fill='currentColor'>
            <use xlink:href='/bootstrap-icons.svg#youtube'/>
          </svg>
        </a>
      </div>
    </div>
  </div>
</footer>


        </main>

	





<script src="https://blog.koehntopp.info/js/bootstrap.js"></script>




<script src="https://blog.koehntopp.info/js/lunr.js"></script>





<script src="https://blog.koehntopp.info/js/app.js"></script>


    </body>
</html>
